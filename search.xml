<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux操作系统03--vim操作、ssh</title>
    <url>/jwangcloud/2793636500/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/Linux.jpeg"></p>
<h2 id="翻墙基础知识"><a href="#翻墙基础知识" class="headerlink" title="翻墙基础知识"></a>翻墙基础知识</h2><span id="more"></span>
<p>1.海底光缆：CN1（日本）CN2（美国加州） GIA</p>
<p>2.端口 ：一台服务器（一个IP）可有多个程序或功能，每一个程序或功能都会被分配一个不可重复的端口，端口号1024已经被系统应用占据，我们可以使用1024-65535之间的端口号，配置多个端口需写一个配置文件.</p>
<p>3.墙：国家监管，若浏览不正当网站会直接关闭</p>
<p>4.解决“墙”的问题：</p>
<pre><code>              加密      解密
解决方案： 本地 ----&gt; 墙 ----&gt; 美国服务器
       （加密软件）          （解密软件）
</code></pre>
<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><ol>
<li><p>ssh:加密登录方式（多用于银行，军队），我们常用的https就是一个加密协议，不会被监控</p>
</li>
<li><p>加密方式：RSA加密  （第一个加密方式：凯撒加密CASER，常见加密方式BASE 64）</p>
</li>
<li><p>RSA原理：双方交换公钥，但保留私钥，用私钥加密，公钥解密</p>
</li>
<li><p>查看密钥 ：其保存在～/.ssh/文件夹中 使用less命令拷贝密钥</p>
</li>
<li><p>创建密钥 ：ssh -keygen</p>
</li>
<li><p>交换密钥：ssh-copy-id root@对方ip -p 端口号</p>
<pre><code> 若失败，需要重新创建密钥
 若成功，运行：ssh root@对方ip -p 端口号 可免密码登录
</code></pre>
</li>
<li><p>使用ssh远程拷贝文件：scp -P 端口 文件名 root@远程服务器ip:绝对路径</p>
</li>
</ol>
<h2 id="实现步骤（简易版单人）"><a href="#实现步骤（简易版单人）" class="headerlink" title="实现步骤（简易版单人）"></a>实现步骤（简易版单人）</h2><p>1.登陆远程服务器：ssh root@远程服务器ip地址 -p 端口 （需要输入远程服务器密码，在买服务器网站的个人信息中）</p>
<p>2.安装解密软件： pip install shadowsocks  (远程服务器上)</p>
<p>3.设置端口、密码：ssserver -p 端口 -k 密码 -m 加密方式  （远程服务器）</p>
<p>4.本地下载加密软件： 官网下载shadowsocks-NG </p>
<h2 id="Linux文档编辑器（vim）"><a href="#Linux文档编辑器（vim）" class="headerlink" title="Linux文档编辑器（vim）"></a>Linux文档编辑器（vim）</h2><h3 id="vim-基础"><a href="#vim-基础" class="headerlink" title="vim 基础"></a>vim 基础</h3><ol>
<li>安装vim：yum install vim </li>
<li>确认是否安装：vi   (Shift+q :退出)</li>
<li>vim text.txt ：新建txt文件并编辑</li>
<li>vim两种模式<pre><code> 输入模式：可以在其中输入文本，与文档编辑器一样，esc键退出该模式，esc+i:进入该模式，esa+a:在光标之后进入该模式
 命令模式：只能进行命令操作，shift+: 进入长命令输入，下方
</code></pre>
</li>
</ol>
<h3 id="vim常用命令"><a href="#vim常用命令" class="headerlink" title="vim常用命令"></a>vim常用命令</h3><ol>
<li>x: 消除光标之前字符</li>
<li>hjkl:上下左右移动</li>
<li>yy:复制光标所在行内容</li>
<li>p:粘贴复制内容</li>
<li>dd:删除光标所在行内容</li>
<li>N（数字键）+ yy/dd:批量复制/删除光标之下的N行</li>
<li>u:撤销上一步操作</li>
<li>I：将光标移到光标所在行行首，并进入编辑模式</li>
<li>A：光标移到行尾</li>
<li>shift+:下输入wq:保存并退出（进入直接：vim 文件名）</li>
<li>数字(N) gg：光标移到第N行；gg:跳到首行</li>
<li>o:在光标下新开一行并进入编辑模式</li>
</ol>
<h2 id="高级步骤（多人端口版）"><a href="#高级步骤（多人端口版）" class="headerlink" title="高级步骤（多人端口版）"></a>高级步骤（多人端口版）</h2><ol>
<li>端口文件配置shadow.conf，<pre><code> &#123;
 &quot;server&quot;:&quot;93.179.99.149&quot;,
 &quot;local_address&quot;: &quot;127.0.0.1&quot;,
 &quot;local_port&quot;:1080,
 &quot;port_password&quot;: &#123;
         &quot;55501&quot;: &quot;add55555&quot;,
         &quot;55502&quot;: &quot;add55555&quot;,
         &quot;55503&quot;: &quot;add55555&quot;（此处无逗号） 
 &#125;,
 &quot;timeout&quot;:300,
 &quot;method&quot;:&quot;aes-256-cfb&quot;,
 &quot;fast_open&quot;: false     
 
</code></pre>
</li>
<li>登陆远程服务器并在其中编写该端口文件配置</li>
<li>读取该配置文件：ssserver -c shadow.conf (该命令可先运行，检测成功性) -d start （之后运行完整命令）</li>
<li>运行成功</li>
</ol>
<pre><code>    小提示：1.su 直接切换到超级用户
            2.sudo 代替执行超级用户的权限
</code></pre>
]]></content>
      <categories>
        <category>Linux操作系统</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统01--Linux入门</title>
    <url>/jwangcloud/1737435959/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/Linux.jpeg"></p>
<h3 id="Linux版本之间的区别"><a href="#Linux版本之间的区别" class="headerlink" title="Linux版本之间的区别"></a>Linux版本之间的区别</h3><span id="more"></span>


<pre><code>             redhat  RHEL CentOs 
                     Fedora               --&gt; 稳定版本
             Debian  Ubuntu
     Linux           Mint Linux   knopix  --&gt; 最新版本
             SlackWare  SUSE   SLEs
                               openSuse
             其它发行家族 
</code></pre>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><pre><code>top : 查看电脑当前状态，比如CPU的使用率，物理内存（Physcmem）,可看作一个
任务管理器（使用q键退出）
date：日期。其中取的时区为CST 代表 中国上海
cal ：日历
echo : 将字符串输出到屏幕  &gt; ：输出重定向  &gt;&gt; : 输出追加重定向
echo &#39;hello&#39; &gt; tmp.txt : 将字符串输出重定向，若当前目录下没有该文件，
则会新建该文件并将字符串输出到文件，若存在该文件，则会覆盖该文件中的内容
echo &#39;hello&#39; &gt;&gt; tmp.txt : 与上述一样，但存在该文件时会在该文件内容后
追加字符串
2&gt; : 标准错误截获，将错误提示输出到文件中
unix时间戳（timestamp）: 以格林威治时间为准，计算机开始时间1970开始
Tab键：命令自动补全，多个相同命令则按两下，会将全部相似的命令显示在屏幕上
</code></pre>
<h3 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h3><pre><code>cd  进入目标文件夹中
cd .  当前目录
cd ..  返回上一个文件夹下
ls  查看当前所在文件夹下面所拥有的文件夹清单
pwd 查看当前所在文件夹路径，属于绝对路径
mkdir 创建文件夹
rm -r -f 删除文件夹（不可恢复）
/ 文件路径分隔符  \ 转义字符
～ 用户根目录  ./ 当前目录
ls -la 可显示隐藏文件  隐藏文件的创建为在名字前+“.”,例如：.match
less 文件名  查看文件内信息  more可查看部分文件内信息
cp 文件夹1 文件夹2  考本文件夹1到文件夹2（需要是文件夹全名）与文件操作一样
</code></pre>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><pre><code>cp -r   : 文件复制
cp -r &#123;文件1，文件2&#125; 目标文件夹   ： 拷贝多个文件到一个文件夹中
rm -rf  : 删除任何相关的文件或文件夹 删除多个使用 空格隔开或者通配符
touch   : 新建文件（使用通配符可创建多个）
mkdir -p : 可以创建一个新文件夹下创建新文件
&gt; text.txt : 创建空文件
</code></pre>
]]></content>
      <categories>
        <category>Linux操作系统</category>
      </categories>
      <tags>
        <tag>Linux入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统02--Linux权限</title>
    <url>/jwangcloud/4264740339/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/Linux.jpeg"></p>
<h2 id="进制计算"><a href="#进制计算" class="headerlink" title="进制计算"></a>进制计算</h2><span id="more"></span>    

<pre><code>二进制 ： 以111（2） 为例：1*2^0 + 1*2^1 + 1*2^2 =7 
十六进制：以16为底：0～9 A～F
三十六进制：以32为低：0-9 A-Z 除开 i o s z
</code></pre>
<h2 id="Linux权限"><a href="#Linux权限" class="headerlink" title="Linux权限"></a>Linux权限</h2><ol>
<li>例：使用ls -lh 文件属性字段显示信息如下<pre><code> d  rwx  r_x  r_x  d(文件夹) r(可读) w(可写) x(可执行) 
   111  101  101
    7    5    5
    u    g    o
  
</code></pre>
整个信息段表示：文件属性字段 文件硬链接数/目录子文件数 文件拥有者 文件拥有者所在组 文件大小（以字节为单位） 文件创建时间 文件名（–&gt;符号为指向目标文件夹）</li>
<li> 修改权限：chmod 权限的十进制 文件名 （chmod 755 1.txt）权限最高为777<br>修改文件夹权限：chmod -R</li>
<li>修改某一个权限：chmod u-x 文件名 （u-x 为 user 用户去掉可执行，还可以为u+x、u-wx、g+rx）</li>
</ol>
<h2 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h2><p>最早的字符编码表：Ascil码（不能存汉字）</p>
<p>中文编码：gbk（简体） big5(繁体)</p>
<p>世界性文字编码：unicode32  通过加工–通用编码：utf-8(可变长)、utf-16(即固定又可变)、utf-32(固定)</p>
]]></content>
      <categories>
        <category>Linux操作系统</category>
      </categories>
      <tags>
        <tag>Linux权限</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql数据库04--存储过程、触发器、事件</title>
    <url>/jwangcloud/898521826/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/mysql.jpeg"></p>
<h2 id="mysql进阶"><a href="#mysql进阶" class="headerlink" title="mysql进阶"></a>mysql进阶</h2><span id="more"></span>

<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>1.存储函数（stored function）。返回一个计算结果，该结果可以用在表达式里。<br>2.存储过程（stored procedure）。不直接返回一个结果，但可以用来完成一般的运算或是生成一个结果集并传递回客户。<br>3.触发器（trigger）。与数据表相关联，当那个数据表被INSERT、DELETE或UPDATE语句修改时，触发器将自动执行。<br>4.事件（event）。根据时间表在预定时刻自动执行。</p>
<h3 id="2-存储过程"><a href="#2-存储过程" class="headerlink" title="2.存储过程"></a>2.存储过程</h3><p>1.存储过程和存储函数的区别<br>    使用存储过程的情况主要有两种：<br>    （1）只需通过运算来实现某种效果或动作而无需返回一个值，<br>    （2）运算会返回多个结果集（函数做不到这一点）。这只是些指导性建议，不是硬性规定。<br>    存储函数要用CREATE FUNCTION语句来创建，存储过程要用CREATE PROCEDURE语句来创建，为了与数据表或数据列的名字有所区别，给参数起名字时将使用p_前缀。</p>
<p>2.分隔符,由于mysql默认分隔符是 ; 如果我们使用了;表示存储过程已经结束,但是mysql默认语句也是;结束,如果我们想要在存储过程中多加几个sql语句怎么办？我们需要先修改分割符,然后写sql语句和存储过程然后恢复到默认的分隔符。</p>
<p>3.delimiter命令把mysql程序的语句分隔符重定义为另一个字符或字符串，它必须是在存储例程的定义里没有出现过的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建存储过程：</span><br><span class="line">delimiter $</span><br><span class="line">create procedure show_born()</span><br><span class="line">begin</span><br><span class="line">select 1;</span><br><span class="line">select 2;</span><br><span class="line">end$</span><br><span class="line">delimiter ;</span><br><span class="line">存储过程调用：</span><br><span class="line">call show_born</span><br><span class="line">存储过程参数传入：</span><br><span class="line">create procedure p1 (p_id INT) begin select p_id; end$</span><br><span class="line"></span><br><span class="line">创建存储函数：</span><br><span class="line">delimiter $</span><br><span class="line">create function show()</span><br><span class="line">begin</span><br><span class="line">select 1;</span><br><span class="line">select 2;</span><br><span class="line">end$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-触发器"><a href="#3-触发器" class="headerlink" title="3.触发器"></a>3.触发器</h3><p>1.触发器是与特定数据表相关联的存储过程，当相应的数据表被INSERT、DELETE或UPDATE语句修改时，触发器将自动执行。<br>触发器可以被设置成在这几种语句处理每个数据行之前或之后触发。触发器的定义包括一条将在触发器被触发时执行的语句。</p>
<p>2.创建触发器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每次创建新值的时候,新的数据列test2都会变成999:</span><br><span class="line">create trigger test1_t before insert on test1 for each row begin set NEW.test2&#x3D;999; end$</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-事件"><a href="#4-事件" class="headerlink" title="4.事件"></a>4.事件</h3><p>1.我们可以把数据库操作安排在预定时间执行。事件是与一个时间表相关联的存储程序，时间表用来定义事件发生的时间、次数以及何时消失。事件非常适合用来执行各种无人值守的系统管理任务，如定期更新汇总报告、清理过期失效的数据、对日志数据表进行轮转等。</p>
<p>2.默认条件下，事件不会执行，需要启动事件调度器：</p>
<pre><code>把以下语句添加到一个选项文件中（服务器在启动时将读取）： [mysqld] event_scheduler=ON
</code></pre>
<p>3.查看事件调度器状态：show variables like ‘event_scheduler’</p>
<p>4.创建事件：</p>
<pre><code>create event e1 on schedule every 5 second do insert into test1 (test1)values(&#39;8888&#39;);

do 定义语句部分
</code></pre>
<p>5.事件禁用和激活</p>
<pre><code>事件禁用：
    alter event e1 disable;
事件激活：
    alter event e1 enable;
</code></pre>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql存储器</tag>
        <tag>mysql触发器</tag>
        <tag>mysql事件</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql数据库06--锁</title>
    <url>/jwangcloud/1196357161/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/mysql.jpeg"></p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><span id="more"></span>

<p>数据库锁定机制简单来说，就是数据库为了保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则。</p>
<h4 id="1-读写锁"><a href="#1-读写锁" class="headerlink" title="1.读写锁"></a>1.读写锁</h4><p>1.1 共享锁：对某一资源加共享锁，自身可以读该资源，其他人也可以读该资源（也可以再继续加共享锁，即 共享锁可多个共存），但无法修改。要想修改就必须等所有共享锁都释放完之后。</p>
<pre><code>    语法为：select * from table lock in share mode
</code></pre>
<p>1.2 排他锁：对某一资源加排他锁，自身可以进行增删改查，其他人无法进行任何操作。</p>
<pre><code>    语法为：select * from table for update --增删改自动加了排他锁
    
</code></pre>
<p>1.3 数据库规定同一资源上不能同时共存共享锁和排他锁</p>
<pre><code>命令窗1:select * from table lock in share mode
命令窗2:update table set column1=&#39;hello&#39;

在1未完成前 2无法运行：T2 之所以要等，是因为 T2 在执行 update 前，试图对 table 表加一个排他锁，而数据
库规定同一资源上不能同时共存共享锁和排他锁。所以 T2 必须等 T1 执行完，释放了全部的共享锁，才能加上排他
锁，然后才能开始执行 update 语句。
</code></pre>
<h4 id="2-锁的大小（颗粒度）"><a href="#2-锁的大小（颗粒度）" class="headerlink" title="2.锁的大小（颗粒度）"></a>2.锁的大小（颗粒度）</h4><p>2.1 表级锁定（table-level）</p>
<p>表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎。</p>
<p>2.2 行级锁定（row-level）</p>
<p>行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。使用行级锁定的主要是InnoDB存储引擎。</p>
<p>2.3 页级锁定（page-level）</p>
<p>页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。使用页级锁定的主要是BerkeleyDB存储引擎。</p>
<h4 id="3-myisam的锁"><a href="#3-myisam的锁" class="headerlink" title="3.myisam的锁"></a>3.myisam的锁</h4><p>由于MyISAM存储引擎使用的锁定机制完全是由MySQL提供的表级锁定实现，所以我们以MyISAM存储引擎作为示例存储引擎。</p>
<p>3.1 MySQL表级锁的锁模式</p>
<pre><code>MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。

锁模式的兼容性：
1.对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；
2.对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；
3.MyISAM表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后，只有持有锁的线
程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。
</code></pre>
<p>3.2 MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</p>
<h4 id="4-innodb的锁"><a href="#4-innodb的锁" class="headerlink" title="4.innodb的锁"></a>4.innodb的锁</h4><p> 行级锁定不是MySQL自己实现的锁定方式，而是由其他存储引擎自己所实现的，如广为大家所知的InnoDB存储引擎，以及MySQL的分布式存储引擎NDBCluster等都是实现了行级锁定。</p>
<p> 4.1 InnoDB锁定模式及实现机制</p>
<p>  InnoDB的锁定机制和Oracle数据库有不少相似之处。InnoDB的行级锁定同样分为两种类型，共享锁和排他锁，而在锁定机制的实现过程中为了让行级锁定和表级锁定共存，InnoDB也同样使用了意向锁（表级锁定）的概念，也就有了意向共享锁和意向排他锁这两种。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">共享锁s</th>
<th align="center">排他锁x</th>
<th align="center">意向共享锁is</th>
<th align="center">意向拍他锁</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S</td>
<td align="center">兼容</td>
<td align="center">冲突</td>
<td align="center">兼容</td>
<td align="center">冲突</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">冲突</td>
<td align="center">冲突</td>
<td align="center">冲突</td>
<td align="center">冲突</td>
</tr>
<tr>
<td align="center">IS</td>
<td align="center">兼容</td>
<td align="center">冲突</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
</tr>
<tr>
<td align="center">IX</td>
<td align="center">冲突</td>
<td align="center">冲突</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
</tr>
</tbody></table>
<pre><code>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要
等待锁释放。

意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排
他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。

共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE
</code></pre>
<p>4.2 InnoDB行锁实现方式 InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁</p>
<pre><code>1.在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。
2.由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的
索引键，是会出现锁冲突的。
3.当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普
通索引，InnoDB都会使用行锁来对数据加锁。
4.即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果
MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行
锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引
</code></pre>
<h4 id="5-乐观锁-vs-悲观锁（重点）"><a href="#5-乐观锁-vs-悲观锁（重点）" class="headerlink" title="5.乐观锁 vs 悲观锁（重点）"></a>5.乐观锁 vs 悲观锁（重点）</h4><p>5.1 乐观锁</p>
<p>总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新<br>时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现。</p>
<p>version方式：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到<br>的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<pre><code>update table set x=x+1, version=version+1 where id=#&#123;id&#125; and version=#&#123;version&#125;;  
</code></pre>
<p>CAS操作方式：即compare and swap 或者 compare and set，涉及到三个操作数，数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个自旋操作，即不断的重试。</p>
<p>5.2 悲观锁</p>
<p>总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁. 所以说我们上面所说的读锁,写锁都是属于悲观锁</p>
<p>5.3 优缺点</p>
<p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</p>
<h4 id="6-gap和record-lock"><a href="#6-gap和record-lock" class="headerlink" title="6.gap和record lock"></a>6.gap和record lock</h4><p>6.1 Gap lock 间隙锁 </p>
<p>在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身</p>
<pre><code>mysql&gt; select * from emp where empid &gt; 100 for update;
是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并
不存在）的“间隙”加锁。

InnoDB使用间隙锁的目的： 防止幻读，以满足相关隔离级别的要求。对于上面的例子，要是不使用间隙锁，如果其他
事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；
</code></pre>
<p>6.2 Record lock </p>
<p>单条索引记录上加锁，record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。</p>
<p>6.3 Next-Key</p>
<p>就是Record lock和gap lock的结合，即除了锁住记录本身，还要再锁住索引之间的间隙。</p>
<h4 id="7-死锁"><a href="#7-死锁" class="headerlink" title="7.死锁"></a>7.死锁</h4><p>概述</p>
<p>所谓死锁DeadLock: 是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等带的进程称为死锁进程.表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB.</p>
<pre><code>死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。那么对应的解决死锁问题的关键就是：让不同的
session加锁有次序    
</code></pre>
<h3 id="加锁方法"><a href="#加锁方法" class="headerlink" title="加锁方法"></a>加锁方法</h3><pre><code>select .. from  
不加任何类型的锁

select...from lock in share mode
共享锁
select...from lock for update
排它锁

update..where   
delete from..where 
排他锁
</code></pre>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql锁</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql数据库05--索引、引擎</title>
    <url>/jwangcloud/1501163261/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/mysql.jpeg"></p>
<h3 id="索引与优化"><a href="#索引与优化" class="headerlink" title="索引与优化"></a>索引与优化</h3><span id="more"></span>

<p>1.MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构</p>
<p>2.索引优缺点：</p>
<pre><code>优点：
    1.所有的MySql列类型(字段类型)都可以被索引，也就是可以给任意字段设置索引
    2.大大加快数据的查询速度
缺点：
    1.创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加
    2.索引也需要占空间，我们知道数据表中的数据也会有最大上线设置的，如果我们有大量的索引，索引文件
      可能会比数据文件更快达到上线值
    4.当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。
    
</code></pre>
<p>3.使用</p>
<pre><code>1.对经常更新的表就避免对其进行过多的索引，对经常用于查询的字段应该创建索引
2.数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，
  索引就可能不会产生优化效果。
3.在一同值少的列上(字段上)不要建立索引，比如在学生表的&quot;性别&quot;字段上只有男，女两个不同值。相反的，
  在一个字段上不同值较多可是建立索引。
  
</code></pre>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><h4 id="1-索引的类型"><a href="#1-索引的类型" class="headerlink" title="1.索引的类型"></a>1.索引的类型</h4><p>1.普通索引 index(key)： MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。</p>
<p>2.唯一索引 unique： 索引列中的值必须是唯一的，但是允许为空值</p>
<p>3.主键索引 primary key： 是一种特殊的唯一索引，不允许有空值</p>
<p>4.全文索引 fulltext: 只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行，比如有”好人，二货 …”</p>
<p>5.空间索引 spatial: 空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON。在创建空间索引时，使用SPATIAL关键字。</p>
<h4 id="2-存储数据结构"><a href="#2-存储数据结构" class="headerlink" title="2.存储数据结构"></a>2.存储数据结构</h4><p>1.HASH 只有Memory存储引擎显示支持hash索引，是Memory表的默认索引类型，尽管Memory表也可以使用B-Tree索引。</p>
<pre><code>(1)由于索引仅包含hash code和记录指针，所以，MySQL不能通过使用索引避免读取记录。但是访问内存中的记
    录是非常迅速的，不会对性造成太大的影响。 
(2)不能使用hash索引排序。 
(3)Hash索引不支持键的部分匹配，因为是通过整个索引值来计算hash值的。 
(4)Hash索引只支持等值比较，例如使用=，IN( )和&lt;=&gt;。对于WHERE price&gt;100并不能加速查询。
</code></pre>
<p>2.b-tree BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。</p>
<h4 id="3-单列索引和组合索引"><a href="#3-单列索引和组合索引" class="headerlink" title="3.单列索引和组合索引"></a>3.单列索引和组合索引</h4><p>1.单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引。 这里不要搞混淆了。</p>
<pre><code>普通索引: MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快
一点。
唯一索引：索引列中的值必须是唯一的，但是允许为空值
主键索引：是一种特殊的唯一索引，不允许有空值。
</code></pre>
<p>2.组合索引(复合索引)</p>
<p>在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索<br>引时遵循最左前缀集合。</p>
<pre><code>1.需要加索引的字段，要在where条件中
2.数据量少的字段不需要加索引
3.如果where条件中是OR关系，加索引不起作用
4.符合最左原则
</code></pre>
<p>对于复合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。</p>
<h3 id="索引语句"><a href="#索引语句" class="headerlink" title="索引语句"></a>索引语句</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.创建索引</span><br><span class="line">以User表的username字段(类型为VARCHAR(50))为例，使用username字段的6个字符前缀来创建索引。</span><br><span class="line">CREATE INDEX idx_user_username ON user (username(6));</span><br><span class="line"></span><br><span class="line">CREATE INDEX可对表增加普通索引或UNIQUE索引</span><br><span class="line">--例,只能添加这两种索引;</span><br><span class="line">CREATE INDEX index_name ON table_name (column_list)</span><br><span class="line">CREATE UNIQUE INDEX index_name ON table_name (column_list)</span><br><span class="line"></span><br><span class="line">2.删除索引</span><br><span class="line"></span><br><span class="line">ALTER TABLE table_name DROP INDEX index_name;</span><br><span class="line"></span><br><span class="line">3.修改索引：先删除再创建同名索引</span><br><span class="line"></span><br><span class="line">--先删除</span><br><span class="line">ALTER TABLE user DROP INDEX idx_user_username;</span><br><span class="line">--再以修改后的内容创建同名索引</span><br><span class="line">CREATE INDEX idx_user_username ON user (username(8));</span><br><span class="line"></span><br><span class="line">4.查看索引</span><br><span class="line"></span><br><span class="line">--如果查看索引前，没有使用user db_name等命令指定具体的数据库，则必须加上FROM db_name</span><br><span class="line">SHOW INDEX FROM table_name [FROM db_name]</span><br><span class="line">--如果查看索引前，没有使用user db_name等命令指定具体的数据库，则必须加上db_name.前缀</span><br><span class="line">SHOW INDEX FROM [db_name.]table_name</span><br><span class="line"></span><br><span class="line">5.查看是否使用了索引进行查询</span><br><span class="line">EXPLAIN SELECT * FROM book WHERE year_publication &#x3D; 1990;</span><br><span class="line"></span><br><span class="line">6.添加索引</span><br><span class="line">ALTER TABLE 表名 ADD 索引类型 （unique,primary key,fulltext,index）[索引名]（字段名）</span><br><span class="line">ALTER TABLE book ADD INDEX BkNameIdx(bookname(30));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><p>概述<br>存储引擎就是指表的类型。数据库的存储引擎决定了表在计算机中的存储方式。存储引擎的概念是MySQl的特点，而且是一个插入式的存储引擎概念。这就决定了MySQl数据库中的表可以使用不同的存储方式存储。用户可以根据自己的不同要求，选择不同的存储方式、是否进行事务处理等。</p>
<h4 id="引擎分类"><a href="#引擎分类" class="headerlink" title="引擎分类"></a>引擎分类</h4><p>InnoDB存储引擎</p>
<pre><code>InnoDB是Mysql数据库的一种存储引擎。InnoDB给Mysql的表提供了 事务、回滚、崩溃修复能力、多版本并发控制
的事务安全、间隙锁（可以有效的防止幻读的出现）、支持辅助索引、聚簇索引、自适应hash索引、支持热备、行级
锁。还有InnoDB是Mysql上唯一一个提供了外键约束的引擎。

InnoDB存储引擎中，创建的表的表结构是单独存储的并且存储在.frm文件中。数据和索引存储在一起的并且存储在表
空间中。但是默认情况下mysql会将数据库的所有InnoDB表存储在一个表空间中的。其实这种方式管理起来非常的不
方便而且还不支持高级功能所以建议每个表存储为一个表空间实现方式为：使用服务器变量
innodb_file_per_table = 1。

如果需要频繁的进行更新、删除操作的数据库也可选择InnoDB存储引擎。因为该存储引擎可以实现事务提交和回滚。
</code></pre>
<p>MyISAM存储引擎</p>
<pre><code>MyISAM存储引擎是Mysql中常见的存储引擎，MyISAM存储引擎是基于ISAM存储引擎发展起来的。MyISAM支持全文索
引、压缩存放、空间索引（空间函数）、表级锁、延迟更新索引键。但是MyISAM不支持事务、行级锁、更无法忍受的
是崩溃后不能保证完全恢复（只能手动修复）。

MyISAM存储引擎的表存储成3个文件。文件的名字和表的名字相同。扩展名包含frm、MYD、MYI。其中frm为扩展名的
文件存储表的结构；MYD为扩展名的文件存储数据，其是MYData的缩写；MYI为扩展名的文件存储索引，其为MYIndex
的缩写。

MyISAM存储引擎的插入数据很快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择
MyISAM存储引擎能够实现处理的高效率。如果应用的完整性、并发性要求很低，也可以选择MyISAM存储引擎。
</code></pre>
<p>MEMORY存储引擎</p>
<pre><code>MEMORY存储引擎是Mysql中的一类特殊的存储引擎。其使用存储在内存中的内存来创建表，而且所有数据保存在内存
中。数据安全性很低，但是查找和插入速度很快。如果内存出现异常就会影响到数据的完整性，如果重启或关机，表中
的所有数据就会丢失，因此基于MEMORY存储引擎的表的生命周期很短，一般都是一次性的。适用于某些特殊场景像查
找和映射，缓存周期性的聚合数据等等。
</code></pre>
<p>NDB 集群引擎</p>
<pre><code>作为sql和NDB元素协议之间的接口,用于mysql,ndb集群存储引擎,分布式等
</code></pre>
<h3 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h3><pre><code>1.尽可能让所有的数据检索都通过索引来完成
2.合理设计索引，使索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他
Query的执行；
3.尽量控制事务的大小，减少锁定的资源量和锁定时间长度
4.尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录
5.尽可能按照相同的访问顺序来访问，防止产生死锁
6.尽可能做到一次锁定所需要的所有资源，减少死锁产生概率
</code></pre>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql索引</tag>
        <tag>mysql引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql数据库02--进阶语句</title>
    <url>/jwangcloud/1482967651/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/mysql.jpeg"></p>
<h3 id="mysql进阶"><a href="#mysql进阶" class="headerlink" title="mysql进阶"></a>mysql进阶</h3><span id="more"></span>

<p>1.case…end</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update movie_table </span><br><span class="line">set category &#x3D; </span><br><span class="line">case </span><br><span class="line">	when drama &#x3D; &#39;T&#39; then &#39;drama&#39;  </span><br><span class="line">&#x2F;&#x2F;相当于：update movie_table set category &#x3D; &#39;drama&#39; where drama &#x3D; &#39;T&#39; </span><br><span class="line">	when comedy &#x3D; &#39;T&#39; and sciti &#x3D; &#39;T&#39; then &#39;comedy&#39; </span><br><span class="line">	else &#39;misc&#39;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;找到符合when语句时则直接执行该语句并跳到end</span><br></pre></td></tr></table></figure>

<p>2.order by  :排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select title, category from movie_table </span><br><span class="line">where</span><br><span class="line">category &#x3D; &#39;family&#39;</span><br><span class="line">order by title,purcheased</span><br><span class="line"></span><br><span class="line">desc:倒序</span><br></pre></td></tr></table></figure>

<p>3.sum avg min max count（属于函数） distinct(去重 不一样的值  属于关键字)<br>函数需要加括号 关键字不需要</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct sale_date</span><br><span class="line">from cookie_eales</span><br><span class="line">order by sale_date;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.group by :分组(与3搭配使用  属于关键字)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">select first_name,sum(sales)</span><br><span class="line">from cookie_eales</span><br><span class="line">group by first_name</span><br><span class="line">order by sum(sales) desc;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5.limit 查询结果的数量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select first_name,sum(sales)</span><br><span class="line">from cookie_eales</span><br><span class="line">group by first_name</span><br><span class="line">order by sum(sales) desc;</span><br><span class="line">limit 0,2;  &#x2F;&#x2F;从0开始1结束 一共两行数据</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>6.in,between in表示在其中的数据,between表示在两个数之间的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from atable where column beteen min and max  &#x2F;&#x2F;表示在min 和max之间的数据</span><br><span class="line">elect * from atable where column in(n1,n2,n3) &#x2F;&#x2F;表示数据是 n1或者n2或者n3</span><br></pre></td></tr></table></figure>

<p>7.or,and 表示在数据满足一个或者全部都满足<br>8.运算符,可以使用运算符表示数据大于 小于等于等情况,<br>9.like 模糊查询,使用like语句表示查询的时候匹配查询, %表示0，1或者多个字符的占位符, _ 表示一个字符的占位<br>符</p>
<p>10.having表示筛选 和where不同点在于having后面可以跟上聚合函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT region, SUM(population), SUM(area)</span><br><span class="line">FROM bbc</span><br><span class="line">GROUP BY region</span><br><span class="line">HAVING SUM(area)&gt;1000000</span><br></pre></td></tr></table></figure>


<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>1.创建带有外键的表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table intereste(</span><br><span class="line">int_id int not null auto_increment primary key,</span><br><span class="line">interest varchar(20) not null,</span><br><span class="line">contact_id int not null,</span><br><span class="line"></span><br><span class="line">constraint my_contacts_contact_id </span><br><span class="line">foreign key (contact_id) references my_contacts (contact_id)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.内连接(笛卡儿积)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t1 inner join t2;	</span><br><span class="line">select t1.*,t2.* from t1 inner join t2;</span><br><span class="line">加入筛选条件：on</span><br><span class="line">select t1.*,t2.* from t1 join t2 on t1.i1&#x3D;t2.i2;</span><br><span class="line">别名：</span><br><span class="line">select a.i1,b.i2 from t1 as a join t2 as b on a.i1&#x3D;b.i2;	</span><br></pre></td></tr></table></figure>

<p>3.外连接<br>外联结除了显示同样的匹配结果，还可以把其中一个数据表在另一个数据表里没有匹配的数据行也显示出来。外联结分左联结和右联结两种。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">左连接</span><br><span class="line">select a.i1,b.i2 from t1 as a left join t2 as b on a.i1&#x3D;b.i2;</span><br><span class="line">右连接</span><br><span class="line">elect a.i1,b.i2 from t1 as a right join t2 as b on a.i1&#x3D;b.i2;</span><br><span class="line">用处：</span><br><span class="line">select a.i1,b.i2 from t1 as a right join t2 as b on a.i1&#x3D;b.i2 </span><br><span class="line">where a.i1 is null;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.some any </p>
<pre><code>some和any会帮助我们筛选出最小的一个数来作为条件
select * from salary_table where salary &gt; some (select salary from salary_table 
where position = &#39;Python&#39;);
</code></pre>
<p>5.all</p>
<pre><code>all 会筛选出满足所有条件的选项
select * from salary_table where salary &gt; all (select salary from salary_table 
where position = &#39;java&#39;);
</code></pre>
<p>6.in (=some any)</p>
<pre><code>SELECT * FROM salary_table WHERE salary IN (SELECT salary FROM salary_table 
WHERE 
position = &#39;Python&#39;);

SELECT * FROM salary_table WHERE salary =some (SELECT salary FROM salary_table 
WHERE 
position = &#39;Python&#39;);
</code></pre>
<p>7.exists 会判断数据是否存在 如果不存在则不会筛选数据</p>
<pre><code>select * from salary_table 
where exists(SELECT * from salary_table where id = 1)
</code></pre>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql数据库01--基础语句</title>
    <url>/jwangcloud/1749468513/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/mysql.jpeg"></p>
<h3 id="sql-基础语法"><a href="#sql-基础语法" class="headerlink" title="sql 基础语法"></a>sql 基础语法</h3><span id="more"></span>

<p>1.创建学生数据库</p>
<pre><code>create database Student; 
</code></pre>
<p>2.使用学生数据库</p>
<pre><code>use Student; 
</code></pre>
<p>3.创建成绩表，字段后加not null 则表示不能为空，在查看表结构时为no，default可设置默认值</p>
<pre><code>create table score(id int(20) not null auto_increment,
               name varchar(10) default &#39;aa&#39;,
               score_num int(100)，
               primary key (id)   
                );   

null:代表未定义的值，不能使用在语句中，但可以通过is null判断某一个字段是否为空
主键和外键的设置在创建字段之后设置

auto_increment:从1递增 一个表只能添加一个递增，且该列必须为整数而且不能包含null
</code></pre>
<p>4.查看表结构</p>
<pre><code>desc score;  
</code></pre>
<p>5.删除成绩表</p>
<pre><code>drop table score； 
</code></pre>
<p>6.插入数据到成绩表中</p>
<pre><code>insert into score(id,name) values(1212,&#39;a&#39;); 
</code></pre>
<p>7.查看成绩表所有的数据</p>
<pre><code>select * from score; 
</code></pre>
<p>8.查看成绩表中id为1的所有数据信息</p>
<pre><code>select * from score where id = 1; 
</code></pre>
<p>9.这些类型使用单引号：</p>
<pre><code>char/varchar/date/datetime/time/timestamp/blob

dec/int:不使用引号

\&#39;: 处理字段中单引号的出现
</code></pre>
<p>10.查看成绩表中ID为1的名字</p>
<pre><code>select name from score where id = 1；
</code></pre>
<p>11.查询成绩表中ID为1 姓名为<code>a</code>的名字</p>
<pre><code>    select name from score where id=1 and name = `a`;
    
运算符：&lt;&gt; 不等于 = 等于 &lt; &lt;= &gt; &gt;= (也可以对字符进行比较) or and
select id from score where name &gt; `a`; 查询成绩表中名字首字母在`a`之后的所有数据的id
select * from score where name like &#39;%ca&#39;; 查询成绩表中所有名字以&#39;ca&#39;结尾的数据
%：任意数量的未知字符
_: 一个未知字符
</code></pre>
<p>12.查询成绩表中成绩在60到100之间的所有信息</p>
<pre><code>select * from score where score_num between 60 and 101; 
</code></pre>
<p>13.查询成绩表中名字首字母在’a’到’b’之间的所有信息</p>
<pre><code>select * from score where name between &#39;a&#39; and &#39;c&#39;; 
</code></pre>
<p>14.查询成绩表中名字在（’a’,’b’）中的所有信息 反过来：not in</p>
<pre><code>select * from score where name in(&#39;a&#39;,&#39;b&#39;); 
not:紧跟在where后 not in是特例， 同时可以与and /or /is null 搭配使用 位置在and/or后紧跟，
is     null 之前
</code></pre>
<p>15.删除成绩表中名字为’a’的数据 所有用法与select一样</p>
<pre><code>delete from score where name=&#39;a&#39;; 

注意删除时若无约束条件则会删除全部     删除只能删除一行或多行，无法删除某一个字段或值
</code></pre>
<p>16.修改成绩表中ID为1的名字为’b’成绩为50 无则不修改任何字段</p>
<pre><code>update score set name=&#39;b&#39;,score=50 where id=1; 
</code></pre>
<p>17.查看创建表的语句</p>
<pre><code>show create table score; 
</code></pre>
<p>18.为score表创建一个不为空的整型自增的字段并放于表首列，设置其为主键</p>
<pre><code>alter table score add column student_id int not null auto_increment first,
add primary key (student_id); 
</code></pre>
<p>19.数据原子性：同一列中不会存储多个类型相同的数据，也不会用多个列存储相同的数据</p>
<pre><code>第一范式：每一个数据行均需包含原子性数据值，且每一个数据行都存在唯一的识别方法
alter table score add column phone varchar(10) after id; 为score表创建
一个电话号码字段并放于id列字段之后
</code></pre>
<p>20.alter…change:同时改变现有列的名称和数据类型</p>
<pre><code>alter table score change column id stu_id int not null auto_increment,
add primary key (stu_id);
将score表中ID改为stu_id并将其设置成自增和主键,必须重新命名该列数据类型

alter...modify:修改现有列的数据类型或位置
alter table score modify column id varchar(120);
修改score表的id类型为varchar(120)

alter...add:在当前表中添加一行
alter...drop：删除表中某列

注意：可能造成数据丢失
alter table score rename to score_stu;将表score的名字改为score_stu
alter table score drop primary key; 删除score表的主键
</code></pre>
<p>21.选出name列中从右侧开始选取的2个字符 左侧开始为left</p>
<pre><code>select right(name, 2) from score;
select substring_index(name,&#39;,&#39;,1) from score;选取name列中以第一个逗号隔开之
前的部分，若为2,则为第二个之前的所有部分

其它字符串函数：substring(&#39;aaadsasd&#39;,4,3);截取‘aaadsasd&#39;中从位置4开始长度为3
          upper(&#39;aa&#39;);字符串转为大写  lower(&#39;CC&#39;)；字符串转为小写
          reverse(&#39;cvs&#39;);反转字符串
          ltrim(&#39;  aaaasdf  &#39;); rtrim(&#39;  asaadd  &#39;);清除多余空格
          length(&#39;asadsad&#39;)
运用：update contacts set state = right(location,2);取出contacts 表location字
段中右边两字符并放入到state字段中进行遍历

字符串函数可以和select,update,delete搭配使用
</code></pre>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql数据库03--事务</title>
    <url>/jwangcloud/864966898/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/mysql.jpeg"></p>
<h3 id="mysql隔离级别"><a href="#mysql隔离级别" class="headerlink" title="mysql隔离级别"></a>mysql隔离级别</h3><span id="more"></span>

<p>隔离级别是mysql进行事务提交的时候,对数据的一种表现形式</p>
<h4 id="1-事务的基本要素（ACID）"><a href="#1-事务的基本要素（ACID）" class="headerlink" title="1. 事务的基本要素（ACID）"></a>1. 事务的基本要素（ACID）</h4><p>1.1 原子性（Atomicity）：</p>
<p>事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。</p>
<p>1.2 一致性（Consistency）：</p>
<p>事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。</p>
<p>1.3 隔离性（Isolation）：</p>
<p>同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>
<p>1.4 持久性（Durability）：</p>
<p>事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</p>
<h4 id="2-事务的操作方式"><a href="#2-事务的操作方式" class="headerlink" title="2. 事务的操作方式"></a>2. 事务的操作方式</h4><p>提交使用commit 回滚使用 rollback</p>
<pre><code>begin

&#39;&#39;&#39;&#39;&#39;语句快

commit
</code></pre>
<h4 id="3-事务的并发问题"><a href="#3-事务的并发问题" class="headerlink" title="3.事务的并发问题"></a>3.事务的并发问题</h4><p>3.1 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p>
<p>3.2 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</p>
<p>3.3 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p>
<table>
<thead>
<tr>
<th align="center">事物隔离级别</th>
<th align="center">胀读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交（read-uncommitted）</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">不可重复读（read-committed）</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">可重复读（repeatable-read）</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">串行化（serializable）</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
</tbody></table>
<p>3.4 语句实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">说明: 我们使用a,b两个端 a负责开启事务,并且修改数据。b负责开启事务,并且在a执行事务的时候不断去获取数</span><br><span class="line">	  据。以此研究数据的影响.a先执行,因为a需要去修改数据,所以a要首先获取到锁才行</span><br><span class="line"></span><br><span class="line">1.脏读:</span><br><span class="line">首先在b中去设置隔离级别</span><br><span class="line">a客户端</span><br><span class="line">	start transaction</span><br><span class="line">	update &#96;Employee&#96; set Name&#x3D;&#39;test2&#39; where Id&#x3D;1</span><br><span class="line">b客户端</span><br><span class="line">	set session transaction isolation level read uncommitted</span><br><span class="line">	start transaction</span><br><span class="line">	select * from &#96;Employee&#96;</span><br><span class="line">可以看到a中修改的数据,b中已经可以查看到,但是a的数据并没有commit,b读取到了a还没有提交上</span><br><span class="line">去的脏数据,称为脏读</span><br><span class="line"></span><br><span class="line">2.不可复读:</span><br><span class="line">a客户端</span><br><span class="line">	start transaction</span><br><span class="line">	update &#96;Employee&#96; set Name&#x3D;&#39;test2&#39; where Id&#x3D;1</span><br><span class="line">b客户端</span><br><span class="line">	set session transaction isolation level read committed</span><br><span class="line">	start transaction</span><br><span class="line">	select * from &#96;Employee&#96;</span><br><span class="line">这时候再去查看数据就不会出现脏读的情况,但是在a提交之后,再使用b去查看的话就会有一定的问题</span><br><span class="line"></span><br><span class="line">a客户端</span><br><span class="line">	commit</span><br><span class="line">b客户端</span><br><span class="line">	select * from &#96;Employee&#96;</span><br><span class="line">这时候b的中表的数据就变了,虽然没有脏读的情况,但是b中的数据两次不一样, 所以称之为不可复读</span><br><span class="line"></span><br><span class="line">3.幻读:</span><br><span class="line">a客户端</span><br><span class="line">	start transaction</span><br><span class="line">	update &#96;Employee&#96; set Name&#x3D;&#39;test2&#39; where Id&#x3D;1</span><br><span class="line">b客户端</span><br><span class="line">	set session transaction isolation level REPEATABLE read</span><br><span class="line">	start transaction</span><br><span class="line">	select * from &#96;Employee&#96;</span><br><span class="line">这个时候,b中查看的数据没有没有问题,他看到的一直都是老数据。这里使用了mvvc技术</span><br><span class="line"></span><br><span class="line">a客户端</span><br><span class="line">	commit</span><br><span class="line">b客户端</span><br><span class="line">	select * from &#96;Employee&#96;</span><br><span class="line">但是有一个问题,当a表去Insert一条数据数据并且commit了之后,b去select的时候就会看到a表中新加的数据,就像幻读</span><br><span class="line">一样,多出了一条数据来</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">	start transaction</span><br><span class="line">	insert into &#96;Employee&#96; (name,id)value(&#39;test&#39;,10</span><br><span class="line">	commit</span><br><span class="line">为了避免这个问题,b可以设置</span><br><span class="line">	set session transaction isolation level serializable</span><br><span class="line">在a操作事务的时候,b操作事务会一直卡住,直到a表操作完成b才能去select操作，这就是串行化</span><br><span class="line"></span><br><span class="line">4. mysql默认的级别是不可复读</span><br></pre></td></tr></table></figure>


<p>3.5 不可重复读 和 幻读</p>
<p>不可复读是针对同一条数据两次读取会有变化 幻读是说当select到数据id=9的时候,这个时候我们可以去插入id=10的数据,但是其他的事务已经插入了id=10的记录,这个时候就会报错。但是从本事务的观点来看id为10的东西是不存在的。所以就想有幻觉一样,称为幻读。</p>
<p>其实对于 幻读, MySQL的InnoDB引擎默认的RR级别已经通过MVCC自动帮我们(部分)解决了。因为当其他事务增加一条数据的时候。我们两次执行查询语句结果都是一样的。这是使用了mvcc模式来实现的,在RR模式下面，事务每次读取的都是一个快照。同一个事务中每次都读取同一份快照。所以就算数据更新了。读的也是老数据</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql数据库事务</tag>
      </tags>
  </entry>
  <entry>
    <title>html语法05--表格、表单</title>
    <url>/jwangcloud/1576459572/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/html.jpeg"></p>
<h3 id="1-表格"><a href="#1-表格" class="headerlink" title="1.表格"></a>1.表格</h3><span id="more"></span>

<pre><code>    表格由 table 标签来定义。
    每个表格均有若干行（由 tr 标签定义），每行被分割为若干单元格（由 td 标签定义）。
    字母 td(table data) 指表格数据，即数据单元格的内容。
    数据单元格可以包含文本、图片、列表、段落、表单、水线、表格等等。
    
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;table border&#x3D;&quot;1&quot; cellpadding&#x3D;&quot;10”&gt;  border 为边框宽度1 cellpadding 为单元格间距10 </span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            row 1,col 2    </span><br><span class="line">        &lt;&#x2F;td&gt;</span><br><span class="line">    &lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1-1-表格标签"><a href="#1-1-表格标签" class="headerlink" title="1.1 表格标签"></a>1.1 表格标签</h4><table>
<thead>
<tr>
<th align="center">标签</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">table</td>
<td align="center">定义表格</td>
</tr>
<tr>
<td align="center">th</td>
<td align="center">定义表格的表头</td>
</tr>
<tr>
<td align="center">tr</td>
<td align="center">定义表格的行</td>
</tr>
<tr>
<td align="center">td</td>
<td align="center">定义表格的单元</td>
</tr>
<tr>
<td align="center">caption</td>
<td align="center">定义表格的标题</td>
</tr>
<tr>
<td align="center">colgroup</td>
<td align="center">定义表格的组</td>
</tr>
<tr>
<td align="center">col</td>
<td align="center">定义表格列的属性</td>
</tr>
<tr>
<td align="center">thead</td>
<td align="center">定义页眉</td>
</tr>
<tr>
<td align="center">tbody</td>
<td align="center">定义表格的主体</td>
</tr>
<tr>
<td align="center">tfoot</td>
<td align="center">定义表格的页脚</td>
</tr>
</tbody></table>
<h4 id="1-2-表格三大部分"><a href="#1-2-表格三大部分" class="headerlink" title="1.2 表格三大部分"></a>1.2 表格三大部分</h4><pre><code>        thead ---------表格的页眉
        tbody ---------表格的主体
        tfoot ---------定义表格的页脚(在最下面,不管代码位置在哪里)
        
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;table border&#x3D;&quot;1&quot;&gt;</span><br><span class="line">	    &lt;tfoot&gt;</span><br><span class="line">	    &lt;tr&gt;&lt;th&gt;row end col1&lt;&#x2F;th&gt;&lt;th&gt;row end col2&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;</span><br><span class="line">	    &lt;&#x2F;tfoot&gt;</span><br><span class="line">	    &lt;tbody&gt;</span><br><span class="line">	    &lt;tr&gt;</span><br><span class="line">	        &lt;td rowspan&#x3D;&quot;2&quot;&gt; 把包括本身的2格合并起来</span><br><span class="line">	            row 1,col 1</span><br><span class="line">	        &lt;&#x2F;td&gt;</span><br><span class="line">	    &lt;&#x2F;tr&gt;</span><br><span class="line">	    &lt;&#x2F;tbody&gt;</span><br><span class="line">	    &lt;thead&gt;</span><br><span class="line">	    &lt;tr&gt;&lt;td&gt;位置&lt;&#x2F;td&gt;&lt;td&gt;位置&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class="line">	    &lt;&#x2F;thead&gt;</span><br><span class="line">	    </span><br></pre></td></tr></table></figure>

<h4 id="1-3-表格合并"><a href="#1-3-表格合并" class="headerlink" title="1.3 表格合并"></a>1.3 表格合并</h4><pre><code>    colspan 合并列
    rowspan 合并行
    
</code></pre>
<h3 id="2-表单"><a href="#2-表单" class="headerlink" title="2 表单"></a>2 表单</h3><h4 id="2-1-表单创建"><a href="#2-1-表单创建" class="headerlink" title="2.1 表单创建"></a>2.1 表单创建</h4><pre><code>表单是一个包含表单元素的区域。
HTML 表单用于搜集不同类型的用户输入。
表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、
单选框(radio-buttons)、复选框(checkboxes)等等。

表单使用表单标签 form标签来设置:
多数情况下被用到的表单标签是输入标签 input标签 输入类型是由类型属性（type）定义的。

form标签属性:
    action 提交到哪里去(点击表单之后)
    method 定义提交的方法 get post等方法
    input标签就是我们常见的输入框里面的内容
    placeholder 提示我们输入文字
    required 必须输入
    
&lt;form action=&quot;tables.html&quot; method=&quot;get&quot;&gt;
&lt;label&gt;账户&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;test&quot; placeholder=“输入” required&gt;
&lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;
&lt;/form&gt;
    
</code></pre>
<h4 id="2-2-表单标签"><a href="#2-2-表单标签" class="headerlink" title="2.2 表单标签"></a>2.2 表单标签</h4><table>
<thead>
<tr>
<th align="center">标签</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">form</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">定义输入域</td>
</tr>
<tr>
<td align="center">textarea</td>
<td align="center">定义文本域 (一个多行的输入控件)</td>
</tr>
<tr>
<td align="center">label</td>
<td align="center">定义了 input元素的标签，一般为输入标题</td>
</tr>
<tr>
<td align="center">fieldset</td>
<td align="center">定义了一组相关的表单元素，并使用外框包含起</td>
</tr>
<tr>
<td align="center">legend</td>
<td align="center">定义了 fieldset 元素的标题</td>
</tr>
<tr>
<td align="center">select</td>
<td align="center">定义了下拉选项列表</td>
</tr>
<tr>
<td align="center">optgroup</td>
<td align="center">定义选项组</td>
</tr>
<tr>
<td align="center">option</td>
<td align="center">定义下拉列表中的选项</td>
</tr>
<tr>
<td align="center">button</td>
<td align="center">定义一个点击按钮</td>
</tr>
<tr>
<td align="center">datalist</td>
<td align="center">指定一个预先定义的输入控件选项列表</td>
</tr>
<tr>
<td align="center">keygen</td>
<td align="center">定义了表单的密钥对生成器字段</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">定义一个计算结果</td>
</tr>
</tbody></table>
<pre><code>我们通过type来定义文本的类型,如果password则不会显示密码里面的字段
我们习惯在使用label表示表单的名称,在label中使用for,指向input中的id
就可以在点击label标签的时候,跳转到Input标签中间去    &lt;form action=&quot;tables.html&quot; method=&quot;get&quot;&gt;
&lt;label for=&#39;t1&#39;&gt;账户&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;t1&quot;&gt;
&lt;label for=&quot;t2&quot;&gt;密码&lt;/label&gt;&lt;input type=&quot;password&quot; name=&quot;pwd&quot; id=&quot;t2&quot;&gt;
&lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre>
<h4 id="2-3-单选按钮（radio）-复选框（checkbox）"><a href="#2-3-单选按钮（radio）-复选框（checkbox）" class="headerlink" title="2.3 单选按钮（radio） 复选框（checkbox）"></a>2.3 单选按钮（radio） 复选框（checkbox）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type&#x3D;&quot;radio&quot; 标签定义了表单单选框选项</span><br><span class="line">表单中的单选按钮可以设置以下几个属性：value、name、checked value：提交数据到服务器的值</span><br><span class="line">name：为控件命名，以备后台程序 ASP、PHP 使用</span><br><span class="line"></span><br><span class="line">checked&#x3D;&quot;checked&quot; 时，该选项被默认选中&lt;form action&#x3D;&quot;#&quot; &gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot; value&#x3D;&quot;male&quot; checked&gt;male&lt;br&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot; value&#x3D;&quot;female&quot;&gt;female&lt;br&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-4-下拉列表（select-option）"><a href="#2-4-下拉列表（select-option）" class="headerlink" title="2.4 下拉列表（select option）"></a>2.4 下拉列表（select option）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;#&quot; &gt;</span><br><span class="line">    &lt;select name&#x3D;&quot;car&quot;&gt;</span><br><span class="line">    &lt;option value&#x3D;&quot;1&quot;&gt;bmw&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option value&#x3D;&quot;2&quot;&gt;benz&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option value&#x3D;&quot;3&quot;&gt;audi&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;submit&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-5-带边框的表单（filedset）"><a href="#2-5-带边框的表单（filedset）" class="headerlink" title="2.5 带边框的表单（filedset）"></a>2.5 带边框的表单（filedset）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;form action&#x3D;&quot;#&quot;&gt;</span><br><span class="line">&lt;fieldset&gt;</span><br><span class="line">    &lt;legend&gt;</span><br><span class="line">        fieldset的</span><br><span class="line">    &lt;&#x2F;legend&gt;</span><br><span class="line">    &lt;label for&#x3D;&#39;t1&#39;&gt;账户&lt;&#x2F;label&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot; id&#x3D;&quot;t1&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;t2&quot;&gt;密码&lt;&#x2F;label&gt;&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;pwd&quot; id&#x3D;&quot;t2&quot;&gt;</span><br><span class="line">&lt;&#x2F;fieldset&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;submit&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-6-添加文件"><a href="#2-6-添加文件" class="headerlink" title="2.6 添加文件"></a>2.6 添加文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文件上传 type&#x3D;“file&quot;</span><br><span class="line">使用file，则form的enctype必须设置为multipart&#x2F;form-data，method属性为POST。</span><br><span class="line">&lt;form action&#x3D;&quot;#&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;upfile&quot;&gt;</span><br><span class="line">    &lt;button&gt;上传&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">application&#x2F;x-www-form-urlencoded 	在发送前编码所有字符（默认）</span><br><span class="line">multipart&#x2F;form-data	 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。</span><br><span class="line">text&#x2F;plain	 空格转换为 &quot;+&quot; 加号，但不对特殊字符编码。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>表格</tag>
        <tag>表单</tag>
      </tags>
  </entry>
  <entry>
    <title>html语法04--css语法</title>
    <url>/jwangcloud/1650027718/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/html.jpeg"></p>
<h3 id="css基础"><a href="#css基础" class="headerlink" title="css基础"></a>css基础</h3><span id="more"></span>

<h4 id="1-“行内样式”、“内嵌样式”、“外链样式”、“导入式”"><a href="#1-“行内样式”、“内嵌样式”、“外链样式”、“导入式”" class="headerlink" title="1.“行内样式”、“内嵌样式”、“外链样式”、“导入式”"></a>1.“行内样式”、“内嵌样式”、“外链样式”、“导入式”</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot; http-equiv&#x3D;&quot;refresh&quot;&gt;</span><br><span class="line">    &lt;title&gt;中国男篮排位赛广州进行，将与国足下榻同一酒店&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;style&gt;                              &#x2F;&#x2F; 内嵌样式</span><br><span class="line">    p&#123;</span><br><span class="line">      text-indent: 4em;</span><br><span class="line">    &#125;</span><br><span class="line">    h4&#123;</span><br><span class="line">      text-align: center;</span><br><span class="line">    &#125;</span><br><span class="line">    img&#123;</span><br><span class="line">      width: 560px;</span><br><span class="line">      height: 450px;</span><br><span class="line">    &#125;</span><br><span class="line">    .p1&#123;</span><br><span class="line">      color: chocolate;</span><br><span class="line">    &#125;</span><br><span class="line">    .p2&#123;</span><br><span class="line">      color: aqua;</span><br><span class="line">    &#125;</span><br><span class="line">    #x2&#123;</span><br><span class="line">      color: cornflowerblue;</span><br><span class="line">    &#125;</span><br><span class="line">    *&#123;</span><br><span class="line">      border: 0;</span><br><span class="line">      margin: 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;style&gt;</span><br><span class="line">  &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;h5_css_1.css&quot;&gt;   </span><br><span class="line">  &#x2F;&#x2F;外链样式 链接地址为编写的css外部代码</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;article&gt;</span><br><span class="line">&lt;header&gt;&lt;h1 style&#x3D;&quot;text-align: center&quot;&gt;中国男篮排位赛广州进行&lt;&#x2F;h1&gt;&lt;&#x2F;header&gt; </span><br><span class="line">&#x2F;&#x2F;行内样式</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;h4 class&#x3D;&quot;p1&quot;&gt;(原标题)&lt;&#x2F;h4&gt;</span><br><span class="line">&lt;h5&gt;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;cms-bucket.ws.126.net&#x2F;</span><br><span class="line">2019&#x2F;09&#x2F;05&#x2F;4740f77e15b9402a8877f302eb67a908.jpeg&quot;&gt;&lt;&#x2F;h5&gt;</span><br><span class="line">&lt;p id &#x3D; &quot;x2&quot;&gt;中国男篮59-72不敌委内瑞拉&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;而据澎湃新闻记者从国足处&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;article&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;b&gt;延伸 · 回顾&lt;&#x2F;b&gt;&lt;hr&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;sports.163.com&#x2F;19&#x2F;0904&#x2F;21&#x2F;EO8T046J00059AJ8.html&quot;&gt;男篮无缘16强球</span><br><span class="line">迷终于忍不了全场高喊&quot;李楠下课&quot;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p class&#x3D;&quot;p2&quot;&gt;北京时间9月4日晚&lt;&#x2F;p&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;*h5_css_1.css*&#x2F;</span><br><span class="line">h5&#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-css选择器"><a href="#2-css选择器" class="headerlink" title="2.css选择器"></a>2.css选择器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.标签选择器</span><br><span class="line">div  &#123; width:  300px; height: 300px; background-color: red; &#125;</span><br><span class="line">p    &#123; text-indent: 2em; color: blue; &#125;</span><br><span class="line">span &#123; letter-spacing: 5px; font-size: 20px; &#125;</span><br><span class="line"></span><br><span class="line">2. 类选择器</span><br><span class="line">.box  &#123; width:  300px; height: 300px; background-color: red; &#125;</span><br><span class="line">p.des &#123; text-indent: 2em; color: blue; &#125;</span><br><span class="line"></span><br><span class="line">3. id选择器</span><br><span class="line">#box &#123; width:  300px; height: 300px; background-color: red; &#125;</span><br><span class="line">#des &#123; text-indent: 2em; color: blue; &#125;</span><br><span class="line"></span><br><span class="line">4. 通用选择器</span><br><span class="line">通用选择器使用 * 表示，它的作用是选择页面中所有的标签元素</span><br><span class="line"></span><br><span class="line">5. 后代选择器  可选择嵌套其中的任意一个子类</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.container article &#123; text-align: center; &#125;</span><br><span class="line">.container h1 &#123; color: #000000; &#125;</span><br><span class="line">.container p  &#123; color: #008800; &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;article&gt;</span><br><span class="line">        &lt;h1&gt;Napoléon Bonaparte&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;p&gt;Adversity is the midwife of genius.&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;article&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">6. 子类选择器  只能选择直系嵌套下的子类</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.container &gt; article &#123; text-align: center; &#125;</span><br><span class="line">.container &gt; article &gt; h1 &#123; color: #000000; &#125;</span><br><span class="line">.container &gt; article &gt; p  &#123; color: #008800; &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">7. 伪类选择器</span><br><span class="line"></span><br><span class="line">link：表示链接在正常情况下（即页面刚加载完成时）显示的颜色。</span><br><span class="line">visited：表示链接被点击后显示的颜色。</span><br><span class="line">hover：表示鼠标悬停时显示的颜色。</span><br><span class="line">focus：表示元素获得光标焦点时使用的颜色，主要用于文本框输入文字时使用（鼠标松开时显示的颜色,</span><br><span class="line">可以使用input来查看）。</span><br><span class="line">active：表示当所指元素处于激活状态（鼠标在元素上按下还没有松开）时所显示的颜色。</span><br><span class="line"></span><br><span class="line">a &#123; text-decoration: none; &#125;		</span><br><span class="line">a:hover &#123; text-decoration: underline;&#125;</span><br><span class="line">      a:link&#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">        a:visited&#123;</span><br><span class="line">            color: green;</span><br><span class="line">        &#125;</span><br><span class="line">        a:hover&#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">        a:focus&#123;</span><br><span class="line">            color:black;</span><br><span class="line">        &#125;</span><br><span class="line">        a:active&#123;</span><br><span class="line">            color: yellow;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">8. 群组选择器</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">a, div, span, p &#123; font-size: 20px; &#125;</span><br><span class="line">div, p &#123; margin:  0; padding: 0; &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;a href&#x3D;&quot;javascript:;&quot;&gt;超链接&lt;&#x2F;a&gt;</span><br><span class="line">&lt;div&gt;布局标签&lt;&#x2F;div&gt;</span><br><span class="line">&lt;span&gt;文本标签&lt;&#x2F;span&gt;</span><br><span class="line">&lt;p&gt;段落标签&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-权重计算值"><a href="#3-权重计算值" class="headerlink" title="3.权重计算值"></a>3.权重计算值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">行内权重值：1000</span><br><span class="line">ID选择器的权重值：100</span><br><span class="line">class和伪类：10</span><br><span class="line">标签选择器：1</span><br><span class="line"></span><br><span class="line">!important 最高权重：10000 </span><br><span class="line"></span><br><span class="line">#html1 &#123;</span><br><span class="line">           color: #73d44d !important;</span><br><span class="line">           background-color: #93c1d4;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<pre><code>    1.每种权重值的最大值只能叠加9次
    2.如果两个地方定义的权重一样的话,那么就按照最后定义的权重为准,这个原则
    使用于 &lt;style&gt;和 &lt;link&gt;混合来使用
    
    
</code></pre>
<h4 id="4-css高级选择器"><a href="#4-css高级选择器" class="headerlink" title="4.css高级选择器"></a>4.css高级选择器</h4><p>CSS高级选择器区别于CSS普通选择器,是对标签元素的结构、标签元素的索引、标签元素<br>的状态等一些更为复杂的条件下进行的选择，甚至能改变现有标签的状态结构。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">伪元素选择器：向指定的选择器添加指定的效果</span><br><span class="line"></span><br><span class="line">1.：first-letter</span><br><span class="line">	选择“块级元素”文本段落中的首个字符，只对块级元素生效 如&lt;p&gt;</span><br><span class="line">2.:first-line</span><br><span class="line">	选择“块级元素”文本段落中的首行文本，与1一样</span><br><span class="line">3.:before</span><br><span class="line">	在指定的选择器之前插入一段内容。插入内容默认为“行内元素”，可通过“display”强制转换类型。</span><br><span class="line">	如果需要插入文本字符串，则直接将字符串赋值给 content 属性，</span><br><span class="line">	如：&#96;content: &#39;Hello, world!&#39;	</span><br><span class="line">	p &#123;</span><br><span class="line">    		letter-spacing: 5px;</span><br><span class="line">    		font-size: 25px;</span><br><span class="line">    		color: #ff4500;</span><br><span class="line">    		text-shadow: 1px 1px 2px #000;</span><br><span class="line">		&#125;	</span><br><span class="line">	p:after &#123;</span><br><span class="line">    		&#x2F;*插入内容，这里以插入图片为例*&#x2F;</span><br><span class="line">    			content: url(&#39;xiaoxin.jpg&#39;);</span><br><span class="line"></span><br><span class="line">    			position: relative;</span><br><span class="line">    			top: 20px;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">结构性伪类选择器：该类选择器主要用于当前选择器精确地通过元素“索引值”或“匹配类型”</span><br><span class="line">的索引值定位到该选择器的同级指定元素</span><br><span class="line"></span><br><span class="line">1.:first-child</span><br><span class="line">	对该类所有父元素中的首个子元素进行选择。</span><br><span class="line">2.：last-child</span><br><span class="line">	对该类所有父元素中的最后一个子元素进行选择。</span><br><span class="line">3. :first-of-type</span><br><span class="line">	对该类所有父元素中的首个匹配到类型的子元素进行选择。</span><br><span class="line">4. :last-of-type</span><br><span class="line">	对该类所有父元素中的最后一个匹配到类型的子元素进行选择。</span><br><span class="line">5. :only-child</span><br><span class="line">	对该类所有父元素中只含有唯一所匹配（不包含同级元素&#x2F;只有一个子元素）的子元素进行选择。</span><br><span class="line">6. :only-of-type</span><br><span class="line">	对该类所有父元素中只含有唯一所匹配类型的子元素进行选择。</span><br><span class="line">7. :nth-child(n)</span><br><span class="line">	对其父元素的第“n”个子元素进行选择，通过设置参数“n(0开始)”指定为第几个元素。</span><br><span class="line">	(该选择器不仅能准确的匹配到第“几”个指定类型的元素，还能对匹配类型元素的“</span><br><span class="line">	奇偶索引”值进行选择。odd 表示奇数，even 表示偶数。)</span><br><span class="line">8. :nth-last-child(n)</span><br><span class="line">	该选择器和“:nth-child(n)”的特性基本一致，唯一的不同点就是该选择器的索引值是从该选</span><br><span class="line">	择器匹配到的元素的同级元素中的最后一个开始进行计算的</span><br><span class="line">9. :empty</span><br><span class="line">  	该选择器会匹配所有，或指定基本选择器内没有元素（没有子节点）的标签元素。</span><br><span class="line">10. :not(selector)</span><br><span class="line">  	该选择器是用于排除指定元素的选择器。</span><br></pre></td></tr></table></figure>

<h3 id="css文本和字体"><a href="#css文本和字体" class="headerlink" title="css文本和字体"></a>css文本和字体</h3><h4 id="1-文本设置"><a href="#1-文本设置" class="headerlink" title="1.文本设置"></a>1.文本设置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">01. 文本对齐方式</span><br><span class="line">	text-align 属性用于控制“行内块元素”、“块元素”或“行内元素”（文本元素）的居中方式，</span><br><span class="line">	包含三个值：</span><br><span class="line"></span><br><span class="line">	left：局左对齐（m o&#39;ren）</span><br><span class="line">	right：居右对齐</span><br><span class="line">	center：居中对齐</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">02. 段落首行缩进</span><br><span class="line">	text-indent 属性是用于设置每个段落首行缩进数量值的属性，CSS字体大小（font-size）可</span><br><span class="line">	以设置的数值和单位在该属性的值中都可以使用（除了百分比）。如果是用于中文布局，一般会使</span><br><span class="line">	用“2em”的数值和单位来为每个段落的首行缩进“两个字符”。1em就等于16px，2em就是32px。</span><br><span class="line">	</span><br><span class="line">03. 文本装饰线</span><br><span class="line">	text-decoration 属性是为文本上添加一根装饰线，带&quot;href&quot;属性的&lt;a&gt;标签默认</span><br><span class="line">	会带有一根下划线，就是由该属性的值“underline”设置的。“text-decoration”</span><br><span class="line">	属性有以下值：</span><br><span class="line"></span><br><span class="line">	none（默认）：不显示任何装饰线</span><br><span class="line">	underline：在文本下方显示装饰线</span><br><span class="line">	overline：在文本上方显示装饰线</span><br><span class="line">	line-through：在文本中间显示装饰线，相当于删除线</span><br><span class="line">	</span><br><span class="line">04. 大小写转换</span><br><span class="line">	text-transform 属性能将“行内元素”中的英文文本进行大小写转换，以满足网站对</span><br><span class="line">	规范性的要求。该属性有以下属性值：</span><br><span class="line"></span><br><span class="line">	none（默认）：保持文本中英文单词的默认大小写</span><br><span class="line">	capitalize：每个英文单词首字母为大写字母，其它为小写字母</span><br><span class="line">	uppercase：将所有英文单词转换为大写字母</span><br><span class="line">	lowercase：将所有英文单词转换为小写字母</span><br><span class="line"></span><br><span class="line">05. 文本阴影</span><br><span class="line">text-shadow 属性的作用是给文本添加阴影效果。目前除了IE9及之前版本不支持该属性外，</span><br><span class="line">其它主流浏览器均支持该属性。该属性有4个值，具体如下：text-shadow: H V blur color;</span><br><span class="line"></span><br><span class="line">H：水平偏移，“0”表示维持原位，正数为向右偏移，负数为向左偏移。单位为像素“px”。</span><br><span class="line">V：垂直偏移，“0”表示维持原位，正数为向下偏移，负数为向上偏移。单位为像素“px”。</span><br><span class="line">blur ：模糊距离，用 正数 表示阴影模糊的单位距离，距离越大模糊程度越高。单位为像素“px”。</span><br><span class="line">color：阴影颜色，支持Web技术中的常用颜色模式：“颜色英文单词”、“HEX”、“RGBa”、“HSLa”。</span><br><span class="line"></span><br><span class="line">&lt;p style&#x3D;&quot;text-shadow: 2px 2px 5px #000;&quot;&gt;Hello, World!&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">06. 文本行高</span><br><span class="line">line-height 属性是用于设置“行内元素”中文本元素在一行中所占据的高度</span><br><span class="line">当文本元素只有一行时，可以将该行的文本行高设为和父容器元素高度一致，以此到达文</span><br><span class="line">本垂直居中的效果。使用场景如：表格、导航按钮、自定义样式按钮、标题栏等。</span><br><span class="line"></span><br><span class="line">&lt;!-- HTML 部分 --&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;txt&quot;&gt;CHINA&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- CSS 部分 --&gt;</span><br><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">    .txt &#123;</span><br><span class="line">        width:  260px;</span><br><span class="line">        height: 260px;</span><br><span class="line">        background-color: #000;</span><br><span class="line"></span><br><span class="line">        color: #fff;</span><br><span class="line">        text-align: center;</span><br><span class="line">        line-height: 260px;</span><br><span class="line"></span><br><span class="line">        &#x2F;*字符间距*&#x2F;</span><br><span class="line">        letter-spacing: 5px;</span><br><span class="line">        &#x2F;*字体大小*&#x2F;</span><br><span class="line">        font-size: 36px;</span><br><span class="line">        &#x2F;*文本阴影*&#x2F;</span><br><span class="line">        text-shadow: 3px 3px 5px skyblue;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">07. 单词间距  word-spacing 如“像素（px）”，“字符（em）”，“点（pt）”等，可以为负数。</span><br><span class="line"></span><br><span class="line">08. 字符间距 letter-spacing 属性是用于控制字符间的间距，即无论单词或词语中含有空格</span><br><span class="line">	（该属性对空格字符无效），该属性都会生效，单位同样为Web技术的常用度量单位，</span><br><span class="line">	同样为可以为负数。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-字体设置"><a href="#2-字体设置" class="headerlink" title="2.字体设置"></a>2.字体设置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">01. 字体颜色</span><br><span class="line">在目前的浏览器标准中，要想改变浏览器默认字体的颜色（#000000）唯一的途径就是通过</span><br><span class="line">CSS的 color 属性进行设置。颜色属性可以设置4种类型的值，有以下类型：颜色属于继承属性</span><br><span class="line"></span><br><span class="line">颜色英文单词</span><br><span class="line">	HEX（16进制颜色）</span><br><span class="line">	RGBa&#x2F;RGB（Alpha的三原色）</span><br><span class="line">	HSLa（Alpha的Hue、Saturation、Lightness）</span><br><span class="line">	Transparent（透明）</span><br><span class="line">	inherit（继承父级）</span><br><span class="line"></span><br><span class="line">02. 字体样式</span><br><span class="line">font-style 用于设置字体类型，可设置以下值：</span><br><span class="line"></span><br><span class="line">	normal：普通字体</span><br><span class="line">	italic：斜体</span><br><span class="line">	oblique：倾斜字体</span><br><span class="line"></span><br><span class="line">03. 字体粗细</span><br><span class="line">font-weight 用于设置字体粗细，可设置以下值：</span><br><span class="line"></span><br><span class="line">	normal：正常粗细</span><br><span class="line">	bold：粗体</span><br><span class="line">	bolder：更粗的字体</span><br><span class="line">	lighter：更细的字体</span><br><span class="line">	100~900：步长为100，400 等同于 normal，而 700 等同于 bold</span><br><span class="line">	</span><br><span class="line">04. 字体大小 font-size 目前浏览器的主流的字号都是采用16像素（px）的字体。</span><br><span class="line"></span><br><span class="line">05. 字体名称 font-family 用于设置字体系列，就是我们通常说的“所用字体”。</span><br><span class="line"></span><br><span class="line">06. 字体组合值 font 属性用于设置字体样式的组合值写法，其语法形式为：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">扩展：文字两端对齐</span><br><span class="line"></span><br><span class="line">div &#123;</span><br><span class="line"></span><br><span class="line">    width: 120px;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    margin:  2px;</span><br><span class="line">    border:  1px solid #ff4500;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line"></span><br><span class="line">    text-align-last: justify; &#x2F;*两端对齐*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="css元素分类"><a href="#css元素分类" class="headerlink" title="css元素分类"></a>css元素分类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.在CSS中，html中的标签元素大体被分为三种不同的类型：</span><br><span class="line">	块状元素、内联元素(又叫行内元素)和内联块状元素。</span><br><span class="line"></span><br><span class="line">常用的块状元素有：</span><br><span class="line">&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;</span><br><span class="line">常用的内联元素有：</span><br><span class="line">&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;</span><br><span class="line">常用的内联块状元素有：</span><br><span class="line">&lt;img&gt;、&lt;input&gt;</span><br><span class="line"></span><br><span class="line">2.块级元素 block</span><br><span class="line"></span><br><span class="line">块级元素特点：</span><br><span class="line">	1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。</span><br><span class="line">	2、元素的高度、宽度、行高以及顶和底边距都可设置。</span><br><span class="line">	3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），</span><br><span class="line">	   除非设定一个宽度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.内联元素 inline</span><br><span class="line">	内联元素特点:</span><br><span class="line">	1、和其他元素都在一行上；</span><br><span class="line">	2、元素的高度、宽度及顶部和底部边距不可设置；</span><br><span class="line">	3、元素的宽度就是它包含的文字或图片的宽度，不可改变。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.内联块状 inline-block</span><br><span class="line">	特点</span><br><span class="line">	1、和其他元素都在一行上；</span><br><span class="line">	2、元素的高度、宽度、行高以及顶和底边距都可设置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.类型转换  通过display:block 我们可以将元素转换类型  a&#123;display:block;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-盒模型"><a href="#4-盒模型" class="headerlink" title="4.盒模型"></a>4.盒模型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 所谓盒子模型，即是将网页布局中的元素（行内&#x2F;行内块元素）进行拟物化的比喻，一个盒子由内容</span><br><span class="line">（content）、内间距（padding）、边框（border）以及外边距（margin）组成</span><br><span class="line">提示：只有 块级元素 与 行内块元素 具备盒子模型。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. CSS盒子模型的类型主要有两个：</span><br><span class="line">	IE浏览器盒子模型：box-sizing:border-box;</span><br><span class="line">	标准（W3C，其它主流浏览器）盒子模型（默认）：box-sizing:content-box;</span><br><span class="line"></span><br><span class="line">3.盒子属性：</span><br><span class="line">	宽度：width</span><br><span class="line">	高度：height</span><br><span class="line">	内间距：padding  设置盒子内容与边框之间的间距，即内间距（填充）</span><br><span class="line">			padding 可以接收的值为：像素（px）、百分比（%）、inherit（继承）</span><br><span class="line">									以及auto（浏览器自计算）</span><br><span class="line">	外间距：margin   margin 属性主要用于设置某元素相对于同级元素和父级元素的一个距离值，</span><br><span class="line">	       常用单位像素“px”。该属性对文本类元素（即“行内元素”）标签是无效的。</span><br><span class="line">	       和 padding 一样</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.边框：border 属性的作用是为设定该属性的元素添加边框 该属性能对任何显示类型的元素设置，包括</span><br><span class="line">		“行级元素（inline）”。该属性有三个分支属性：</span><br><span class="line">		1）、border-width</span><br><span class="line">		设置边框宽度，单位为像素。设定边框的宽度。可以为Web技术中常用的度量单位，</span><br><span class="line">		通常为像素“px”。</span><br><span class="line">		2）、border-style</span><br><span class="line">		设置边框的类型，主要有以下可以设定的值：</span><br><span class="line">				none：无边框  solid：实线边框  dotted：点线边框  </span><br><span class="line">				dashed：虚线边框</span><br><span class="line">				double：双线边框  groove：3D凹槽边框  </span><br><span class="line">				ridge：3D凸槽边框 </span><br><span class="line">				inset：内浮雕边框  outset：外浮雕边框</span><br><span class="line">		3）、border-color</span><br><span class="line">		设置边框颜色，支持英文单词、十六进制以及rgb颜色。</span><br><span class="line">		4）、border  </span><br><span class="line">		通过 border 属性直接设置四个方向的边框样式</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">5.盒子圆角</span><br><span class="line">border-radius：设置边框圆角</span><br><span class="line"></span><br><span class="line">6.元素阴影</span><br><span class="line">box-shadow 属性能够让元素获得一个“阴影”效果，根据颜色的不同，有时候也可以叫做“发光”效果</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="css布局模型"><a href="#css布局模型" class="headerlink" title="css布局模型"></a>css布局模型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.css的布局模式分类: </span><br><span class="line">	流动模型（Flow）浮动模型 (Float) 层模型（Layer）</span><br><span class="line"></span><br><span class="line">2.流动（Flow）是默认的网页布局模式。也就是说网页在默认状态下的 HTML 网页元素都是根据流动模型</span><br><span class="line">来分布网页内容的。</span><br><span class="line">	特征：（1）块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，</span><br><span class="line">				块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。</span><br><span class="line">		 （2）第二点，在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。</span><br><span class="line">		 		（内联元素可不像块状元素这么霸道独占一行）</span><br><span class="line">			</span><br><span class="line">3.float 浮动模型</span><br><span class="line">	块状元素都是独占一行，如果现在我们想让两个块状元素并排显示</span><br><span class="line">	任何元素在默认情况下是不能浮动的，但可以用 CSS 定义为浮动，如 div、p、table、img </span><br><span class="line">	等元素都可以被定义为浮动。</span><br><span class="line"></span><br><span class="line">4.层模型：能让层一样可以对每个图层能够精确定位操作</span><br><span class="line">	层模型有三种形式：</span><br><span class="line">	1、绝对定位(position: absolute) 绝对定位,把图形定义在绝对的位置</span><br><span class="line">	2、相对定位(position: relative) 为元素设置层模型中的相对定位，需要设置position:relative</span><br><span class="line">	（表示相对定位），它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。</span><br><span class="line">	3、固定定位(position: fixed) fixed：表示固定定位，与absolute定位类型类似，但它的相对</span><br><span class="line">	  移动的坐标是视图（屏幕内的网页窗口）本身</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="css可见性"><a href="#css可见性" class="headerlink" title="css可见性"></a>css可见性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.CSS Display(显示) 与 Visibility（可见性）</span><br><span class="line"></span><br><span class="line">visibility:hidden:可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。</span><br><span class="line">		            也就是说，该元素虽然被隐藏了，但仍然会影响布局。</span><br><span class="line"></span><br><span class="line">display:none:可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但</span><br><span class="line">	          被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;title&gt;Title&lt;&#x2F;title&gt; &lt;style&gt;</span><br><span class="line">    ul&#123;</span><br><span class="line">        list-style-type: none;</span><br><span class="line">    &#125;</span><br><span class="line">    #ul1&#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">        1.把 边框去掉</span><br><span class="line">        2. 把li标签上面的点号去掉</span><br><span class="line">        *&#x2F;</span><br><span class="line">        margin: auto;</span><br><span class="line">        padding: 0;</span><br><span class="line">        width: 400px;</span><br><span class="line">    &#125;</span><br><span class="line">    #ul1&gt;li&#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">        给li标签整个增加背景颜色</span><br><span class="line">        给li标签增加下面的分析</span><br><span class="line">        *&#x2F;</span><br><span class="line">        background-color: #8bd400;</span><br><span class="line">        margin-bottom: 2px;</span><br><span class="line">        margin-left: 2px;</span><br><span class="line">        height: 40px;</span><br><span class="line">        width: 80px;</span><br><span class="line">        border-radius: 5px;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    a&#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">        把a标签的下划线去掉</span><br><span class="line">         *&#x2F;</span><br><span class="line">        display:block;</span><br><span class="line">        height: 40px;</span><br><span class="line">        text-decoration: none;</span><br><span class="line">        &#x2F;*</span><br><span class="line">        把文字放在中间</span><br><span class="line">        *&#x2F;</span><br><span class="line">        text-align: center;</span><br><span class="line">        &#x2F;*</span><br><span class="line">        把文字行间距和整个block一样,那么文字就居中了</span><br><span class="line">        *&#x2F;</span><br><span class="line">        line-height:40px;</span><br><span class="line">        &#x2F;*</span><br><span class="line">        加上椭圆</span><br><span class="line">        *&#x2F;</span><br><span class="line"></span><br><span class="line">        border-radius: 5px;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    #li1&#123;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #li1 ul&#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">        position: absolute;</span><br><span class="line">        display: none;</span><br><span class="line">    &#125;</span><br><span class="line">    #li1 ul&gt;li&#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        color: grey;</span><br><span class="line">        text-align: left;</span><br><span class="line">        border: 1px solid;</span><br><span class="line">        background-color: #ffcf41;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    当数据过去的时候,整体变成深绿色</span><br><span class="line">     *&#x2F;</span><br><span class="line">    a:hover&#123;</span><br><span class="line">        background-color: green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*.c_li1:hover #ul2&#123;*&#x2F;</span><br><span class="line">        &#x2F;*display: block;*&#x2F;</span><br><span class="line">    &#x2F;*&#125;*&#x2F;</span><br><span class="line"></span><br><span class="line">    #ul1 li:hover &gt;a~ul&#123;</span><br><span class="line">        display: block;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #ul2 a:hover&#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css语法</tag>
      </tags>
  </entry>
  <entry>
    <title>html语法03--js语法</title>
    <url>/jwangcloud/3810165720/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/html.jpeg"></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><span id="more"></span>

<h4 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">      &#x2F;*</span><br><span class="line">      &#x2F;&#x2F;前端语法会尽量隐藏报错</span><br><span class="line">      const i &#x3D; 10;  &#x2F;&#x2F;常量定义</span><br><span class="line">      var a &#x3D; 10;</span><br><span class="line">      var b &#x3D; 20;</span><br><span class="line">      var c &#x3D; a + b;</span><br><span class="line">      var d &#x3D; &quot;helllo world&quot;;</span><br><span class="line">      var e &#x3D; &quot;1234&quot;</span><br><span class="line">      console.log(a);</span><br><span class="line">      console.log(c); &#x2F;&#x2F;在浏览器中开发者工具console中打印输出</span><br><span class="line">      console.log(d);</span><br><span class="line">      document.write(a);&#x2F;&#x2F;在浏览器页面输出</span><br><span class="line">      document.write(d);</span><br><span class="line">      document.write(a+d);  &#x2F;&#x2F;可以直接加减任何类型</span><br><span class="line">      document.write(Number(e)+a); &#x2F;&#x2F;使用Number String等进行类型转换</span><br><span class="line">      alert(&quot;helllo world&quot;) &#x2F;&#x2F;页面弹窗</span><br><span class="line">      &#x2F;&#x2F;js中类型</span><br><span class="line">      var b;</span><br><span class="line">      b &#x3D; 10; &#x2F;&#x2F; &#39;number&#39;</span><br><span class="line">      console.log(typeof b);</span><br><span class="line">      b &#x3D; true; &#x2F;&#x2F; &#39;boolean&#39;</span><br><span class="line">      console.log(typeof b);</span><br><span class="line">      a &#x3D; &#39;Henrry Lee&#39;; &#x2F;&#x2F; &#39;string&#39;</span><br><span class="line">      console.log(typeof a);</span><br><span class="line">      a &#x3D; function()&#123;&#125;; &#x2F;&#x2F; &#39;function&#39;</span><br><span class="line">      console.log(typeof a);</span><br><span class="line">      a &#x3D; &#123;age:26&#125;; &#x2F;&#x2F; &#39;object&#39;</span><br><span class="line">      console.log(typeof a);</span><br><span class="line"></span><br><span class="line">      *&#x2F;</span><br><span class="line">      var aa &#x3D; [1,2,3,4,56,23,1];</span><br><span class="line">      for(var i in aa)&#123;</span><br><span class="line">          document.write(&quot;下标：&quot; + i + &quot;  ||值：&quot; + aa[i] + &#39;&lt;br&gt;&#39;);</span><br><span class="line">      &#125;</span><br><span class="line">      for (var i of aa)&#123;</span><br><span class="line">          document.write(i+&#39;  &#39;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      function plus(num) &#123;</span><br><span class="line">          if(num &#x3D;&#x3D;&#x3D; 1)&#123;</span><br><span class="line">              return num;</span><br><span class="line">          &#125;</span><br><span class="line">          return num + plus(num - 1);</span><br><span class="line">      &#125;</span><br><span class="line">      var sum &#x3D; plus(100);</span><br><span class="line">      document.write(&#39;&lt;br&gt;&#39; + sum);</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-函数方法"><a href="#2-函数方法" class="headerlink" title="2.函数方法"></a>2.函数方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;&lt;title&gt;js基础教学&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">&lt;&#x2F;ol&gt;</span><br><span class="line">&lt;button onclick&#x3D;first()&gt;确认&lt;&#x2F;button&gt;  &lt;!--捕捉onclik事件操作并执行所对应函数 </span><br><span class="line">可以写在这里也可以重新定义函数引用--&gt;</span><br><span class="line">&lt;button onclick&#x3D;&quot;&quot;&gt;第二次确认&lt;&#x2F;button&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;button onclick&#x3D;&quot;&quot;&gt;第三次确认&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function first()&#123;                &#x2F;&#x2F;定义函数</span><br><span class="line">      alert(&#39;确认点击后 弹窗函数被执行&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">  var b &#x3D; document.getElementsByTagName(&#39;button&#39;)[1];  &#x2F;&#x2F;确认位置</span><br><span class="line">  b.onclick &#x3D; function()&#123;   &#x2F;&#x2F;函数编写并绑定&#39;点击&#39;事件</span><br><span class="line">      alert(&#39;新方法，直接绑定点击事件并弹窗&#39;);</span><br><span class="line">  &#125;;</span><br><span class="line">  var c &#x3D; document.getElementsByTagName(&#39;button&#39;)[2];</span><br><span class="line">  c.onmouseover &#x3D; function()&#123;    &#x2F;&#x2F;移到该位置便弹窗事件</span><br><span class="line">      alert(&#39;鼠标进过便弹窗&#39;)</span><br><span class="line">  &#125;;</span><br><span class="line">  &#x2F;*</span><br><span class="line">  ol &#x3D; document.getElementsByTagName(&quot;ol&quot;);</span><br><span class="line">  ol &#x3D; ol[0];</span><br><span class="line">  ol.children;</span><br><span class="line">  ol.childNodes;</span><br><span class="line">  ol.childNodes[2];</span><br><span class="line">  ol.firstElementChild;</span><br><span class="line">  ol.lastElementChild;</span><br><span class="line">  l1 &#x3D; ol.parentElement;</span><br><span class="line">   x1 &#x3D; li1.previousElementSibling; &#x2F;&#x2F;直接在console中输入即可</span><br><span class="line">   *&#x2F;</span><br><span class="line">  ol &#x3D; document.getElementsByTagName(&#39;ol&#39;)[0];  &#x2F;&#x2F;插入子节点步骤 1。获取标签</span><br><span class="line">  var li2 &#x3D; document.createElement(&#39;li&#39;); &#x2F;&#x2F;2。创建子标签</span><br><span class="line">  ol.appendChild(li2); &#x2F;&#x2F;3。添加标签</span><br><span class="line">  li2.innerText &#x3D; &#39;Test&#39;; &#x2F;&#x2F;4，标签内容</span><br><span class="line">  var li3 &#x3D; document.createElement(&#39;li&#39;);</span><br><span class="line">  ol.appendChild(li3);</span><br><span class="line">  li3.innerText &#x3D; &#39;Test2&#39;;</span><br><span class="line">  var body1 &#x3D; document.getElementsByTagName(&#39;body&#39;);  &#x2F;&#x2F;插入相邻节点步骤 1。获取标签</span><br><span class="line">  body1 &#x3D; body1[0];  &#x2F;&#x2F;2。精确定位标签</span><br><span class="line">  var div1 &#x3D; document.createElement(&#39;div&#39;); &#x2F;&#x2F;3。创建div标签</span><br><span class="line">  body1.insertBefore(div1,ol);  &#x2F;&#x2F;4.插入该标签</span><br><span class="line">  div1.innerText &#x3D; &#39;xxxxx&#39;; &#x2F;&#x2F;5.标签内容</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-js练习"><a href="#3-js练习" class="headerlink" title="3.js练习"></a>3.js练习</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;js练习&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  td&#123;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">  &#125;</span><br><span class="line">  *&#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;table cellspacing&#x3D;&quot;0px&quot; id &#x3D; &#39;t1&#39;&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td colspan&#x3D;&quot;4&quot;&gt;</span><br><span class="line">      &lt;button onclick&#x3D;&quot;add()&quot;&gt;添加&lt;&#x2F;button&gt;&lt;button onclick&#x3D;&quot;del()&quot;&gt;删除&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;td&gt;</span><br><span class="line">  &lt;&#x2F;tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;全选 &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;check&quot;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;书号&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;书名&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;作者&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function add() &#123;   &#x2F;&#x2F;添加按钮：添加表格标签并加入内容</span><br><span class="line">      var table &#x3D; document.getElementById(&#39;t1&#39;);  &#x2F;&#x2F;获取table下标签</span><br><span class="line">      var tr1 &#x3D; document.createElement(&#39;tr&#39;);  &#x2F;&#x2F;创建tr标签</span><br><span class="line">      tr1.innerHTML &#x3D; &quot;&lt;td&gt;&lt;input type &#x3D; \&quot;checkbox\&quot; name&#x3D;\&quot;check\&quot;&gt;</span><br><span class="line">      &lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&quot;; &#x2F;&#x2F;在tr标签中输入html语法</span><br><span class="line">      table.appendChild(tr1); &#x2F;&#x2F;tr中添加该语法</span><br><span class="line">  &#125;</span><br><span class="line">  function del() &#123;</span><br><span class="line">      var inputs &#x3D; document.getElementsByTagName(&#39;input&#39;);</span><br><span class="line">      var del_inputs &#x3D; [];</span><br><span class="line">      for(let i of inputs)&#123;</span><br><span class="line">          console.log(i.checked);   &#x2F;&#x2F;是否选中：根据checked的值确定</span><br><span class="line">          if(i.checked) &#123;</span><br><span class="line">              del_inputs.push(i)     &#x2F;&#x2F;删除该按钮的值</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;return del_inputs</span><br><span class="line">      for(let i of del_inputs)&#123;</span><br><span class="line">          let tr2 &#x3D; i.parentNode.parentNode;</span><br><span class="line">          let table2 &#x3D; tr2.parentNode;</span><br><span class="line">         table2.removeChild(tr2);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js语法</tag>
      </tags>
  </entry>
  <entry>
    <title>web02--html属性</title>
    <url>/jwangcloud/2741279174/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/html.jpeg"></p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该属性能用于所有的HTML元素，为HTML元素指定一个唯一的标识符，用于CSS设置，</span><br><span class="line">JavasSript进行操作或其它脚本语言及服务器端语言进行设置操作。</span><br><span class="line"></span><br><span class="line">&lt;p id&#x3D;&quot;des&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;b id&#x3D;&quot;title&quot;&gt;&lt;&#x2F;b&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该属性可以用于所有HTML元素，为元素添加一个或多个类名。通常是用于CSS设置或配</span><br><span class="line">合JavaScript进行操作设置，多个类名以空格符进行分隔，多个元素可以使用同一个类名。</span><br><span class="line"></span><br><span class="line">&lt;section class&#x3D;&quot;box fr&quot;&gt;&lt;&#x2F;section&gt;</span><br><span class="line">&lt;section class&#x3D;&quot;box&quot;&gt;&lt;&#x2F;section&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该属性可以用于所有HTML元素，通过设置它的值，可以让用户鼠标悬浮在该元素上显示出“title”</span><br><span class="line">属性中所设置的值。如之前提到的标签。起到一个补充说明的作用。</span><br><span class="line"></span><br><span class="line">&lt;img src&#x3D;&quot;1.jpegv&quot; alt&#x3D;&quot;图片加载失败...&quot; title&#x3D;&quot;Ferrari&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="lang"><a href="#lang" class="headerlink" title="lang"></a>lang</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该属性用于设置元素的语言类型，不支持的标标有&lt;base&gt;，&lt;br&gt;，&lt;frame&gt;，&lt;frameset&gt;，</span><br><span class="line">&lt;hr&gt;，&lt;iframe&gt;，&lt;param&gt; 及 &lt;script&gt;，但通常的使用方式是直接给标签设置该属性，</span><br><span class="line">如：&lt;html lang&#x3D;&quot;zh-cn&quot;&gt;、&lt;html lang&#x3D;&quot;zh&quot;&gt;、&lt;html lang&#x3D;&quot;en&quot;&gt;这样的形式，</span><br><span class="line">分别表示将语言类型设置为“简体中文”、“中文”、“英文”。</span><br></pre></td></tr></table></figure>

<h3 id="h5播放器"><a href="#h5播放器" class="headerlink" title="h5播放器"></a>h5播放器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;video controls&#x3D;&quot;controls&quot; autoplay&#x3D;&quot;autoplay&quot;&gt;</span><br><span class="line">    &lt;source src&#x3D;&quot;h5_player1.mp4&quot; type&#x3D;&quot;video&#x2F;mp4&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;video&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>html属性</tag>
      </tags>
  </entry>
  <entry>
    <title>html语法01--html基础</title>
    <url>/jwangcloud/4252999164/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/html.jpeg"></p>
<h3 id="1-html简介"><a href="#1-html简介" class="headerlink" title="1.html简介"></a>1.html简介</h3><span id="more"></span>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标记语言：注重文档结构</span><br><span class="line">程序语言：注重控制计算机</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">常用标记语言：</span><br><span class="line">Xml: XML是元标识语言，用户可以根据自身的需要定义一些标记 </span><br><span class="line">Html: 这是一种用来制作超文本文档的简单标记语言，用其编写的文档通常后缀为html</span><br><span class="line">XHTML:HTML的增强版，它的灵活性和扩展性会适应未来网络应用的更多需求,语法要求更严格</span><br><span class="line">HTML5: html最新标准</span><br><span class="line"></span><br><span class="line">js css html 关系</span><br><span class="line">html： 负责创建，负责语义的表达，解决了页面“显示内容是什么”的问题</span><br><span class="line">css：负责解决网页中内容该如何显示的问题</span><br><span class="line">javascript：负责讲解网页内容对事件该做出什么样的反应</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-html结构"><a href="#2-html结构" class="headerlink" title="2.html结构"></a>2.html结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;                     &#x2F;&#x2F;申明html文档</span><br><span class="line">&lt;html lang&#x3D;&quot;zh-Hans&quot;&gt;  </span><br><span class="line">    &lt;head&gt;                          &#x2F;&#x2F;head 头部标签</span><br><span class="line">        &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;      </span><br><span class="line">&#x2F;&#x2F;meta 无结束标签，通过对应的属性来设置编码格式（必要）、</span><br><span class="line">设备显示缩放、搜索引擎关键字、描述、浏览器内核渲染方式等内容。        </span><br><span class="line">		&lt;title&gt;Document&lt;&#x2F;title&gt;     &#x2F;&#x2F;title 设置网页标题</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;&lt;&#x2F;body&gt;                   &#x2F;&#x2F;body 内容</span><br><span class="line">&lt;&#x2F;html&gt;                             &#x2F;&#x2F;html 文档跟节点    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-html-基础标签和元素"><a href="#3-html-基础标签和元素" class="headerlink" title="3.html 基础标签和元素"></a>3.html 基础标签和元素</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h: &lt;h1&gt;&lt;&#x2F;h1&gt;  标题，有1，2，3，4。。。等标题</span><br><span class="line">p:&lt;p&gt;&lt;&#x2F;p&gt;     段落  不识别回车和空格 （回车会识别为空格，一个或多个空格为一个空格）</span><br><span class="line">body:&lt;body&gt;&lt;&#x2F;body&gt;  网页上需要显示的信息，其html主体写在body里面</span><br><span class="line">meta：&lt;meta charset&#x3D;&quot;UTF-8&quot; http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;40&quot;&gt;  闭合标签，其中可设置字符集 </span><br><span class="line">		charset:标签属性 设置字符集</span><br><span class="line">		http-equiv: 网页刷新</span><br><span class="line">		content:刷新间隔秒数</span><br><span class="line">title:&lt;title&gt;&lt;&#x2F;title&gt;  标题，整个网页的标题</span><br><span class="line">hr:&lt;hr&gt;   水平线标签</span><br><span class="line">br:&lt;br&gt;   换行</span><br><span class="line">a:&lt;a href&#x3D;&quot;url&quot; target&#x3D;&quot;_blank&quot;&gt;&lt;&#x2F;a&gt;  超链接</span><br><span class="line">		target&#x3D;&quot;_blank&quot;  从新窗口打开 </span><br><span class="line">		&lt;a href&#x3D;“url” download&gt;链接文本&lt;&#x2F;a&gt;  下载到本地</span><br><span class="line">		&lt;a href&#x3D;&quot;#c2&quot;&gt;跳转到c2&lt;&#x2F;a&gt;  跳转到id&#x3D;c2所对应的标签</span><br><span class="line">img:&lt;img src&#x3D;&quot;images&#x2F;a1.png&quot;&gt;  浏览器展示图片</span><br><span class="line"></span><br><span class="line">b:&lt;b&gt;&lt;&#x2F;b&gt;  字体加粗</span><br><span class="line"></span><br><span class="line">语义化标签：</span><br><span class="line">	strong:&lt;&gt;&lt;&#x2F;&gt;  强调语句</span><br><span class="line">	em:&lt;&gt;&lt;&#x2F;&gt;   强调</span><br><span class="line">	div:&lt;&gt;&lt;&#x2F;&gt;  布局标签（通用容器）</span><br><span class="line">	article:&lt;&gt;&lt;&#x2F;&gt; 用于文章、新闻或博客，表示文档、页面、应用或一个独立的容器 可嵌套</span><br><span class="line">	section:&lt;&gt;&lt;&#x2F;&gt; 章节标签</span><br><span class="line">	aside:&lt;&gt;&lt;&#x2F;&gt; 指定附注栏，包括引述、侧栏、指向文章的一组链接、广告、友情链接、相关产品列表等</span><br><span class="line">	header:&lt;header&gt;&lt;&#x2F;header&gt; 网页的额外信息，比如网页的脚本语言和网页使用的字符集等</span><br><span class="line">	footer:&lt;&gt;&lt;&#x2F;&gt;  页脚	</span><br><span class="line">	nav:&lt;&gt;&lt;&#x2F;&gt; 标记导航，仅对文档中重要的链接使用</span><br><span class="line">	time:&lt;&gt;&lt;&#x2F;&gt; 时间</span><br><span class="line">	main:&lt;&gt;&lt;&#x2F;&gt; 页面主要内容，一个页面只使用一次			</span><br><span class="line">			</span><br><span class="line">特殊符号：</span><br><span class="line">		&amp;lt  &lt;</span><br><span class="line">		&amp;gt   &gt;</span><br><span class="line">		&amp;nbsp  空格</span><br><span class="line">		&amp;amp  &amp;</span><br><span class="line">		&amp;quot  &quot;</span><br><span class="line">		&amp;qpos  &#39;</span><br><span class="line"></span><br><span class="line">pre:&lt;pre&gt;&lt;&#x2F;pre&gt;  原样输出，适合编程语句的显示</span><br><span class="line"></span><br><span class="line">iframe框架：通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面</span><br><span class="line">&lt;iframe src&#x3D;&quot;demo_iframe.htm&quot; name&#x3D;&quot;iframe_a&quot; scrolling&#x3D;&quot;yes&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line">name：设置iframe的名称</span><br><span class="line"></span><br><span class="line">width：设置iframe的宽度，值可以为像素（不用添加“px”单位）和百分数</span><br><span class="line"></span><br><span class="line">height：设置iframe的高度，值可以为像素（不用添加“px”单位）和百分数</span><br><span class="line"></span><br><span class="line">src：设置iframe元素内需要显示页面或文件的URL地址，</span><br><span class="line">该属性的值可以由与之关联的a标签点击设置（通过将a标签的“target”</span><br><span class="line">属性的值设置为该iframe的“name”属性的值进行关联）</span><br><span class="line"></span><br><span class="line">frameborder：设置是否显示边框（0 表示不显示边框&#x2F; 1 表示要显示边框）</span><br><span class="line"></span><br><span class="line">scrolling：设置是否允许滚动（auto&#x2F;yes&#x2F;no）</span><br></pre></td></tr></table></figure>

<h3 id="4-html列表标签"><a href="#4-html列表标签" class="headerlink" title="4.html列表标签"></a>4.html列表标签</h3><table>
<thead>
<tr>
<th align="center">元素</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ol</td>
<td align="center">定义有序列表</td>
</tr>
<tr>
<td align="center">ul</td>
<td align="center">定义无序列表</td>
</tr>
<tr>
<td align="center">li</td>
<td align="center">列表内容</td>
</tr>
<tr>
<td align="center">dl</td>
<td align="center">自定义列表</td>
</tr>
<tr>
<td align="center">dt</td>
<td align="center">列表项目描述</td>
</tr>
<tr>
<td align="center">dd</td>
<td align="center">列表项目描述</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;h4&gt;无序列表:&lt;&#x2F;h4&gt;</span><br><span class="line">	&lt;ul&gt;</span><br><span class="line">	  &lt;li&gt;Coffee&lt;&#x2F;li&gt;</span><br><span class="line">	  &lt;li&gt;Tea&lt;&#x2F;li&gt;</span><br><span class="line">	  &lt;li&gt;Milk&lt;&#x2F;li&gt;</span><br><span class="line">	&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;h4&gt;无序列表:&lt;&#x2F;h4&gt;</span><br><span class="line">	&lt;ol start&#x3D;’50’&gt;</span><br><span class="line">	  &lt;li&gt;Coffee&lt;&#x2F;li&gt;</span><br><span class="line">	  &lt;li&gt;Tea&lt;&#x2F;li&gt;</span><br><span class="line">	  &lt;li&gt;Milk&lt;&#x2F;li&gt;</span><br><span class="line">	&lt;&#x2F;ol&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;dl&gt;</span><br><span class="line">	 &lt;dt&gt;a&lt;&#x2F;dt&gt;</span><br><span class="line">	 &lt;dd&gt;a1&lt;&#x2F;dd&gt;</span><br><span class="line">	 &lt;dd&gt;a2&lt;&#x2F;dd&gt;</span><br><span class="line">	 &lt;dt&gt;b&lt;&#x2F;dt&gt;</span><br><span class="line">	 &lt;dd&gt;b1&lt;&#x2F;dd&gt;</span><br><span class="line">	 &lt;dd&gt;b2&lt;&#x2F;dd&gt;</span><br><span class="line">	 &lt;dt&gt;c&lt;&#x2F;dt&gt;</span><br><span class="line">	 &lt;dd&gt;c1&lt;&#x2F;dd&gt;</span><br><span class="line">	 &lt;dd&gt;c2&lt;&#x2F;dd&gt;</span><br><span class="line">&lt;&#x2F;dl&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-格式化标签"><a href="#5-格式化标签" class="headerlink" title="5.格式化标签"></a>5.格式化标签</h3><table>
<thead>
<tr>
<th align="center">标签</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">b</td>
<td align="center">粗字体</td>
</tr>
<tr>
<td align="center">em</td>
<td align="center">着重</td>
</tr>
<tr>
<td align="center">i</td>
<td align="center">斜体字</td>
</tr>
<tr>
<td align="center">small</td>
<td align="center">小号字</td>
</tr>
<tr>
<td align="center">strong</td>
<td align="center">加重语气</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">下标字</td>
</tr>
<tr>
<td align="center">sup</td>
<td align="center">上标字</td>
</tr>
<tr>
<td align="center">ins</td>
<td align="center">插入字</td>
</tr>
<tr>
<td align="center">del</td>
<td align="center">删除字</td>
</tr>
</tbody></table>
<h3 id="6-语言分类"><a href="#6-语言分类" class="headerlink" title="6.语言分类"></a>6.语言分类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">编程语言：python，运算用</span><br><span class="line">标记语言：结构化文档</span><br><span class="line">自然语言：信息搜索等</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>html基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Django框架10--项目部署</title>
    <url>/jwangcloud/3485546001/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/Django.jpeg"></p>
<h1 id="部署基本要求"><a href="#部署基本要求" class="headerlink" title="部署基本要求"></a>部署基本要求</h1><span id="more"></span>

<p>1.通过yum安装python3.5以上 使python程序不和系统本身python冲突(宝塔后台使用了默认<br>python)</p>
<p>2.安装虚拟环境</p>
<p>3.通过git ssh公钥下载部署代码</p>
<p>4.书写supervisord脚本，使用脚本启动项目</p>
<p>5.安装nginx</p>
<h1 id="app服务器部署"><a href="#app服务器部署" class="headerlink" title="app服务器部署"></a>app服务器部署</h1><p>1.安装python3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /opt/mypython3</span><br><span class="line">wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz</span><br><span class="line">tar -zxvf Python-3.6.5.tgz</span><br><span class="line"><span class="built_in">cd</span> Python-3.6.5</span><br><span class="line">./configure --prefix=/opt/mypython3</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>


<p>2.安装虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;opt&#x2F;mypython3&#x2F;bin</span><br><span class="line"></span><br><span class="line">.&#x2F;pip3 install virtualenvwrapper</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir ~&#x2F;Envs</span><br><span class="line">cd ~&#x2F;Envs</span><br><span class="line">virtualenv movie_online -p &#x2F;opt&#x2F;mypython3&#x2F;bin&#x2F;python3.6</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>激活虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~&#x2F;Envs&#x2F;movie_online&#x2F;bin&#x2F;activate</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.部署代码</p>
<p>生成ssh公钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>把公钥放入gitee私人设置</p>
<p>建目录 托代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;project</span><br><span class="line">cd &#x2F;project</span><br><span class="line">git clone git@gitee.com:pengmao&#x2F;MoDuXiXiaAPP.git movie_online</span><br><span class="line">mkdir &#x2F;project&#x2F;movie_online&#x2F;backend&#x2F;log</span><br><span class="line">mkdir &#x2F;project&#x2F;movie_online&#x2F;backend&#x2F;log&#x2F;gunicorn</span><br></pre></td></tr></table></figure>

<p>4.安装supervisor并使用</p>
<p>给虚拟环境安装pip 包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -r &#x2F;project&#x2F;movie_online&#x2F;backend&#x2F;requirements.txt</span><br></pre></td></tr></table></figure>

<p>使用自带的python2.6安装supervisord</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deactivate</span><br><span class="line"></span><br><span class="line">pip install supervisor</span><br><span class="line"></span><br><span class="line">mkdir &#x2F;project&#x2F;supervisor</span><br><span class="line">cd &#x2F;project&#x2F;supervisor</span><br><span class="line">echo_supervisord_conf &gt; supervisor.conf</span><br><span class="line"></span><br><span class="line">mkdir &#x2F;project&#x2F;supervisor&#x2F;movie_online_log</span><br></pre></td></tr></table></figure>

<p>supervisord配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[program:movie_online]</span><br><span class="line">command&#x3D;&#x2F;root&#x2F;Envs&#x2F;movie_online&#x2F;bin&#x2F;gunicorn -c gunicorn_conf.py movie_1.wsgi</span><br><span class="line">directory&#x3D;&#x2F;project&#x2F;movie_online&#x2F;backend</span><br><span class="line">startsecs&#x3D;0</span><br><span class="line">stopwaitsecs&#x3D;0</span><br><span class="line">autostart&#x3D;true</span><br><span class="line">autorestart&#x3D;true</span><br><span class="line">stdout_logfile&#x3D;&#x2F;project&#x2F;supervisor&#x2F;movie_online_log&#x2F;gunicorn.log</span><br><span class="line">stderr_logfile&#x3D;&#x2F;project&#x2F;supervisor&#x2F;movie_online_log&#x2F;gunicorn.err</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>supervisord启动命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">supervisord -c &#x2F;project&#x2F;supervisor&#x2F;supervisor.conf</span><br><span class="line">supervisorctl -c &#x2F;project&#x2F;supervisor&#x2F;supervisor.conf status 察看supervisor的状态</span><br><span class="line">supervisorctl -c &#x2F;project&#x2F;supervisor&#x2F;supervisor.conf reload 重新载入 配置文件</span><br><span class="line">supervisorctl -c supervisor.conf stop 停止</span><br></pre></td></tr></table></figure>

<h4 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h4><p>新建日志文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;project&#x2F;logs</span><br><span class="line">mkdir &#x2F;project&#x2F;logs&#x2F;movie_online</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>nginx配置参考</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"> charset utf-8;</span><br><span class="line"> listen 80;</span><br><span class="line"> #server_name api.coolcity.tangrenapp.com;</span><br><span class="line"></span><br><span class="line"> client_max_body_size 5;</span><br><span class="line"> location &#x2F;static &#123;</span><br><span class="line">         client_max_body_size 50m;</span><br><span class="line">         alias &#x2F;project&#x2F;movie_online&#x2F;backend&#x2F;static;</span><br><span class="line">         allow all;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">         client_max_body_size 50m;</span><br><span class="line">         proxy_set_header Host $host;</span><br><span class="line">         proxy_pass http:&#x2F;&#x2F;0.0.0.0:8005;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#error_log &#x2F;root&#x2F;project&#x2F;logs&#x2F;modou&#x2F;error.log;</span><br><span class="line">error_log &#x2F;project&#x2F;logs&#x2F;movie_online&#x2F;error.log;</span><br><span class="line">access_log &#x2F;project&#x2F;logs&#x2F;movie_online&#x2F;access.log;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后收集静态文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;project&#x2F;movie_online&#x2F;backend</span><br><span class="line">source ~&#x2F;Envs&#x2F;movie_online&#x2F;bin&#x2F;activate</span><br><span class="line">python3.6 manage.py collectstatic</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="资源服务器"><a href="#资源服务器" class="headerlink" title="资源服务器"></a>资源服务器</h1><p>搭建nginx dav服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.12.2.tar.gz</span><br><span class="line">tar -zxvf nginx-1.12.2.tar.gz</span><br><span class="line">cd nginx-1.12.2</span><br><span class="line">mkdir &#x2F;opt&#x2F;mynginx</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;opt&#x2F;mynginx --with-http_dav_module</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>dav配置</p>
<p>10.19.96.0/24; 开放内网网段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen 30081;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            #root &#x2F;var&#x2F;www&#x2F;media;</span><br><span class="line">            root &#x2F;www&#x2F;wwwroot&#x2F;file.coolcity.tangrenapp.com;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         #   client_body_temp_path &#x2F;data&#x2F;client_temp;</span><br><span class="line"></span><br><span class="line">            dav_methods PUT DELETE MKCOL COPY MOVE;</span><br><span class="line"></span><br><span class="line">            create_full_put_path  on;</span><br><span class="line">            dav_access            group:rw  all:r;</span><br><span class="line">            allow 10.19.96.0&#x2F;24;</span><br><span class="line">            deny all;</span><br><span class="line">         &#125;</span><br><span class="line">        error_log  logs&#x2F;pic_error.log;</span><br><span class="line">        access_log  logs&#x2F;pic_access.log;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>user = 我 or 其他人</p>
<p>发帖人(我) 删除权限  对 我的帖子<br>看帖子的人(其他人) 没有删除权限 对 我的帖子<br>小吧主(其他人) 有删除权限 对 我的帖子</p>
<p>权限管理系统 –》 第三方</p>
<p>实现的一种 -&gt; guradian</p>
<p>权限管理系统 -&gt; RBAC-&gt; guradian</p>
<ol>
<li>赋予权限</li>
<li>查看权限</li>
<li>删除权限</li>
</ol>
<p>短评:</p>
<p>1.用户发帖的时候 使用 guradian</p>
<pre><code>1.赋予用户删帖权限
2.赋予管理员删除权限
3.赋予用户修改权限
</code></pre>
<ol start="2">
<li><p>在查看帖子的时候:<br> 去查看一下你有没有删除的权限</p>
</li>
<li><p>请求删除的时候:<br> 去查看一下你有没有删除的权限</p>
</li>
</ol>
<p>代码:<br>    from guardian.shortcuts import assign_perm<br>    from guardian.shortcuts import check_perm<br>    from guardian.shortcuts import remove_perm</p>
]]></content>
      <categories>
        <category>python框架</category>
      </categories>
      <tags>
        <tag>Django项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title>Django框架09--序列化</title>
    <url>/jwangcloud/2889044135/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/Django.jpeg"></p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><span id="more"></span>

<ol>
<li><p>操作系统: </p>
<p> os 操作系统是管理计算机硬件与软件资源的计算机程序，同时也是计算机系统的内核与基石。操作系统需要处理如管<br> 理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务。操作<br> 系统也提供一个让用户与系统交互的操作界面。</p>
</li>
<li><p>操作系统中的进程调度策略：先来先服务调度算法  短作业(进程)优先调度算法  高优先权优先调度算法  高响应比优先调度算法等</p>
</li>
<li><p>分时操作系统： 将一个时间段分成多段运行多个程序  时分：按时间分  频分：按频率分发</p>
</li>
<li><p>CPU：对指令运行  不同操作系统执行的程序不同：格式不同其无法识别，解析不出指令  例如：windows(PE) Linux(tar)</p>
</li>
<li><p>破解原理：识别格式–找寻相关指令–进行修改</p>
</li>
<li><p>os:python 中可以<br>path:环境变量  命令行输入命令时，会找寻path中的 </p>
</li>
<li><p>程序加载到内存 </p>
<p> 进程包括：文本段（指令） data（数据段 初始化/未初始化）堆（可全局访问 类的对象）<br> 栈（执行函数时会给函数分配一个空间&lt;符合递归&gt;函数执行完成后,栈相关内存销毁,所以不同函数之间的变量不可以相互访问）</p>
</li>
<li><p>地址引用：一个变量指向地址  python全是地址引用</p>
</li>
</ol>
<p>值引用：</p>
<p>进程管理：</p>
<ol start="9">
<li><p>进程创建：fork()  每一个进程都有父进程，不一定有子进程 树状结构 </p>
</li>
<li><p>ps: pid() ppid(父进程)  []：内核进程  未加括号的：用户进程</p>
</li>
</ol>
<h2 id="django-REST-framework"><a href="#django-REST-framework" class="headerlink" title="django REST framework"></a>django REST framework</h2><h3 id="前期知识"><a href="#前期知识" class="headerlink" title="前期知识"></a>前期知识</h3><p>api接口开发，最核心最常见的一个过程就是序列化，所谓序列化就是把数据转换格式，序列化可以分两个阶段：</p>
<p>1.序列化： 把我们识别的数据转换成指定的格式提供给别人。</p>
<pre><code>例如：我们在django的ORM中获取到的数据默认是模型对象，但是模型对象数据无法直接提供给前端或别的
平台使用，所以我们需要把数据进行序列化，变成字符串或者json数据，提供给别人。
</code></pre>
<p>2.反序列化：把别人提供的数据转换/还原成我们需要的格式。</p>
<pre><code>例如：前端js提供过来的json数据，对于python而言就是字符串，我们需要进行反序列化换成模型类对象，
这样我们才能把    数据保存到数据库中。
    1.接收数据[反序列化]
    2.操作数据
    3.响应数据[序列化]
</code></pre>
<h3 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h3><p><a href="https://q1mi.github.io/Django-REST-framework-documentation/#django-rest-framework">中文文档</a><br>(github: <a href="https://github.com/encode/django-rest-framework/tree/master">https://github.com/encode/django-rest-framework/tree/master</a>)</p>
<ol>
<li>需要安装的包：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install djangorestframework</span><br><span class="line">pip install markdown       <span class="comment"># Markdown support for the browsable API.</span></span><br><span class="line">pip install django-<span class="built_in">filter</span>  <span class="comment"># Filtering support</span></span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">git clone https://github.com/encode/django-rest-framework</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>项目目录下：settings–app添加–’rest_framework’</p>
</li>
<li><p>根urls：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line">from django.urls import path, include</span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    </span><br><span class="line">    url(r&#39;^api-auth&#x2F;&#39;, include(&#39;rest_framework.urls&#39;))  #添加该urls</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="jquert-api"><a href="#jquert-api" class="headerlink" title="jquert/api"></a>jquert/api</h3><h4 id="jquery"><a href="#jquery" class="headerlink" title="jquery"></a>jquery</h4><p>1.创建Model并迁移</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UserModer(models.Model):</span><br><span class="line">    username &#x3D; models.CharField(max_length&#x3D;200, null&#x3D;False, blank&#x3D;False)</span><br><span class="line">    age &#x3D; models.IntegerField()</span><br><span class="line">    gender &#x3D; models.BooleanField(default&#x3D;False)</span><br><span class="line">    </span><br><span class="line">    def to_json(self):</span><br><span class="line">    return &#123;&quot;username&quot;: self.username, &quot;age&quot;: self.age, &quot;gender&quot;: self.gender&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>2.编辑views</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调用所有的网页页面  例如：foo&#x2F;html&#x2F;index.html&#x2F;</span><br><span class="line"></span><br><span class="line">def index(request, file):</span><br><span class="line">	return render(request, file)</span><br></pre></td></tr></table></figure>

<p>3.前端网页 jquery 接收request中的数据进行处理并显示在前端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head头里 index.html 编写用户信息展示表单：</span><br><span class="line">	1.导入jquery:</span><br><span class="line">		&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">	2.使用：</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        $(document).ready(function() &#123;</span><br><span class="line">            $.get(&quot;&#x2F;foo&#x2F;api&#x2F;user&#x2F;&quot;,</span><br><span class="line">                function (users) &#123;</span><br><span class="line">                    users.forEach(function (user) &#123;</span><br><span class="line">                        &#x2F;&#x2F; $(&#39;#id_users&#39;).append(user.user);</span><br><span class="line">                        &#x2F;&#x2F; $(&#39;#id_users&#39;).append(user.age);</span><br><span class="line">                       $(&quot;#id_users&quot;).append(&quot;&lt;tr&gt;&lt;td&gt;&quot;+user.username+&quot;&lt;&#x2F;td&gt;&lt;td&gt;&quot; + </span><br><span class="line">                       user.age + &quot;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&quot;)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">    页面...</span><br><span class="line">    &lt;tbody id &#x3D; &quot;id_users&quot;&gt;</span><br><span class="line">    	上面设置的后端处理内容将显示在这里</span><br><span class="line">    &lt;&#x2F;tbody&gt;</span><br><span class="line"></span><br><span class="line">4.urls创建：如api 1步骤</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="api"><a href="#api" class="headerlink" title="api"></a>api</h4><p>1.urls（该app下）设置api</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app下创建urls.py</span><br><span class="line">from django.urls import path</span><br><span class="line">from foo import views</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">	path(&#39;html&#x2F;&lt;str:file&gt;&#39;, views.index)</span><br><span class="line">	path(&#39;api&#x2F;user&#x2F;&#39;, views.get_user)</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">根urls:</span><br><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path</span><br><span class="line">from django.conf.urls import url</span><br><span class="line">from django.urls import path, include</span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    path(&#39;admin&#x2F;&#39;, admin.site.urls),</span><br><span class="line">    path(&#39;foo&#x2F;&#39;, include(&#39;foo.urls&#39;)),</span><br><span class="line">    url(r&#39;^api-auth&#x2F;&#39;, include(&#39;rest_framework.urls&#39;))</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.使用api 实现前后端分离</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前端调用展示相关数据：</span><br><span class="line"></span><br><span class="line">1 html(user.html) 编写用户输入表单:</span><br><span class="line">&lt;form method&#x3D;&#39;post&#39;, action&#x3D;&#39;&#x2F;foo&#x2F;api&#x2F;user&#x2F;&#39;&gt;</span><br><span class="line">	username:&lt;input placeholder&#x3D;&quot;username&quot;, name&#x3D;&quot;username&quot;&gt;....  #添加name以此为POST数据的名称</span><br><span class="line">	&lt;&#x2F;form&gt;</span><br><span class="line">	</span><br><span class="line">2 views:</span><br><span class="line">	只推送数据到前端展示：地址：foo&#x2F;api&#x2F;user&#x2F;</span><br><span class="line">		def get_user(request):</span><br><span class="line">				users &#x3D; UserModer.object.all()</span><br><span class="line">				user_info &#x3D; [u.to_json() for u in users]</span><br><span class="line">				return JsonResponse(user_info, safe&#x3D;False)</span><br><span class="line">	POST则获取前端user.html的表单数据并保存(foo&#x2F;html&#x2F;user.html)&#x2F;否则返回数据到前端(foo&#x2F;api&#x2F;user&#x2F;)</span><br><span class="line">		@csrf_exempt</span><br><span class="line">		def do_user(request):</span><br><span class="line">			if request.method &#x3D;&#x3D; &quot;POST&quot;:</span><br><span class="line">				user &#x3D; UserModel() #取出Model中的字段</span><br><span class="line">				user.username &#x3D; request.POST[&#39;username&#39;]  #赋值给相应字段</span><br><span class="line">				...</span><br><span class="line">				user.save()   #保存到数据库</span><br><span class="line">				return JsonResponse(user.to_json())  #将数据发送给前端  地址：foo&#x2F;api&#x2F;user&#x2F;</span><br><span class="line">			else: 推送数据到前端</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3 urls(当前app中):</span><br><span class="line">	path(&#39;api&#x2F;user&#x2F;&#39;, views.do_user)  #2推送的消息返回前端的地址规则</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="serializers-序列化器"><a href="#serializers-序列化器" class="headerlink" title="serializers 序列化器"></a>serializers 序列化器</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 序列化,序列化器会把模型对象转换成字典,经过response以后变成json字符串</span><br><span class="line">2. 反序列化,把客户端发送过来的数据,经过request以后变成字典,序列化器可以把字典转成模型</span><br><span class="line">3. 反序列化,完成数据校验功能</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="常用字段类型"><a href="#常用字段类型" class="headerlink" title="常用字段类型"></a>常用字段类型</h4><table>
<thead>
<tr>
<th align="center">字  段  名  称</th>
<th align="center">字段构造方式 serializers.字段构造方式()</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BooleanField</td>
<td align="center">BooleanField()</td>
</tr>
<tr>
<td align="center">NullBooleanField</td>
<td align="center">NullBooleanField()</td>
</tr>
<tr>
<td align="center">CharField</td>
<td align="center">CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)</td>
</tr>
<tr>
<td align="center">EmailField</td>
<td align="center">EmailField(max_length=None, min_length=None, allow_blank=False)</td>
</tr>
<tr>
<td align="center">RegexField</td>
<td align="center">RegexField(regex, max_length=None, min_length=None, allow_blank=False)</td>
</tr>
<tr>
<td align="center">SlugField</td>
<td align="center">SlugField(max<em>length=50, min_length=None, allow_blank=False) 正则字段，验证正则模式 [a-zA-Z0-9</em>-]+</td>
</tr>
<tr>
<td align="center">URLField</td>
<td align="center">URLField(max_length=200, min_length=None, allow_blank=False)</td>
</tr>
<tr>
<td align="center">UUIDField</td>
<td align="center">UUIDField(format=’hex_verbose’) format:1) ‘hex_verbose’ 如”5ce0e9a5-5ffa-654b-cee0-1238041fb31a”2) ‘hex’ 如 “5ce0e9a55ffa654bcee01238041fb31a”3) ‘int’ - 如: “123456789012312313134124512351145145114”4) ‘urn’ 如: “urn:uuid:5ce0e9a5-5ffa-654b-cee0-1238041fb31a”</td>
</tr>
<tr>
<td align="center">IPAddressField</td>
<td align="center">IPAddressField(protocol=’both’, unpack_ipv4=False, **options)</td>
</tr>
<tr>
<td align="center">IntegerField</td>
<td align="center">IntegerField(max_value=None, min_value=None)</td>
</tr>
<tr>
<td align="center">FloatField</td>
<td align="center">FloatField(max_value=None, min_value=None)</td>
</tr>
<tr>
<td align="center">DecimalField</td>
<td align="center">DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)max_digits: 最多位数 decimal_palces: 小数点位置</td>
</tr>
<tr>
<td align="center">DateTimeField</td>
<td align="center">DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None)</td>
</tr>
<tr>
<td align="center">DateField</td>
<td align="center">DateField(format=api_settings.DATE_FORMAT, input_formats=None)</td>
</tr>
<tr>
<td align="center">TimeField</td>
<td align="center">TimeField(format=api_settings.TIME_FORMAT, input_formats=None)</td>
</tr>
<tr>
<td align="center">DurationField</td>
<td align="center">DurationField()</td>
</tr>
<tr>
<td align="center">ChoiceField</td>
<td align="center">ChoiceField(choices) choices与Django的用法相同</td>
</tr>
<tr>
<td align="center">MultipleChoiceField</td>
<td align="center">MultipleChoiceField(choices)</td>
</tr>
<tr>
<td align="center">FileField</td>
<td align="center">FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)</td>
</tr>
<tr>
<td align="center">ImageField</td>
<td align="center">ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)</td>
</tr>
<tr>
<td align="center">ListField</td>
<td align="center">ListField(child=, min_length=None, max_length=None)</td>
</tr>
<tr>
<td align="center">DictField</td>
<td align="center">DictField(child=)</td>
</tr>
</tbody></table>
<h4 id="选项参数"><a href="#选项参数" class="headerlink" title="选项参数"></a>选项参数</h4><table>
<thead>
<tr>
<th align="center">参数名称</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">max_length</td>
<td align="center">最大长度</td>
</tr>
<tr>
<td align="center">min_length</td>
<td align="center">最小长度</td>
</tr>
<tr>
<td align="center">allow_blank</td>
<td align="center">是否允许为空</td>
</tr>
<tr>
<td align="center">trim_whitespace</td>
<td align="center">是否截断空白字符</td>
</tr>
<tr>
<td align="center">max_value</td>
<td align="center">最大数值</td>
</tr>
<tr>
<td align="center">min_value</td>
<td align="center">最小数值</td>
</tr>
</tbody></table>
<h4 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h4><table>
<thead>
<tr>
<th align="center">参数名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">read_only</td>
<td align="center">表明该字段仅用于序列化输出，默认False</td>
</tr>
<tr>
<td align="center">write_only</td>
<td align="center">表明该字段仅用于反序列化输入，默认False</td>
</tr>
<tr>
<td align="center">required</td>
<td align="center">表明该字段在反序列化时必须输入，默认True</td>
</tr>
<tr>
<td align="center">default</td>
<td align="center">反序列化时使用的默认值</td>
</tr>
<tr>
<td align="center">allow_null</td>
<td align="center">表明该字段是否允许传入None，默认False</td>
</tr>
<tr>
<td align="center">validators</td>
<td align="center">该字段使用的验证器</td>
</tr>
<tr>
<td align="center">error_messages</td>
<td align="center">包含错误编号与错误信息的字典</td>
</tr>
<tr>
<td align="center">label</td>
<td align="center">用于HTML展示API页面时，显示的字段名称</td>
</tr>
<tr>
<td align="center">help_text</td>
<td align="center">用于HTML展示API页面时，显示的字段帮助提示信息</td>
</tr>
</tbody></table>
<h4 id="创建序列化类（用户为例）"><a href="#创建序列化类（用户为例）" class="headerlink" title="创建序列化类（用户为例）"></a>创建序列化类（用户为例）</h4><p>1.新建文件并导入序列化器 serializers.py  (当前app下)   用于序列化与反序列化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## serializers.py</span><br><span class="line">from rest_framework import serializers</span><br><span class="line"></span><br><span class="line">class UserSerializer(serializers.Serializer):</span><br><span class="line">	username &#x3D; serializers.CharFiled(requird &#x3D; True, max_length&#x3D;50)</span><br><span class="line">	...  #需要进行数据转换的字段设,并修改字段相应类型</span><br><span class="line">	def create(self, validated_data):  #重写create方法 </span><br><span class="line">		model &#x3D; UserModel()</span><br><span class="line">		model.username &#x3D; validated_data[&#39;username&#39;]</span><br><span class="line">		...</span><br><span class="line">		model.save()</span><br><span class="line">		return model </span><br><span class="line">		</span><br><span class="line">model ：指明该序列化器处理的数据字段从模型类Student参考生成</span><br><span class="line">fields ：指明该序列化器包含模型类中的哪些字段，__all__指明包含所有字段   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.views：获取前端表单数据并返回数据给前端 创建serializer对象</p>
<p>定义好Serializer类后，就可以创建Serializer对象了。</p>
<p>Serializer的构造方法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Serializer(instance&#x3D;None, data&#x3D;empty, **kwarg)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>1）用于序列化时，将模型类对象传入instance参数</p>
<p>2）用于反序列化时，将要被反序列化的数据传入data参数</p>
<p>3）除了instance和data参数外，在构造Serializer对象时，还可通过context参数额外添加数据，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">serializer &#x3D; StudentSerializer(instance, context&#x3D;&#123;&#39;request&#39;: request&#125;)</span><br></pre></td></tr></table></figure>
<p>通过context参数附加的数据，可以通过Serializer对象的context属性获取。</p>
<pre><code>1.使用序列化器的时候一定要注意，序列化器声明了以后，不会自动执行，需要我们在视图中进行调用才可以。
2.序列化器无法直接接收数据，需要我们在视图中创建序列化器对象时把使用的数据传递过来。
3.序列化器的字段声明类似于form表单系统。
4.开发restful api时，序列化器会帮我们把模型数据转换成字典.
5.drf提供的视图会帮我们把字典转换成json,或者把客户端发送过来的数据转换字典.
</code></pre>
<p>序列化器的使用分两个阶段：</p>
<p>1.在客户端请求时，使用序列化器可以完成对数据的反序列化。</p>
<p>2.在服务器响应时，使用序列化器可以完成对数据的序列化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def do_user(request):</span><br><span class="line">	if request.method &#x3D;&#x3D; &quot;POST&quot;:  #foo&#x2F;api&#x2F;user&#x2F;1   </span><br><span class="line">		serializer &#x3D; UserSerializer(data&#x3D;request.POST)   </span><br><span class="line">			#包括：serializer的__init__中有instance,data，many等字段，</span><br><span class="line">		if not serializer.is_valid():  </span><br><span class="line">			return JsonResponse(serializer.errors)</span><br><span class="line">		serializer.save(force_insert&#x3D;True)</span><br><span class="line">		return JsonResponse(serializer.validated_data)  </span><br><span class="line">		</span><br><span class="line">		#serializer中会将data中的数据赋值给validated_data</span><br><span class="line">		</span><br><span class="line">	else:</span><br><span class="line">			users &#x3D; UserModer.object.all()</span><br><span class="line">			user_info &#x3D; [u.to_json() for u in users]</span><br><span class="line">			return JsonResponse(user_info, safe&#x3D;False)</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.app_name/urls.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path(&#39;api&#x2F;user&#x2F;&lt;int:id&gt;&#39;, views.do_user) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.serializers 序列化/反序列化</p>
<p>说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用序列化器进行反序列化时，需要对数据进行验证后，才能获取验证成功的数据或保存成模型类对象。</span><br><span class="line"></span><br><span class="line">在获取反序列化的数据前，必须调用is_valid()方法进行验证，验证成功返回True，否则返回False。</span><br><span class="line"></span><br><span class="line">验证失败，可以通过序列化器对象的errors属性获取错误信息，返回字典，包含了字段和字段的错误。</span><br><span class="line">如果是非字段错误，可以通过修改REST framework配置中的NON_FIELD_ERRORS_KEY来控制错误字典中的键名。</span><br><span class="line"></span><br><span class="line">验证成功，可以通过序列化器对象的validated_data属性获取数据。</span><br><span class="line"></span><br><span class="line">在定义序列化器时，指明每个字段的序列化类型和选项参数，本身就是一种验证行为。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## serializers.py</span><br><span class="line">class UserSerializer2(serializers.ModelSerializer): #需申明调用模型信息</span><br><span class="line">	class Meta:</span><br><span class="line">		model &#x3D; UserModel  #model添加上to_json  直接继承Model的字段</span><br><span class="line">		exclude &#x3D; (&#39;gender&#39;,)  #不在前端展示的字段</span><br><span class="line">	</span><br><span class="line">## views.py</span><br><span class="line">def do_user(request, id&#x3D;None):</span><br><span class="line">	if not id:</span><br><span class="line">		if request.method &#x3D;&#x3D; &quot;POST&quot;:  #根据前端输入的资源进行保存数据库中并返回给前端  </span><br><span class="line">			serializer &#x3D; UserSerializer(data&#x3D;request.POST)  #数据转换（反序列化） </span><br><span class="line">			if not serializer.is_valid():  </span><br><span class="line">				return JsonResponse(serializer.errors)  #响应错误</span><br><span class="line">			serializer.save(force_insert&#x3D;True)  #存储数据</span><br><span class="line">			return JsonResponse(serializer.validated_data)  #响应数据</span><br><span class="line">		else:  #被序列化的是包含多条数据的查询集QuerySet，可通过many&#x3D;True参数补充说明 </span><br><span class="line">				users &#x3D; UserModer.object.all() #获取数据</span><br><span class="line">				#不需要在model中定义to_json传资源</span><br><span class="line">				user_info &#x3D; UserSerializer2(instance&#x3D;users, many&#x3D;True) #转化多个数据，需要加上many&#x3D;True</span><br><span class="line">				#user_info.data ：序列化器转化后的数据（字典） </span><br><span class="line">				return JsonResponse(user_info.data, safe&#x3D;False)</span><br><span class="line">				#响应数据给客户端</span><br><span class="line">				#返回的Json数据，如果是列表，需要声明safe&#x3D;False</span><br><span class="line">	else:  </span><br><span class="line">		if request.method &#x3D;&#x3D; &quot;GET&quot;：  </span><br><span class="line">			user &#x3D; UserModel.object.get(pk &#x3D; id)  #获取数据</span><br><span class="line">			user_info &#x3D; UserSerializer2(instance&#x3D;user) #数据转换（序列化）</span><br><span class="line">			return JsonResponse(user_info.data)   #响应数据</span><br></pre></td></tr></table></figure>

<h3 id="ModelSerializer"><a href="#ModelSerializer" class="headerlink" title="ModelSerializer"></a>ModelSerializer</h3><p>如果我们想要使用序列化器对应的是Django的模型类，DRF为我们提供了ModelSerializer模型类序列化器来帮助我们快速创建一个Serializer类。</p>
<p>ModelSerializer与常规的Serializer相同，但提供了：</p>
<pre><code>基于模型类自动生成一系列字段
基于模型类自动为Serializer生成validators，比如unique_together
包含默认的create()和update()的实现
</code></pre>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BookSerializer(serializers.ModelSerializer):</span><br><span class="line">    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; Book</span><br><span class="line">        fields &#x3D; &#39;__all__&#39;</span><br><span class="line"></span><br><span class="line">model 指明参照哪个模型类</span><br><span class="line">fields 指明为模型类的哪些字段生成</span><br><span class="line"></span><br><span class="line">我们可以在python manage.py shell中查看自动生成的BookSerializer的具体实现</span><br><span class="line">&gt;&gt;&gt; from booktest.serializers import BookSerializer</span><br><span class="line">&gt;&gt;&gt; serializer &#x3D; BookSerializer()</span><br><span class="line">&gt;&gt;&gt; serializer</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="指定字段"><a href="#指定字段" class="headerlink" title="指定字段"></a>指定字段</h4><ol>
<li><p>使用fields来明确字段，__all__表名包含所有字段，也可以写明具体哪些字段</p>
</li>
<li><p>使用exclude可以明确排除掉哪些字段</p>
</li>
<li><p>fields 指明为模型类的哪些字段生成</p>
</li>
<li><p>指明只读字段  可以通过read_only_fields指明只读字段，即仅用于序列化输出的字段</p>
</li>
</ol>
<h4 id="添加额外参数"><a href="#添加额外参数" class="headerlink" title="添加额外参数"></a>添加额外参数</h4><p>我们可以使用extra_kwargs参数为ModelSerializer添加或修改原有的选项参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BookSerializer(serializers.ModelSerializer):</span><br><span class="line">    &quot;&quot;&quot;图书序列化器&quot;&quot;&quot;</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; Book</span><br><span class="line">        fields &#x3D; (&#39;id&#39;, &#39;title&#39;, &#39;pub_date&#39;, &#39;read&#39;, &#39;comment&#39;)</span><br><span class="line">        extra_kwargs &#x3D; &#123;</span><br><span class="line">            &#39;read&#39;: &#123;&#39;min_value&#39;: 0, &#39;required&#39;: True&#125;,</span><br><span class="line">            &#39;comment&#39;: &#123;&#39;min_value&#39;: 0, &#39;required&#39;: True&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="序列化过程（lesson为例）"><a href="#序列化过程（lesson为例）" class="headerlink" title="序列化过程（lesson为例）"></a>序列化过程（lesson为例）</h3><h4 id="Model创建"><a href="#Model创建" class="headerlink" title="Model创建"></a>Model创建</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#models.py</span><br><span class="line">class LessonModel(models.Model):</span><br><span class="line">    subject &#x3D; models.CharField(max_length&#x3D;255)</span><br><span class="line">    student &#x3D; models.ForeignKey(&#39;UserModer&#39;, on_delete&#x3D;models.CASCADE)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="序列化类"><a href="#序列化类" class="headerlink" title="序列化类"></a>序列化类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#serializer.py</span><br><span class="line">class LessonSerializer(serializers.ModelSerializer):</span><br><span class="line">	#序列化调用上面学生信息（对student字段进行处理后返回）</span><br><span class="line">	student &#x3D; serializer.SerializerMethodField()</span><br><span class="line">	</span><br><span class="line">	def get_student(self, instance):</span><br><span class="line">		#instance.student 为获取数据</span><br><span class="line">		u &#x3D; UserSerializer2(instance&#x3D;instance.student) #数据转化</span><br><span class="line">		return u.data #返回转化数据  使得该序列化可以转化学生信息数据并一起发给前端</span><br><span class="line">	</span><br><span class="line">	#定义任意需要的字段</span><br><span class="line">	count &#x3D; serializer.SerializerMethodField()</span><br><span class="line">	</span><br><span class="line">	def get_count(self, instance):</span><br><span class="line">		return 12</span><br><span class="line">		</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; LessonModel  #声明model  (instance中包括的字段)</span><br><span class="line">        fields &#x3D; (&quot;subject&quot;, &quot;student&quot;, &#39;count&#39;)  #指明序列化model中的字段与exclude相反</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="转化为序列化对象"><a href="#转化为序列化对象" class="headerlink" title="转化为序列化对象"></a>转化为序列化对象</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#views.py</span><br><span class="line">def do_lesson(request, id&#x3D;None):</span><br><span class="line">	if not id:</span><br><span class="line">		lesson &#x3D; LessonModel.object.all() #获取数据</span><br><span class="line">		json_lesson &#x3D; LessonSerializer(instance&#x3D;lesson, many&#x3D;True)  #数据转化（序列化）</span><br><span class="line">		return JsonResponse(json_lesson.data, safe&#x3D;False)  </span><br><span class="line">		#响应数据(subject,student,count的所有序列化返回的数据)</span><br></pre></td></tr></table></figure>

<h3 id="反序列化过程"><a href="#反序列化过程" class="headerlink" title="反序列化过程"></a>反序列化过程</h3><h4 id="数据验证-以图书为例"><a href="#数据验证-以图书为例" class="headerlink" title="数据验证(以图书为例)"></a>数据验证(以图书为例)</h4><p>使用序列化器进行反序列化时，需要对数据进行验证后，才能获取验证成功的数据或保存成模型类对象。</p>
<p>在获取反序列化的数据前，必须调用is_valid()方法进行验证，验证成功返回True，否则返回False。</p>
<p>验证失败，可以通过序列化器对象的errors属性获取错误信息，返回字典，包含了字段和字段的错误。如果是非字段错误，可以通过修改REST framework配置中的NON_FIELD_ERRORS_KEY来控制错误字典中的键名。</p>
<p>验证成功，可以通过序列化器对象的validated_data属性获取数据。</p>
<p>在定义序列化器时，指明每个字段的序列化类型和选项参数，本身就是一种验证行为。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新建一个子应用books。</span><br><span class="line"></span><br><span class="line">data &#x3D; &#123;&#39;title&#39;: &#39;python&#39;&#125;  #传入的数据</span><br><span class="line">serializer &#x3D; BookSerializer(data&#x3D;data)  #序列化</span><br><span class="line">serializer.is_valid()  # True   验证结果返回值 （字段的限制若不满足直接False）</span><br><span class="line">serializer.errors  # &#123;&#125;  错误信息</span><br><span class="line">serializer.validated_data  #  OrderedDict([(&#39;btitle&#39;, &#39;python&#39;)])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>is_valid()方法还可以在验证失败时抛出异常serializers.ValidationError，
可以通过传递raise_exception=True参数开启，REST framework接收到此异常，
会向前端返回HTTP 400 Bad Request响应。
</code></pre>
<h4 id="补充定义验证行为"><a href="#补充定义验证行为" class="headerlink" title="补充定义验证行为"></a>补充定义验证行为</h4><p>1）validate_字段名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BookSerializer(serializers.Serializer):</span><br><span class="line">    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span><br><span class="line">    ...</span><br><span class="line">    def validate_title(self, value):</span><br><span class="line">        if &#39;django&#39; not in value.lower():</span><br><span class="line">            raise serializers.ValidationError(&quot;图书不是关于Django的&quot;)</span><br><span class="line">        return value</span><br><span class="line"></span><br><span class="line">验证：</span><br><span class="line">from book.serializers import BookSerializer</span><br><span class="line">data &#x3D; &#123;&#39;title&#39;: &#39;python&#39;&#125;</span><br><span class="line">serializer &#x3D; BookSerializer(data&#x3D;data)</span><br><span class="line">serializer.is_valid()  # False   </span><br><span class="line">serializer.errors</span><br><span class="line">#  &#123;&#39;title&#39;: [ErrorDetail(string&#x3D;&#39;图书不是关于Django的&#39;, code&#x3D;&#39;invalid&#39;)]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>多个字段进行验证 定义validate方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BookSerializer(serializers.Serializer):</span><br><span class="line">    &quot;&quot;&quot;图书序列化器&quot;&quot;&quot;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def validate(self, attrs):</span><br><span class="line">        read &#x3D; attrs[&#39;read&#39;]</span><br><span class="line">        comment &#x3D; attrs[&#39;comment&#39;]</span><br><span class="line">        if read &lt; comment:</span><br><span class="line">            raise serializers.ValidationError(&#39;阅读量小于评论量，不可以通过&#39;)</span><br><span class="line">        return attrs</span><br><span class="line">        </span><br><span class="line">   </span><br><span class="line">from book.serializers import BookSerializer</span><br><span class="line">data &#x3D; &#123;&#39;title&#39;: &#39;about django&#39;, &#39;read&#39;: 10, &#39;comment&#39;: 20&#125;</span><br><span class="line">s &#x3D; BookSerializer(data&#x3D;data)</span><br><span class="line">s.is_valid()  # False</span><br><span class="line">s.errors</span><br><span class="line">#  &#123;&#39;non_field_errors&#39;: [ErrorDetail(string&#x3D;&#39;阅读量小于评论量&#39;, code&#x3D;&#39;invalid&#39;)]&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>validators  字段中添加该补充验证行为选项参数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def about_django(value):</span><br><span class="line">    if &#39;django&#39; not in value.lower():</span><br><span class="line">        raise serializers.ValidationError(&quot;图书不是关于Django的&quot;)</span><br><span class="line"></span><br><span class="line">class BookSerializer(serializers.Serializer):</span><br><span class="line">    &quot;&quot;&quot;图书序列化器&quot;&quot;&quot;</span><br><span class="line">    id &#x3D; serializers.IntegerField(label&#x3D;&#39;ID&#39;, read_only&#x3D;True)</span><br><span class="line">     #验证字段title</span><br><span class="line">    title &#x3D; serializers.CharField(label&#x3D;&#39;名称&#39;, max_length&#x3D;20, validators&#x3D;[about_django])    	 pub_date &#x3D; serializers.DateField(label&#x3D;&#39;发布日期&#39;, required&#x3D;False)</span><br><span class="line">    read &#x3D; serializers.IntegerField(label&#x3D;&#39;阅读量&#39;, required&#x3D;False)</span><br><span class="line">    comment &#x3D; serializers.IntegerField(label&#x3D;&#39;评论量&#39;, required&#x3D;False)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">from book.serializers import BookSerializer</span><br><span class="line">data &#x3D; &#123;&#39;title&#39;: &#39;python&#39;&#125;</span><br><span class="line">serializer &#x3D; BookSerializer(data&#x3D;data)</span><br><span class="line">serializer.is_valid()  # False   </span><br><span class="line">serializer.errors</span><br><span class="line">#  &#123;&#39;title&#39;: [ErrorDetail(string&#x3D;&#39;图书不是关于Django的&#39;, code&#x3D;&#39;invalid&#39;)]&#125;</span><br></pre></td></tr></table></figure>

<h4 id="保存-更新数据"><a href="#保存-更新数据" class="headerlink" title="保存/更新数据"></a>保存/更新数据</h4><h5 id="以密码保存和更新为例"><a href="#以密码保存和更新为例" class="headerlink" title="以密码保存和更新为例"></a>以密码保存和更新为例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Model.py</span><br><span class="line">class UserModel(models.Model):</span><br><span class="line">	password &#x3D; models.CharField(max_length&#x3D;255, null&#x3D;True)</span><br><span class="line">   salt &#x3D; models.CharField(max_length&#x3D;255, default&#x3D;&#39;123456&#39;)</span><br><span class="line"></span><br><span class="line">#serializers.py 序列化</span><br><span class="line"></span><br><span class="line">如果创建序列化器对象的时候，没有传递instance实例，则调用save()方法的时候，create()被调用，相反，</span><br><span class="line">如果传递了instance实例，则调用save()方法的时候，update()被调用</span><br><span class="line"></span><br><span class="line">class UserSerializer2(serializers.ModelSerializer):</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; UserModer</span><br><span class="line">        exclude &#x3D; (&#39;password&#39;, ）</span><br><span class="line">	#创建密码  validated_data是反序列化验证成功后获得的数据</span><br><span class="line">    def create(self, validated_data):</span><br><span class="line">        model &#x3D; super().create(validated_data)</span><br><span class="line">        model.salt &#x3D; uuid.uuid4().hex</span><br><span class="line">        password &#x3D; &#39;12345&#39; + model.salt</span><br><span class="line">        import hashlib</span><br><span class="line">        md5 &#x3D; hashlib.md5()</span><br><span class="line">        md5.update(password.encode(&#39;utf-8&#39;))</span><br><span class="line">        model.password &#x3D; md5.hexdigest()</span><br><span class="line">        model.save()</span><br><span class="line">        return model</span><br><span class="line">	# 更新密码</span><br><span class="line">    def update(self, instance, validated_data):</span><br><span class="line">        model &#x3D; super().update(instance, validated_data)</span><br><span class="line">        if &quot;password&quot; in validated_data:</span><br><span class="line">            password &#x3D; validated_data[&#39;password&#39;] + model.salt</span><br><span class="line">            import hashlib</span><br><span class="line">            md5 &#x3D; hashlib.md5()</span><br><span class="line">            md5.update(password.encode(&#39;utf-8&#39;))</span><br><span class="line">            model.password &#x3D; md5.hexdigest()</span><br><span class="line">            model.save()</span><br><span class="line">        	  return model</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="api-view-基于方法的视图"><a href="#api-view-基于方法的视图" class="headerlink" title="api_view(基于方法的视图)"></a>api_view(基于方法的视图)</h3><p>api_view 是一个装饰器，用 http_method_names 来设置视图允许响应的 HTTP 方法列表，举个例子，</p>
<p>编写一个简单的视图，手动返回一些数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@api_view([&#39;GET&#39;, &#39;POST&#39;])  #如果未制定 默认是GET 其它以“405 Method Not Allowed ”进行响应</span><br><span class="line">def hello_world(request):</span><br><span class="line">    if request.method &#x3D;&#x3D; &#39;POST&#39;:</span><br><span class="line">        return Response(&#123;&quot;message&quot;: &quot;Got some data!&quot;, &quot;data&quot;: request.data&#125;)</span><br><span class="line">    return Response(&#123;&quot;message&quot;: &quot;Hello, world!&quot;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="api-view装饰器"><a href="#api-view装饰器" class="headerlink" title="api_view装饰器"></a>api_view装饰器</h4><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># views.py</span><br><span class="line"></span><br><span class="line">@api_view(&quot;GET&quot;, &quot;POST&quot; ) </span><br><span class="line">def do_user(request, id&#x3D;None): #可指定format:json(前端显示方式为json)</span><br><span class="line">	assert isinstance(request, Request)</span><br><span class="line">	# request.query_params &#x3D;&#x3D; request.GET  urls中的数据</span><br><span class="line">	# request.data &#x3D;&#x3D; request.POST   报文中的数据</span><br><span class="line">	if not id:</span><br><span class="line">		if request.method &#x3D;&#x3D; &quot;POST&quot;:   </span><br><span class="line">			serializer &#x3D; UserSerializer(data&#x3D;request.POST)   </span><br><span class="line">			if not serializer.is_valid():  #序列化验证 </span><br><span class="line">				return JsonResponse(serializer.errors)  </span><br><span class="line">			serializer.save(force_insert&#x3D;True) #保存 </span><br><span class="line">			#return JsonResponse(serializer.validated_data)</span><br><span class="line">			#使用rest_framework 的Response </span><br><span class="line">			return Response(serializer.validated_data)  #响应数据  </span><br><span class="line"> </span><br><span class="line"># app&#x2F;urls</span><br><span class="line">path(&#39;api&#x2F;user&#39;, views.do_user, &#123;&#39;format&#39;:&#39;json&#39;&#125;) #上述指定format后需要制定</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="类视图-APIView例"><a href="#类视图-APIView例" class="headerlink" title="类视图(APIView例)"></a>类视图(APIView例)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#views.py</span><br><span class="line"></span><br><span class="line">class UserView(APIView):</span><br><span class="line">    def get(self, request, id&#x3D;None, *args, **kwargs):</span><br><span class="line">    # request.query_params &#x3D;&#x3D; request.GET  urls中的数据</span><br><span class="line">	 # request.data &#x3D;&#x3D; request.POST   报文中的数据</span><br><span class="line">        if id:</span><br><span class="line">            user &#x3D; UserModer.objects.get(pk&#x3D;id)</span><br><span class="line">            user_info &#x3D; UserSerializer2(instance&#x3D;user)</span><br><span class="line">            return Response(user_info.data)</span><br><span class="line">        else:</span><br><span class="line">            users &#x3D; UserModer.objects.all()</span><br><span class="line">            users_info &#x3D; UserSerializer2(instance&#x3D;users, many&#x3D;True)</span><br><span class="line">            return Response(users_info.data)</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        serializer &#x3D; UserSerializer2(data&#x3D;request.data)</span><br><span class="line">        if not serializer.is_valid():</span><br><span class="line">            return JsonResponse(serializer.errors)</span><br><span class="line">        serializer.save()</span><br><span class="line">        return Response(serializer.validated_data)</span><br><span class="line">    def put(self, request, id&#x3D;None, *args, **kwargs):</span><br><span class="line">    	  if id:</span><br><span class="line">    	  		model &#x3D; UserModel.object.get(pk&#x3D;id)</span><br><span class="line">    	  else:</span><br><span class="line">    	  		model &#x3D; UserModel.object.get(pk&#x3D;request.data[&#39;id&#39;])</span><br><span class="line">    	  serializer &#x3D; UserSerializer2(data&#x3D;request.data)</span><br><span class="line">    	  if not serializer.is_valid():</span><br><span class="line">    	  	  print(serializer.errors)</span><br><span class="line">            return Response(status&#x3D;401)</span><br><span class="line">        serializer.save()</span><br><span class="line">        return Response(serializer.data)</span><br><span class="line">    	  </span><br><span class="line"></span><br><span class="line"># app&#x2F;urls.py</span><br><span class="line"></span><br><span class="line">path(&#39;api&#x2F;user&#x2F;&#39;, views.UserView.as_view())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UserView(mixins.ListModelMixin,</span><br><span class="line">               mixins.CreateModelMixin,</span><br><span class="line">               mixins.RetrieveModelMixin,</span><br><span class="line">               mixins.UpdateModelMixin,</span><br><span class="line">               mixins.DestroyModelMixin,</span><br><span class="line">               generics.GenericAPIView):</span><br><span class="line"></span><br><span class="line">    queryset &#x3D; UserModer.objects.all()</span><br><span class="line">    serializer_class &#x3D; UserSerializer2</span><br><span class="line"></span><br><span class="line">    def get(self, request, pk&#x3D;None, *args, **kwargs):</span><br><span class="line">        if not pk:</span><br><span class="line">            return self.list(request, *args, **kwargs)</span><br><span class="line">        else:</span><br><span class="line">            return self.retrieve(request, pk, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        return self.create(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def put(self, request, *args, **kwargs):</span><br><span class="line">        return self.update(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def delete(self, request, *args, **kwargs):</span><br><span class="line">        return self.destroy(request, *args, **kwargs)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h3 id="ModelViewSet"><a href="#ModelViewSet" class="headerlink" title="ModelViewSet"></a>ModelViewSet</h3><p>详细：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#views.py:</span><br><span class="line"></span><br><span class="line">class UserView(ModelViewSet):</span><br><span class="line">    queryset &#x3D; UserModer.objects.all()</span><br><span class="line">    serializer_class &#x3D; UserSerializer2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list_view &#x3D; UserView.as_view(&#123;</span><br><span class="line">        &quot;get&quot;: &quot;list&quot;,</span><br><span class="line">        &quot;post&quot;: &#39;create&#39;&#125;)</span><br><span class="line"></span><br><span class="line">detail_view &#x3D; UserView.as_view(</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;get&quot;: &quot;retrieve&quot;,</span><br><span class="line">        &quot;put&quot;: &quot;update&quot;,</span><br><span class="line">        &quot;delete&quot;: &quot;destroy&quot;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">    # path(&#39;api&#x2F;user&#x2F;&#39;, views.list_view),</span><br><span class="line">    # path(&#39;api&#x2F;user&#x2F;&lt;int:pk&gt;&#39;, views.detail_view),</span><br></pre></td></tr></table></figure>


<p>简化1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#views.py</span><br><span class="line"> class LessonView(ModelViewSet):</span><br><span class="line">     queryset &#x3D; LessonModel.objects.all()</span><br><span class="line">     serializer_class &#x3D; LessonSerializer</span><br><span class="line">     </span><br><span class="line">#app&#x2F;urls.py</span><br><span class="line">from rest_framework.routers import DefaultRouter</span><br><span class="line">router &#x3D; DefaultRouter()</span><br><span class="line">router.register(&#39;user&#39;, views.UserView)</span><br><span class="line">router.register(&#39;lesson&#39;, views.LessonView)</span><br><span class="line"></span><br><span class="line">path(&#39;api&#x2F;&#39;, include(router.urls)),</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>主要是对是否符合查看条件，符合则返回相关响应数据，否则返回权限不足</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework.permissions import IsAuthenticated, BasePermission</span><br><span class="line"></span><br><span class="line">class TokenPermissionClass(BasePermission): #验证方法重写</span><br><span class="line">    def has_object_permission(self, request, view, obj):</span><br><span class="line">        pass</span><br><span class="line">    def has_permission(self, request, view):</span><br><span class="line">        if isinstance(view, UserView):</span><br><span class="line">            return False</span><br><span class="line">        return True</span><br><span class="line">           </span><br><span class="line">class LessonView(ModelViewSet):</span><br><span class="line">    permission_classes &#x3D; [TokenPermissionClass]  #调用上面的验证方式</span><br><span class="line">    queryset &#x3D; LessonModel.objects.all()</span><br><span class="line">    serializer_class &#x3D; LessonSerializer</span><br></pre></td></tr></table></figure>


<p>自定义验证</p>
<p>1.新建验证文件 authentications.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#authentications.py</span><br><span class="line"></span><br><span class="line">from rest_framework.authentication import BaseAuthentication, BasicAuthentication</span><br><span class="line">from foo.models import UserModer</span><br><span class="line"></span><br><span class="line">class UserPasswordAuthentication(BaseAuthentication):</span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        user &#x3D; request.query_params.get(&#39;username&#39;)</span><br><span class="line">        password &#x3D; request.query_params.get(&#39;password&#39;)</span><br><span class="line">        try:</span><br><span class="line">            user &#x3D; UserModer.objects.get(username&#x3D;user)</span><br><span class="line">        except:</span><br><span class="line">            return None, None</span><br><span class="line">        new_password &#x3D; password + user.salt</span><br><span class="line">        import hashlib</span><br><span class="line">        md5 &#x3D; hashlib.md5()</span><br><span class="line">        md5.update(new_password.encode(&#39;utf-8&#39;))</span><br><span class="line">        if user.password &#x3D;&#x3D; md5.hexdigest():</span><br><span class="line">            return user, None</span><br><span class="line">        else:</span><br><span class="line">            return None, None</span><br><span class="line">            </span><br><span class="line">#views.py</span><br><span class="line"></span><br><span class="line">class UserView(ModelViewSet):  #若有权限即验证通过，则序列化</span><br><span class="line">    permission_classes &#x3D; [IsAuthenticated]</span><br><span class="line">    authentication_classes &#x3D; [UserPasswordAuthentication]</span><br><span class="line">    queryset &#x3D; UserModer.objects.all()</span><br><span class="line">    serializer_class &#x3D; UserSerializer2</span><br><span class="line"> </span><br><span class="line"> #models.py</span><br><span class="line"> class UserModer(models.Model):</span><br><span class="line"> 	...</span><br><span class="line"> 	</span><br><span class="line">   @property</span><br><span class="line">   def is_authenticated(self):  </span><br><span class="line">   #(IsAuthenticated中request.user和request.user.is_authenticated需要同时满足 这里重写其中一个)</span><br><span class="line">        return True</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#地址栏输入  字段名&#x3D;值 可以查询出该字段里所有符合的值的数据</span><br><span class="line">class UserView(ModelViewSet):  </span><br><span class="line">    queryset &#x3D; UserModer.objects.all()</span><br><span class="line">    serializer_class &#x3D; UserSerializer2</span><br><span class="line"></span><br><span class="line">    def list(self, request, *args, **kwargs):</span><br><span class="line">        for arg, value in request.query_params.items():</span><br><span class="line">            self.queryset &#x3D; self.queryset.filter(**&#123;arg: value&#125;)</span><br><span class="line"></span><br><span class="line">        return super(UserView, self).list(request, *args, **kwargs)</span><br></pre></td></tr></table></figure>

<h3 id="django-filters"><a href="#django-filters" class="headerlink" title="django-filters"></a>django-filters</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install django-filters</span><br><span class="line"></span><br><span class="line">import django_filters.rest_framework</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserView(ModelViewSet):</span><br><span class="line"></span><br><span class="line">    queryset &#x3D; UserModer.objects.all()</span><br><span class="line">    filter_backends &#x3D; [django_filters.rest_framework.DjangoFilterBackend, SearchFilter]</span><br><span class="line">    serializer_class &#x3D; UserSerializer2</span><br><span class="line">    filterset_fields &#x3D; [&#39;gender&#39;, &#39;salt&#39;]</span><br><span class="line"></span><br><span class="line">#http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;foo&#x2F;api&#x2F;user&#x2F;?gender&#x3D;1</span><br><span class="line"></span><br><span class="line">class LessonView(ModelViewSet):</span><br><span class="line">    queryset &#x3D; LessonModel.objects.all()</span><br><span class="line">    serializer_class &#x3D; LessonSerializer</span><br><span class="line">    filter_backends &#x3D; [SearchFilter]</span><br><span class="line">    search_fields &#x3D; [&#39;subject&#39;, &#39;student__username&#39;]</span><br><span class="line"></span><br><span class="line">#http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;foo&#x2F;api&#x2F;lesson&#x2F;?search&#x3D;a</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>python框架</category>
      </categories>
      <tags>
        <tag>Django序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>Django框架08--请求类型</title>
    <url>/jwangcloud/1334139912/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/Django.jpeg"></p>
<h3 id="get-put-post-delete含义与区别"><a href="#get-put-post-delete含义与区别" class="headerlink" title="get,put,post,delete含义与区别"></a>get,put,post,delete含义与区别</h3><span id="more"></span>
<h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><table>
<thead>
<tr>
<th>名称</th>
<th>url</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>POST</td>
<td>/uri</td>
<td>创建</td>
</tr>
<tr>
<td>DELETE</td>
<td>/uri/xxx</td>
<td>删除</td>
</tr>
<tr>
<td>PUT</td>
<td>/uri/xxx</td>
<td>更新或创建</td>
</tr>
<tr>
<td>GET</td>
<td>/uri/xxx</td>
<td>查看</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>1.GET操作是安全的。</p>
<pre><code>所谓安全是指不管进行多少次操作，资源的状态都不会改变。比如我用GET浏览文章，不管浏览多少次，那篇文章还在那，
没有变化。当然，你可能说每浏览一次文章，文章的浏览数就加一，这不也改变了资源的状态么？这并不矛盾，因为这个改变不是GET操作引
起的，而是用户自己设定的服务端逻辑造成的。
</code></pre>
<p>2.PUT，DELETE操作是幂等的。</p>
<pre><code>所谓幂等是指不管进行多少次操作，结果都一样。比如我用PUT修改一篇文章，然后在做同样的操作，每次操作后的结果并没有不同，
DELETE也是一样。顺便说一句，因为GET操作是安全的，所以它自然也是幂等的。
</code></pre>
<p>3.POST操作既不是安全的，也不是幂等。</p>
<pre><code>比如常见的POST重复加载问题：当我们多次发出同样的POST请求后，其结果是创建出了若干的资源。
</code></pre>
<p>4.安全和幂等的意义在于：</p>
<pre><code>    当操作没有达到预期的目标时，我们可以不停的重试，而不会对资源产生副作用。从这个意义上说，POST操作往往是有害的，但很多时
候我们还是不得不使用它。还有一点需要注意的就是，创建操作可以使用POST，也可以使用PUT，区别在于POST 是作用在一个集合资
源之上的（/uri），而PUT操作是作用在一个具体资源之上的（/uri/xxx），再通俗点说，如果URL可以在客户端确定，
    那么就使用PUT，如果是在服务端确定，那么就使用POST，比如说很多资源使用数据库自增主键作为标识信息，而创建的资源的标识信息
到底是什么只能由服务端提供，这个时候就必须使用POST。
</code></pre>
<h4 id="关于GET-POST-的混淆"><a href="#关于GET-POST-的混淆" class="headerlink" title="关于GET POST 的混淆"></a>关于GET POST 的混淆</h4><p>1.先说相同点，只有了解了相同点之后才能理解为什么会发生混淆。两者都能向服务器发送数据，提交的“内容”[注1]的格式相同，都是</p>
<pre><code>param1=value1&amp;param2=value2&amp;....  
</code></pre>
<p>get 和 post 区别如字面，一个是get（获取），一个是post（发送）。</p>
<pre><code>    get用来告诉服务器需要获取哪些内容（uri+query），向静态页面（uri）请求则直接返回文件内容给浏览器，向一个动态页面请求时
可以提供查询参数（query）以获得相应内容。

    post用来向服务器提交内容，主要是为了提交，而不是为了请求内容，就是说post的初衷并不要求服务器返回内容[注2]，只是提交内
容让服务器处理（主要是存储或者处理之后再存储）。
</code></pre>
<p>2.get和post出现混淆是因为对提交的数据处理方法的滥用造成的，数据是无辜的。</p>
<p>混淆之一：</p>
<pre><code>将get提交的用来查询的字段当作是存储数据存入了服务器端文件或者数据库。然后就误以为get是用来提交用于存储的数据的。
</code></pre>
<p>混淆之二：</p>
<pre><code>编写脚本在服务器端通过处理post提交的数据并返回内容。只要有数据，就能用来进行判断，脚本怎写是程序员的事，而不在乎数据来源的形
式（post、get，或者是自己预设值的常量）。这点功能上确实没问题，只是背离的其初始目的而已。
</code></pre>
<p>由于都是要传送数据，且数据格式相同（即使数据格式不同，只要能提取出相应数据）。使用的时候难免出现张冠李戴，将get数据用来存储、将post数据用来检索返回数据。</p>
<p>3.二者区别（用途而“人为”造成）：</p>
<pre><code>    get的长度限制在2048字节（由浏览器和服务器限制的，这是目前IE的数据，曾经是1024字节），很大程度上限制了get用来传递“存
储数据”的数据的能力，所以还是老老实实用来做检索吧；
    post则无此限制（只是HTTP协议规范没有进行大小限制，但受限于服务器的处理能力），因此对于大的数据（一般来说需要存储的数据
可能会比较大，比2048字节大）的传递有天然的优势，谁让它是 nature born post 呢。


    get提交的数据是放在url里，目的是灵活的向服务其提交检索请求，可以在地址栏随时修改数据以变更需要获取的内容，比如直接修改
分页的编号就跳到另外一个分页了（当然也可能是 404）。

    post提交的数据放在http请求的正文里，目的在于提交数据并用于服务器端的存储，而不允许用户过多的更改相应数据（主要是相对于
在url 修改要麻烦很多，url的修改只要点击地址栏输入字符就可以了），除非是专门跑来编辑数据的。

    post和get的安全性在传输的层面上区别不大，但是采用url提交数据的get方式容易被人肉眼看到，或者出现在历史纪录里，还是可能
被肉眼看到，都是一些本地的问题。
</code></pre>
<p>注：get方式主要是为了获得预期内容，即uri+query相同时所得到的内容应该是相同的。而post主要是提交内容，至于是否有必要返回页面可<br>能只是出于用户体验，比如注册时返回你的注册id，但是如果只是返回一个“您已注册成功”的相同页面（即使你post的数据不一样）也没什么好奇怪的。</p>
<h4 id="HTTP-POST-GET-本质区别"><a href="#HTTP-POST-GET-本质区别" class="headerlink" title="HTTP POST GET 本质区别"></a>HTTP POST GET 本质区别</h4><p>1.原理区别</p>
<pre><code>一般在浏览器中输入网址访问资源都是通过GET方式；在FORM提交中，可以通过Method指定提交方式为GET或者POST，默认为GET提交 
Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE URL 全称是资源描述符，我们可以这样认
为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查 ，改 ，增 ，删 4个
操作。到这里，大家应该有个大概的了解了，GET一般用于获取/查询 资源信息，而POST一般用于更新 资源信息(个人认为这是GET和POST
的本质区别，也是协议设计者的本意，其它区别都是具体表现形式的差异 )。 　　
</code></pre>
<p>2.根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的 。 　　</p>
<pre><code>1.所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数
据库查询一样，不会修改，增加数据，不会影响资源的状态。 
　　
* 注意：这里安全的含义仅仅是指是非修改信息。 　　

2.幂等的意味着对同一URL的多个请求应该返回同样的结果。这里我再解释一下幂等 这个概念： 　　

幂等 （idempotent、idempotence）是一个数学或计算机学概念，常见于抽象代数中。 　　

    幂等有以下几种定义：对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结
    果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有abs(a) = abs(abs(a)) 。 　　

    对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数
    的最大值的函数，有在在实数集中幂等，即max(x,x) = x 。 看完上述解释后，应该可以理解GET幂等的含义了。 　　

    但在实际应用中，以上2条规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同
    一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。从根本上说，如果目标是当用户打开一个链接时，他可以
    确信从自身的角度来看没有改变资源即可。 
    
     根据HTTP规范，POST表示可能修改变服务器上的资源的请求 。继续引用上面的例子：还是新闻以网站为例，读者对新闻发表自己的评
     论应该通过POST实现，因为在评论提交后站点的资源已经不同了，或者说资源被修改了。 　　

    
</code></pre>
<p>3.上面大概说了一下HTTP规范中，GET和POST的一些原理性的问题。但在实际的做的时候，很多人却没有按照HTTP规范去做，导致这个问题的原因有很多，比如说：</p>
<pre><code> 　　        
    1.很多人贪方便，更新资源时用了GET，因为用POST必须要到FORM（表单），这样会麻烦一点。　　
    2.对资源的增，删，改，查操作，其实都可以通过GET/POST完成，不需要用到PUT和DELETE。 　　
    3.另外一个是，早期的但是Web MVC框架设计者们并没有有意识地将URL当作抽象的资源来看待和设计 。还有一个较为严重的问题是
    传统的Web MVC框架基本上都只支持GET和POST两种HTTP方法，而不支持PUT和DELETE方法。
</code></pre>
]]></content>
      <categories>
        <category>python框架</category>
      </categories>
      <tags>
        <tag>Django请求类型</tag>
      </tags>
  </entry>
  <entry>
    <title>Django框架07--表单</title>
    <url>/jwangcloud/3826544670/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/Django.jpeg"></p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>django的form有两个功能,第一个是帮助我们生成表单,在html里面,第二个功能是帮我们验证表单</p>
<span id="more"></span>

<h2 id="1-生成表单"><a href="#1-生成表单" class="headerlink" title="1. 生成表单"></a>1. 生成表单</h2><ol>
<li><p>首先我们会在一个外部的forms.py文件里面建立我们的表单类,在这个类的定义的字段会直接显示在html里面,我们不用在html里面去写input标签</p>
<blockquote>
<p>test1/forms.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from django import forms</span><br><span class="line"></span><br><span class="line">class LoginForm(forms.Form):</span><br><span class="line">    zhanghu &#x3D; forms.CharField(max_length&#x3D;10)</span><br><span class="line">    mima &#x3D; forms.CharField(max_length&#x3D;20)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>在views里面去实例化表单类,注意,我们是去实例化forms.py里面的LoginForm 然后把实例化的对象login_form 传递给模板 login_test.html 传递的值是 form</p>
<blockquote>
<p>test1/views.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">def test5(request):</span><br><span class="line"></span><br><span class="line">	 from movies.forms import LoginForm</span><br><span class="line">    method &#x3D; request.method</span><br><span class="line"></span><br><span class="line">    if method &#x3D;&#x3D; &quot;GET&quot;:</span><br><span class="line">        login_form &#x3D; LoginForm()</span><br><span class="line">        return render(request,&#39;test1&#x2F;login_test.html&#39;,&#123;&#39;form&#39;:login_form&#125;)</span><br><span class="line">    elif method &#x3D;&#x3D; &quot;POST&quot;:</span><br><span class="line">        account &#x3D; request.POST[&#39;account&#39;]</span><br><span class="line">        password &#x3D; request.POST[&#39;password&#39;]</span><br><span class="line">        return HttpResponse(&#39;POST&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>在html里面去调用form,以为接受值,因为我们在views.py里面定义就是form,当然我们也可以定义其他的值</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return render(request,&#39;test1&#x2F;login_test.html&#39;,&#123;&#39;form&#39;:login_form&#125;)</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<blockquote>
<p>templates/movies/login_test.html</p>
</blockquote>
<pre><code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;hi Login!&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:18001&#x2F;login&#x2F;&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">    &#123;&#123; form &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>python框架</category>
      </categories>
      <tags>
        <tag>Django表单</tag>
      </tags>
  </entry>
  <entry>
    <title>Django框架06--csrf</title>
    <url>/jwangcloud/493232681/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/Django.jpeg"></p>
<h2 id="CSRF概念："><a href="#CSRF概念：" class="headerlink" title="CSRF概念："></a>CSRF概念：</h2><span id="more"></span>

<ol>
<li>全称: CSRF跨站点请求伪造(Cross—Site Request Forgery)</li>
<li>解释: 攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。</li>
</ol>
<h2 id="CSRF攻击攻击原理及过程"><a href="#CSRF攻击攻击原理及过程" class="headerlink" title="CSRF攻击攻击原理及过程"></a>CSRF攻击攻击原理及过程</h2><ol>
<li><p>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</p>
</li>
<li><p>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</p>
</li>
<li><p>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</p>
</li>
<li><p>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</p>
</li>
</ol>
<ol start="5">
<li>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 </li>
</ol>
<h2 id="CSRF攻击实例"><a href="#CSRF攻击实例" class="headerlink" title="CSRF攻击实例"></a>CSRF攻击实例</h2><p>受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2</a> 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。</p>
<p>黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：<a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory%E3%80%82%E4%BD%86%E6%98%AF%E8%BF%99%E4%B8%AA%E8%AF%B7%E6%B1%82%E6%9D%A5%E8%87%AA">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自</a> Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。</p>
<p>这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”<a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a> ”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。</p>
<h2 id="防御CSRF攻击"><a href="#防御CSRF攻击" class="headerlink" title="防御CSRF攻击"></a>防御CSRF攻击</h2><h3 id="目前防御-CSRF-攻击主要有三种策略：验证-HTTP-Referer-字段；在请求地址中添加-token-并验证；在-HTTP-头中自定义属性并验证。"><a href="#目前防御-CSRF-攻击主要有三种策略：验证-HTTP-Referer-字段；在请求地址中添加-token-并验证；在-HTTP-头中自定义属性并验证。" class="headerlink" title="目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。"></a>目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。</h3><h3 id="（1）验证-HTTP-Referer-字段"><a href="#（1）验证-HTTP-Referer-字段" class="headerlink" title="（1）验证 HTTP Referer 字段"></a>（1）验证 HTTP Referer 字段</h3><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory%EF%BC%8C%E7%94%A8%E6%88%B7%E5%BF%85%E9%A1%BB%E5%85%88%E7%99%BB%E9%99%86">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆</a> bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p>
<p>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p>
<p>然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。</p>
<p>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p>
<p>###（2）在请求地址中添加 token 并验证</p>
<p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
<p>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href="http://url/?csrftoken=tokenvalue%E3%80%82">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上 <input type="”hidden”" name="”csrftoken”" value="”tokenvalue”/">，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p>
<p>该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p>
<p>###（3）在 HTTP 头中自定义属性并验证</p>
<p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p>
<p>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>
]]></content>
      <categories>
        <category>python框架</category>
      </categories>
      <tags>
        <tag>Django CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>Django框架05--语法整理</title>
    <url>/jwangcloud/663967090/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/Django.jpeg"></p>
<h2 id="0-笔记格式说明"><a href="#0-笔记格式说明" class="headerlink" title="0.笔记格式说明"></a>0.笔记格式说明</h2><span id="more"></span>

<ol>
<li>代码位置的表示</li>
</ol>
<p>笔记中会有很多代码,比如</p>
<blockquote>
<p>mytest.views.py</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib.auth.models import User</span><br><span class="line">from rest_framework import serializers, viewsets</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol>
<li>mytest.views.py表示在根目录下面的 mytest文件夹 下面的views.py中<br>写入或者查找这些代码</li>
<li>下面那边表示代码</li>
<li>… 三个省略号表示已有代码,需要你到代码中去查看</li>
</ol>
<h2 id="1-restful-api简介"><a href="#1-restful-api简介" class="headerlink" title="1. restful api简介"></a>1. restful api简介</h2><ol>
<li><p>作用:关于如何去设计url的,url的设计其实是很麻烦</p>
</li>
<li><p>观点: url表示了网站的资源</p>
<ol>
<li>URL(Uniform Resoure Locator):统一资源定位符</li>
<li>我们是去通过URL去操控网站里面的资源(数据)</li>
<li>这个Url或者资源他是静态的</li>
</ol>
</li>
<li><p>关于资源的操作(动态的)</p>
<ol>
<li>获取 GET方法</li>
<li>修改 PUT PATCH修改</li>
<li>删除 DELETE</li>
<li>新加 POST</li>
</ol>
</li>
<li><p>思考 comments/delete url的问题</p>
<pre><code> 答案: 以restful标准去设计url的话,他所有的url都是表示静态资源的,他不能有动词
</code></pre>
</li>
<li><p>login logout 怎么去改写:<br> 答案 : 登录是关于session的操作</p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">http://www.ruanyifeng.com/blog/2014/05/restful_api.html</a></p>
</li>
</ol>
<h2 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h2><ol>
<li><p>需要安装的软件</p>
<ol>
<li>django 1.11版本</li>
<li>django drf 最新版本<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install django&#x3D;&#x3D;1.11</span><br><span class="line">pip install djangorestframework</span><br><span class="line">pip install markdown</span><br><span class="line">pip install django-filter</span><br><span class="line">pip install coreapi</span><br></pre></td></tr></table></figure></li>
<li>postman发送get或者post方法的工具<br> <a href="https://www.getpostman.com/apps">https://www.getpostman.com/apps</a></li>
</ol>
</li>
<li><p>在setting中加入drf app应用</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS &#x3D; (</span><br><span class="line">    ...</span><br><span class="line">    &#39;rest_framework&#39;,</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在drf_movie_rimi.urls.py中配置url</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import include</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    ...</span><br><span class="line">    url(r&#39;^api-auth&#x2F;&#39;, include(&#39;rest_framework.urls&#39;))</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在settings.py中配置drf的权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line">    # Use Django&#39;s standard &#96;django.contrib.auth&#96; permissions,</span><br><span class="line">    # or allow read-only access for unauthenticated users.</span><br><span class="line">    &#39;DEFAULT_PERMISSION_CLASSES&#39;: [</span><br><span class="line">        &#39;rest_framework.permissions.DjangoModelPermissionsOrAnonReadOnly&#39;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>安装drf自动文档生成功能</li>
</ol>
<p>drf_movie_rimi.urls.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from rest_framework.documentation import include_docs_urls</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    ...</span><br><span class="line">    url(r&#39;^docs&#x2F;&#39;, include_docs_urls(title&#x3D;&#39;My API title&#39;))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>访问文档url  <a href="http://127.0.0.1:8001/docs/">http://127.0.0.1:8001/docs/</a></p>
</blockquote>
<h2 id="3-drf快速上手"><a href="#3-drf快速上手" class="headerlink" title="3. drf快速上手"></a>3. drf快速上手</h2><h3 id="1-示例代码"><a href="#1-示例代码" class="headerlink" title="1. 示例代码"></a>1. 示例代码</h3><ol>
<li>新建一个 test的 app 来实验一下drf</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">startapp mytest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>书写drf代码</li>
</ol>
<blockquote>
<p>1.定义视图类和视图类需要的序列化类</p>
</blockquote>
<blockquote>
<p>mytest.views.py</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib.auth.models import User</span><br><span class="line">from rest_framework import serializers, viewsets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义序列化数据 把user表里面的 url username mail is_staff字段提取出来</span><br><span class="line">class UserSerializer(serializers.HyperlinkedModelSerializer):</span><br><span class="line">    class Meta:</span><br><span class="line">        #使用哪个数据模型</span><br><span class="line">        model &#x3D; User</span><br><span class="line">        #序列化哪些字段出来</span><br><span class="line">        fields &#x3D; (&#39;url&#39;, &#39;username&#39;, &#39;email&#39;, &#39;is_staff&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserViewSet(viewsets.ModelViewSet):</span><br><span class="line">    queryset &#x3D; User.objects.all()</span><br><span class="line">    serializer_class &#x3D; UserSerializer</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.定义路由 把mytest的url包含到总url中</p>
</blockquote>
<blockquote>
<p>drf_movie_rimi.urls.py</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from django.conf.urls import url,include</span><br><span class="line">from django.contrib import admin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    ...</span><br><span class="line">    url(r&#39;^mytest&#x2F;&#39;, include(&#39;mytest.urls&#39;)),</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在mytest的app中定义路由，指向到我们的视图函数</p>
</blockquote>
<blockquote>
<p>mytest.urls.py</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from rest_framework import routers</span><br><span class="line">from mytest.views import UserViewSet</span><br><span class="line">from django.conf.urls import include,url</span><br><span class="line"></span><br><span class="line">router &#x3D; routers.DefaultRouter()</span><br><span class="line">router.register(r&#39;users&#39;, UserViewSet)</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^&#39;, include(router.urls)),</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>使用 createsuperuser 的api 来新建一个或者几个用户的信息</p>
</li>
<li><p>访问接口 查看数据</p>
</li>
<li><p>代码简单解释</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;mytest&#x2F;users&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-知识点讲解"><a href="#4-知识点讲解" class="headerlink" title="4. 知识点讲解"></a>4. 知识点讲解</h2><h3 id="1-views"><a href="#1-views" class="headerlink" title="1. views"></a>1. views</h3><ol>
<li><p>drf的views和django原生的views一样,可以返回数据,获取get,post方法的参数,验证数据等等。<br>也可以像之前listview detailview, createview deleteview 一样,直接帮你做列表和单<br>个数据的查询,创建数据,删除数据</p>
</li>
<li><p>基础view 函数视图</p>
<ol>
<li>我们可以像django最基础的函数视图一样,去返回一个报文给http请求,注意我们需要加上装饰器<br>才能运行</li>
</ol>
<p> 定义views</p>
<blockquote>
<p>mytest.view_test1.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">from rest_framework.decorators import api_view</span><br><span class="line">from rest_framework.response import Response</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">@api_view()</span><br><span class="line">def hello_world(request):</span><br><span class="line">    return Response(&#123;&quot;message&quot;: &quot;Hello, world!&quot;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<pre><code>定义url路由
&gt;mytest.urls.py
</code></pre>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">from mytest.view_test1 import hello_world</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    ...</span><br><span class="line">    url(r&#39;test2&#39;,hello_world),</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<pre><code>如果上面的函数运行成功,我们就可以去通过最简单得函数视图去解决 简单得业务逻辑,如get请求
post请求,但是事情没有那么简单

我们会发现你用post 方法是不行的,需要加上方法的装饰器
&gt;mytest.view_test1.py

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from rest_framework.decorators import api_view</span><br><span class="line">from rest_framework.response import Response</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">@api_view([&#39;GET&#39;, &#39;POST&#39;])</span><br><span class="line">def hello_world(request):</span><br><span class="line">    return Response(&#123;&quot;message&quot;: &quot;Hello, world!&quot;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
<p>   练习:</p>
<pre><code>  1. 使用postman发送post方法 断点查看request的值,实现一个功能, get post方法过来
分别返回不同的值
  2. 再次观察我们的response
   里面值,我们传递的是一个list或者dict,如果是django的话你会收到一个报错,但是drf里面的response
   会帮我们解析成json数据格式
</code></pre>
<p>   查看其实这个request的值其实是rest_framework的request解析过来的,和我们之间的django request有什么不一样</p>
<ol start="2">
<li>APIView</li>
</ol>
<pre><code>APIView是我们接触到的第一个类视图,就像django的template view一样 是基础的视图类,你需要自己去定义get post
方法,需要自己去定义返回的数据,但是我们可以看到,我们不用自己去解析get方法和post方法,
只用重写get post函数就可以去截取get ost方法传过来的参数

   1. 简单的get post请求
    mytest.view_test1.py
    
    
    
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from rest_framework.response import Response</span><br><span class="line">from rest_framework import authentication, permissions</span><br><span class="line">from django.contrib.auth.models import User</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">class ListUsers(APIView):</span><br><span class="line"></span><br><span class="line">    def get(self, request, format&#x3D;None):</span><br><span class="line">        return Response(&#123;&quot;get&quot;: &quot;Hello, world!&quot;&#125;)</span><br><span class="line"></span><br><span class="line">    def post(self, request, format&#x3D;None):</span><br><span class="line">            return Response(&#123;&quot;post&quot;: &quot;Hello, world!&quot;&#125;)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>


    定义url路由
    &gt;mytest.urls.py

    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">from mytest.view_test1 import ListUsers</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    ...</span><br><span class="line">    url(r&#39;test1&#39;,ListUsers.as_view()),</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

   2. APIView里面包含了很多强大的功能,比如我们权限控制

   我们制作一个接口,访问用户数据接口,由于用户信息比较敏感，我们需要授权用户(登录用户)去才能访问
   APIView里面自带了权限验证接口,接口分为两部分:

   1. 通过一定的方式，比如session或者cookie或者其他区识别用户是哪个
       &gt;authentication_classes

   2. 通过识别好的用户身份，去判断他是否由权限使用这个接口
       &gt; permission_classes

   mytest.view_test1.py
   
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from rest_framework.response import Response</span><br><span class="line">from rest_framework import authentication, permissions</span><br><span class="line"></span><br><span class="line">class ListUsersV2(APIView):</span><br><span class="line"></span><br><span class="line">#通过什么方式来验证用户,这个例子里面是通过token来验证用户信息</span><br><span class="line">authentication_classes &#x3D; (authentication.TokenAuthentication,)</span><br><span class="line">#用户必须是什么级别才能使用这个接口</span><br><span class="line">permission_classes &#x3D; (permissions.IsAdminUser,permissions.IsAuthenticatedOrReadOnly)</span><br><span class="line"></span><br><span class="line">def get(self, request, format&#x3D;None):</span><br><span class="line">    return Response(&#123;&quot;get&quot;: &quot;Hello, world!&quot;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def post(self, request, format&#x3D;None):</span><br><span class="line">    return Response([username for username in User.objects.all()])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

    定义url路由
    &gt;mytest.urls.py

    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">from mytest.view_test1 import ListUsersV2</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    ...</span><br><span class="line">    url(r&#39;test3&#39;,ListUsersV2.as_view()),</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

    3. GenericAPIView解析

        1. GenericAPIView解析继承自 APIView 扩展了他的很多功能
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class GenericAPIView(views.APIView):</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

        2. GenericAPIView的具体功能

            1. 强制要求传递 queryset和serializer_class

            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">queryset &#x3D; None</span><br><span class="line">serializer_class &#x3D; None</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

            2. 为detailview 默认制定pk为查询的依据

            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lookup_field &#x3D; &#39;pk&#39;</span><br><span class="line">lookup_url_kwarg &#x3D; None</span><br></pre></td></tr></table></figure>

            3. 定义 get_queryset get_serializer_class等class,指定分页 扩展第一个功能

            4. 参看 mytest.view_test5.py 我们可以直接调用他的函数，获取序列化的数据
            返回给前端

            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">class UserListTest5V1(generics.GenericAPIView):</span><br><span class="line">   queryset &#x3D; User.objects.all()</span><br><span class="line">   serializer_class &#x3D; UserSerializer</span><br><span class="line"></span><br><span class="line">   def get(self, request, format&#x3D;None):</span><br><span class="line">       serializer &#x3D; self.get_serializer(self.get_queryset(), many&#x3D;True)</span><br><span class="line">       return Response(serializer.data)</span><br></pre></td></tr></table></figure>




4. 访问速度控制

mytest.view_test1.py

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework.throttling import UserRateThrottle</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">class OncePerDayUserThrottle(UserRateThrottle):</span><br><span class="line">    rate &#x3D; &#39;1&#x2F;day&#39;</span><br><span class="line"></span><br><span class="line">class ListUsersV2(APIView):</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">throttle_classes &#x3D; (OncePerDayUserThrottle,)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="3">
<li><p>Generic views 封装了一定功能的view类</p>
<ol>
<li><p>简介: 回想django的listview 我们通过这个类无需自己去数据库取东西,<br>只需要告诉他我们的model是什么 模板用什么 他就可以帮我们自动的完成浏览你要<br>访问的model,然后返回给模板数据</p>
</li>
<li><p>ListAPIView 类似于detailview一样 返回给我们所有数据的列表</p>
<ol>
<li><p>queryset 告诉他我们需要使用哪个数据</p>
</li>
<li><p>serializer_class 告诉他我们使用哪个序列化定义</p>
</li>
</ol>
</li>
</ol>
<p> mytest.view_test2.py</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from django.contrib.auth.models import User</span><br><span class="line">from rest_framework import generics</span><br><span class="line">from rest_framework.permissions import IsAdminUser</span><br><span class="line">from rest_framework import serializers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserSerializer(serializers.Serializer):</span><br><span class="line">    username &#x3D; serializers.CharField(max_length&#x3D;50)</span><br><span class="line"></span><br><span class="line">class UserList(generics.ListAPIView):</span><br><span class="line">    queryset &#x3D; User.objects.all()</span><br><span class="line">    serializer_class &#x3D; UserSerializer</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> mytest.urls.py</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">from mytest.view_test2 import UserList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    ...</span><br><span class="line">    url(r&#39;test5&#39;,UserList.as_view()),</span><br><span class="line">    url(r&#39;^&#39;, include(router.urls)),</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<pre><code>3. ListAPIView解析

    查看他的源码 发现他是由mixins和GenericAPIView组合生成的一个类,
    其中重写了get方法,让get方法去执行mixins里面的list方法

    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ListAPIView(mixins.ListModelMixin,</span><br><span class="line">                  GenericAPIView):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Concrete view for listing a queryset.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        return self.list(request, *args, **kwargs)</span><br></pre></td></tr></table></figure>

    mixins是什么，如何理解mixins就成了理解这个类的关键

4. Mixin解析

    1. 简介:通过上面的ListAPIView 我们可以有了很便捷的方式去获取数据库里面的
    数据 比如通过下面函数我们就可以获取到序列化的数据
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">serializer &#x3D; self.get_serializer(self.get_queryset(), many&#x3D;True)</span><br></pre></td></tr></table></figure>


    2. 但是这样不符合DRY原则,我们每次使用ListAPIView或者APIVIEW
    我们都需要自己的去序列化数据返回给前,我们需要一种方法,他已经给我们
    写好了,我们只需要去继承他,就可以免费的使用它的序列化方法,所有就有了
    Mixins,我们继承mixins其实 就是去让他改写了我们get post等等方法,我们
    就不用想

    3. mixins
        1. ListModelMixin  对应获取列表的方法

        2. RetrieveModelMixin 对应获获取一条数据

        3. CreateModelMixin 对应创建数据

        4. UpdateModelMixin 对应修改数据的时候调用

        5. DestroyModelMixin 对应删除数据的时候调用






5. 组合构建view的思路解析

    1. APIView

        1. 里面实现了很多基础的方法,比如我们可以通过APIView
        去截获 get post方法，去限制访问速度,限制用户权限

        &gt; 参看 mytest.view_test1.py

        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"> class ListUsersV2(APIView):</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

        &gt; 参看 APIView的源码

        2. 比如我们需要获取User表里面的部分数据,我们会怎么办

        练习: 自己实现一个通过get,post,put,delete等方法访问,获取用户不同的字段信息,
        或者返回不同的值,表示了你访问了不同的方法

        答案: mytest.view_test3.py
        
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from django.contrib.auth.models import User</span><br><span class="line">from rest_framework.response import Response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ListUsersV2(APIView):</span><br><span class="line"></span><br><span class="line">    def get(self, request, format&#x3D;None):</span><br><span class="line">        return Response([i.username for i in User.objects.all()])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

        3. 使用get方法获取用户数据 username,email,password, 并且是key:value的形式
        答案: mytest.view_test3.py
        
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class ListUsersTest3V2Serializer(serializers.Serializer):</span><br><span class="line">    username &#x3D; serializers.CharField(max_length&#x3D;100)</span><br><span class="line">    email &#x3D; serializers.EmailField()</span><br><span class="line">    password &#x3D; serializers.CharField(max_length&#x3D;100)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ListUsersTest3V2(APIView):</span><br><span class="line"></span><br><span class="line">    def get(self, request, format&#x3D;None):</span><br><span class="line">        # datas &#x3D; []</span><br><span class="line">        # for i in User.objects.all():</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        datas &#x3D; ListUsersTest3V2Serializer(User.objects.all()[0])</span><br><span class="line">        return Response(datas.data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
        我们可以把数据交给序列化去帮我们把数据转化成可迭代对象或者可以被json化的数据

    2. Mixin + APIView
        1. 通过上面的接口可以知道,我们可以通过APIView实现很多我们想要的功能,
        但是,很多逻辑需要我们自己去实现,比如创建一条时间,遍历一条数据。我们也需要去
        定义get post方法去识别这些方法,来判断是否是遍历数据还是添加数据.这时候 我们
        需要mixin去帮我们实现这些功能,我们就可以少些重复性的代码。

        2. 查看mixin源码 mixins.ListModelMixin 我们可以看到他有一个list方法,
        方法的含义是把model里面的数据交给一个serializer 然后返回数据 这样 listMixin
        就有了遍历所有数据的功能

        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ListModelMixin(object):</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">List a queryset.</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">def list(self, request, *args, **kwargs):</span><br><span class="line">    queryset &#x3D; self.filter_queryset(self.get_queryset())</span><br><span class="line"></span><br><span class="line">    page &#x3D; self.paginate_queryset(queryset)</span><br><span class="line">    if page is not None:</span><br><span class="line">        serializer &#x3D; self.get_serializer(page, many&#x3D;True)</span><br><span class="line">        return self.get_paginated_response(serializer.data)</span><br><span class="line"></span><br><span class="line">    serializer &#x3D; self.get_serializer(queryset, many&#x3D;True)</span><br><span class="line">    return Response(serializer.data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

        3.问题: 既然我们有mixin 为什么不直接继承mixin 而是需要把mixin和APIView
        结合来使用？

    3. ListAPIView其实就这个就是帮你把Mixin和apiview组合好了给你直接使用,
    还有其他很多方法 RetrieveAPIView,DestroyAPIView,RetrieveUpdateDestroyAPIView
    这些便捷的组合方法

    &gt; 我们只需要告诉他使用哪个model queryset serializer_class即可,他自动会帮我们
    完成数据遍历的功能和返回Response的工作
    
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ListUsersTest3V3(ListAPIView):</span><br><span class="line"></span><br><span class="line">    model &#x3D; User</span><br><span class="line">    queryset &#x3D; User.objects.all()</span><br><span class="line">    serializer_class &#x3D; ListUsersTest3V2Serializer</span><br><span class="line"></span><br></pre></td></tr></table></figure>


    4. rest_framework.viewsets 更加高层的继承方法
        1. GenericAPIView 和 GenericViewSet


            1. 我们可以看到（源码） ListAPIView  viewsets 都是用了各种mixin
           来做组合，但是 他们最后用的GenericAPIView GenericViewSet却不一样。

            2. 所以问题出在 继承的不同的组合mixin 和 GenericAPIView,GenericViewSet
           我们已经了解不同的mixin会给我们带来不同的快捷使用方法
           现在问题就出在 GenericAPIView GenericViewSet

            3. 再次研究 GenericAPIView GenericViewSet我们可以看到
            GenericViewSet继承自 GenericAPIView 和ViewSetMixin，我们已经知道
            GenericAPIView的用处,那么GenericViewSet其实就是去扩展GenericAPIView,
            通过和ViewSetMixin去扩展

            4. ViewSetMixin 其实就是去改写我们的 get post等方法,让他在request.action
            里面变成 list create等等 观察下面的代码


            &gt;mytest.view_test4.py
            
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UserListTest4V1(generics.ListAPIView):</span><br><span class="line">    queryset &#x3D; User.objects.all()</span><br><span class="line">    serializer_class &#x3D; UserSerializer</span><br><span class="line"></span><br><span class="line">    def get_queryset(self):</span><br><span class="line">        x &#x3D; self.request.method</span><br><span class="line">        return super().get_queryset()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserListTest4V2(viewsets.ReadOnlyModelViewSet):</span><br><span class="line">    queryset &#x3D; User.objects.all()</span><br><span class="line">    serializer_class &#x3D; UserSerializer</span><br><span class="line"></span><br><span class="line">    def get_queryset(self):</span><br><span class="line">        x &#x3D; self.action</span><br><span class="line">        return super().get_queryset()</span><br></pre></td></tr></table></figure>

            在return上面断点 查看x的值是什么

            5. 再次查看ListAPIView源码 我们发现他的代码逻辑是重写了
            get方法 把get方法换成mixins里面的list方法
            
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class ListAPIView(mixins.ListModelMixin,</span><br><span class="line">  GenericAPIView):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Concrete view for listing a queryset.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        return self.list(request, *args, **kwargs)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

            6. 查看viewsets中的方法,没有重写任何方法，直接继承过去,
            得益于我们的GenericViewSet把我们的方法换成了list等等,所以可以直接
            去使用

        2. viewset系列的里面的各种方法

            1. ReadOnlyModelViewSet

                只能查看单条数据或者多条数据

            2. ModelViewSet

                增删查改四种方法

6. 总结:
    1. 最基本的drf的view函数

    2. APIView 提供了权限 限速等等功能 和高级的GenericAPIView提供了必须自定义序列化
    和请求哪个数据库

    3. ListCreateAPIView等等组合的view 来实现各种常用的方法 但是他需要改写get post等等

    4.  ModelViewSet 等等更高级的组合view 他无需改写 get post方法

    5.  区分 generics里面的view 和 viewset里面的view 两者都是组合功能 都可以使用,但是后者更好
    用
</code></pre>
<h3 id="2-serializers"><a href="#2-serializers" class="headerlink" title="2. serializers"></a>2. serializers</h3><ol>
<li><p>serializers 序列化类的意义(验证数据和展示数据)</p>
<ol>
<li><p>序列化的简介:<br> 就像form表单一样,帮你生成表单和验证表单,序列化帮你验证和生成数据</p>
</li>
<li><p>序列化的意义:<br> 把我们复杂的数据库请求,请求之后得到的数据,转化成json,xml等简单的数据库格式<br> 类似于之前学到的form表单和formModel类,把我们定义复杂的表单转化成html的实际表单<br> ,这样你就不会在乎数据是怎么转化成html或者json的细节问题,只用定义好你对数据要求的<br> 格式，和需要序列化哪些数据即可</p>
</li>
</ol>
</li>
<li><p>外部使用django:</p>
<ol>
<li><p>django平时使用它的的功能把一些数据存入数据库,我们需要启动django的server(runserver),</p>
<pre><code> 定义view然后做路由,然后定义url，访问url,django才会执行view里面的
 相应的函数,试想一下,如果我们直接去执行一个定义好的文件去存入数据,肯定会报错

 见 mytest.test1.py
</code></pre>
</li>
<li><p>但是我们也可以在不启动django server的情况下,启动django的api,比如刚才的存入数据，我们只需要</p>
<pre><code> 在代码的运行环境中去设置django的目录,django的配置（settings.py）的位置接口,我们可以
 解决这个报错,也就可以从外部去启动django

 见 mytest.test2.py
</code></pre>
</li>
</ol>
</li>
<li><p>如何把对象序列化</p>
<blockquote>
<p>mytest.tests.py  在下面的代码中 创建一个对象 然后把对象交给序列化去处理</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from django.test import TestCase</span><br><span class="line"></span><br><span class="line"># Create your tests here.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    import sys, os</span><br><span class="line"></span><br><span class="line">    base_dir &#x3D; os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line">    sys.path.append(base_dir)</span><br><span class="line">    os.environ[&#39;DJANGO_SETTINGS_MODULE&#39;] &#x3D; &#39;drf_movie_rimi.settings&#39;</span><br><span class="line"></span><br><span class="line">    from datetime import datetime</span><br><span class="line">    from rest_framework import serializers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    class Comment(object):</span><br><span class="line">        def __init__(self, email, content, created&#x3D;None):</span><br><span class="line">            self.email &#x3D; email</span><br><span class="line">            self.content &#x3D; content</span><br><span class="line">            self.created &#x3D; created or datetime.now()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    comment &#x3D; Comment(email&#x3D;&#39;leila@example.com&#39;, content&#x3D;&#39;foo bar&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    class CommentSerializer(serializers.Serializer):</span><br><span class="line">        email &#x3D; serializers.EmailField()</span><br><span class="line">        content &#x3D; serializers.CharField(max_length&#x3D;200)</span><br><span class="line">        created &#x3D; serializers.DateTimeField()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    serializer &#x3D; CommentSerializer(comment)</span><br><span class="line">    print(serializer.data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>  &gt;mytest.tests.py
 使用serializer可以帮我们验证错误的数据
</code></pre>
</li>
</ol>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">comment_error &#x3D; Comment(email&#x3D;&#39;leila@example.com&#39;, content&#x3D;&#39;foo bar&#39;)</span><br><span class="line">serializer_error &#x3D; CommentSerializer(data&#x3D;comment_error)</span><br><span class="line">print(serializer_error.is_valid())</span><br><span class="line">print(serializer_error.errors)</span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="4">
<li><p>序列化详解</p>
<ol>
<li><p>serializers.Serializer 最基础的序列化类</p>
<ol>
<li><p>需要我们像form 一样自己去定义每个字段的要求</p>
<blockquote>
<p>mytest.tests.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CommentSerializer(serializers.Serializer):</span><br><span class="line">    email &#x3D; serializers.EmailField()</span><br><span class="line">    content &#x3D; serializers.CharField(max_length&#x3D;200)</span><br><span class="line">    created &#x3D; serializers.DateTimeField()</span><br></pre></td></tr></table></figure></li>
<li><p>序列化后的数据，只会包含我们定义的数据，注意,就像form一样,不管我们的原始<br> 数据里面有好多数据,序列化出来的也只有我们定义的时候的那么多字段，注意我们的                对象<br> 有test=5但是序列化后的数据是没有test字段的</p>
<blockquote>
<p>mytest.tests.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	        </span><br><span class="line">class Comment(object):</span><br><span class="line">    def __init__(self, email, content, created&#x3D;None):</span><br><span class="line">        self.email &#x3D; email</span><br><span class="line">        self.content &#x3D; content</span><br><span class="line">        self.test &#x3D; &#39;5&#39;</span><br><span class="line">        self.created &#x3D; created or datetime.now()</span><br><span class="line">	        </span><br><span class="line">	        </span><br><span class="line"># 实例化一个对象 给予邮箱和内容</span><br><span class="line">comment &#x3D; Comment(email&#x3D;&#39;leila@example.com&#39;, content&#x3D;&#39;foo bar&#39;)</span><br><span class="line">	        </span><br><span class="line">	        </span><br><span class="line"># 定义序列化的数据要求</span><br><span class="line">class CommentSerializer(serializers.Serializer):</span><br><span class="line">    email &#x3D; serializers.EmailField()</span><br><span class="line">    content &#x3D; serializers.CharField(max_length&#x3D;200)</span><br><span class="line">    created &#x3D; serializers.DateTimeField()</span><br><span class="line">	</span><br></pre></td></tr></table></figure></li>
<li><p>序列化类可以帮我们验证数据是否满足我们定义的要求,就像form验证数据一样</p>
<ol>
<li>我们新建一个对象</li>
<li>把对象进行序列化成dict</li>
<li>把序列化后的数据(dict)交给序列化类检查(注意使用data)</li>
<li>验证后 可以使用is_valid查看是否验证成功</li>
<li>errors可以查看验证失败的信息</li>
<li>验证成功后可以通过validated_data来查看验证成功后的数据</li>
</ol>
<h5 id="注意-他只能验证-dict的数据-而且调用方法也不一样"><a href="#注意-他只能验证-dict的数据-而且调用方法也不一样" class="headerlink" title="注意:他只能验证 dict的数据 而且调用方法也不一样"></a>注意:他只能验证 dict的数据 而且调用方法也不一样</h5><blockquote>
<p>mytest.tests.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">comment_error &#x3D; Comment(email&#x3D;&#39;leie@mple.com&#39;, content&#x3D;&#39;foo bar&#39;)</span><br><span class="line">comment_data &#x3D; CommentSerializer(comment_error)</span><br><span class="line">serializer_error &#x3D; CommentSerializer(data&#x3D;comment_data.data)</span><br><span class="line">print(serializer_error.is_valid())</span><br><span class="line">print(serializer_error.errors)</span><br><span class="line">print(serializer_error.validated_data)</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
<li><p>我们可以把序列化后的dict转化为json数据格式</p>
<pre><code>   &gt;mytest.tests.py
     
     
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 		...</span><br><span class="line"> 		from rest_framework.renderers import JSONRenderer</span><br><span class="line">json &#x3D; JSONRenderer().render(comment_data.data)</span><br><span class="line">print(json)</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
 
</code></pre>
<p>同样 把json转化回来成dict</p>
<pre><code>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">       from django.utils.six import BytesIO</span><br><span class="line">from rest_framework.parsers import JSONParser</span><br><span class="line">					</span><br><span class="line">stream &#x3D; BytesIO(json)</span><br><span class="line">data &#x3D; JSONParser().parse(stream)</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
 
</code></pre>
</li>
</ol>
</li>
<li><p>serializer 自带数据的存储功能,我们可以定义创建数据或者修改数据的的时候去数据库保存数据</p>
<ol>
<li><p>serializer 带有save 方法,调用save方法可以调用他的create和update方法,<br>在create方法中我们可以去添加自己的逻辑,比如保存数据。</p>
</li>
<li><p>保存数据 我们需要定义create方法 让他在调用save的时候的保存数据</p>
<blockquote>
<p>mytest.serializer_test1.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">   # 外部启动django的方法</span><br><span class="line">   import sys, os</span><br><span class="line">   from django.core.wsgi import get_wsgi_application</span><br><span class="line">			</span><br><span class="line">   base_dir &#x3D; os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line">   sys.path.append(base_dir)</span><br><span class="line">   os.environ[&#39;DJANGO_SETTINGS_MODULE&#39;] &#x3D; &#39;drf_movie_rimi.settings&#39;</span><br><span class="line">   application &#x3D; get_wsgi_application()</span><br><span class="line">			</span><br><span class="line">   from rest_framework import serializers</span><br><span class="line">   from mytest.models import Mytest</span><br><span class="line">			</span><br><span class="line">   class MyTestSerializer(serializers.Serializer):</span><br><span class="line">       name &#x3D; serializers.CharField(max_length&#x3D;20)</span><br><span class="line">       age &#x3D; serializers.IntegerField()</span><br><span class="line">       id &#x3D; serializers.IntegerField()</span><br><span class="line">			</span><br><span class="line">       #重写save方法 让他验证成功后保存数据</span><br><span class="line">       def create(self, validated_data):</span><br><span class="line">           return Mytest.objects.create(**validated_data)</span><br><span class="line">			</span><br><span class="line">...</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">   serializer_data &#x3D; MyTestSerializer(data&#x3D;&#123;&#39;name&#39;:&#39;测试&#39;,&#39;age&#39;:81&#125;)</span><br><span class="line">   #必须调用了is_valid之后才能调用save方法</span><br><span class="line">   serializer_data.is_valid()</span><br><span class="line">   serializer_data.save()</span><br><span class="line">	</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
<li><p>重写update方法 在调用 CommentSerializer(comment, data=data)后再调用save方法 他会去执行我们update函数</p>
<blockquote>
<p>mytest.serializer_test1.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      class MyTestSerializer2(serializers.Serializer):</span><br><span class="line">    name &#x3D; serializers.CharField(max_length&#x3D;20)</span><br><span class="line">    age &#x3D; serializers.IntegerField()</span><br><span class="line">    id &#x3D; serializers.IntegerField()</span><br><span class="line">			</span><br><span class="line">    # 重写update方法 让他验证成功后更新数据</span><br><span class="line">    def update(self, instance, validated_data):</span><br><span class="line">        id &#x3D; validated_data.get(&#39;id&#39;)</span><br><span class="line">        #获取manager</span><br><span class="line">        obj &#x3D; instance.objects.filter(pk&#x3D;id)[0]</span><br><span class="line">        #更新数据</span><br><span class="line">        obj.name &#x3D; validated_data.get(&#39;name&#39;, obj.name)</span><br><span class="line">        obj.age &#x3D; validated_data.get(&#39;age&#39;, obj.age)</span><br><span class="line">        try:</span><br><span class="line">            #保存更新</span><br><span class="line">            obj.save()</span><br><span class="line">        except Exception as e:</span><br><span class="line">            x &#x3D; e</span><br><span class="line">            pass</span><br><span class="line">			</span><br><span class="line">        return obj</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">data &#x3D; Mytest.objects.all()[0]</span><br><span class="line">serializer_data &#x3D; MyTestSerializer2(Mytest, data&#x3D;&#123;&#39;id&#39;:4,&#39;name&#39;: &#39;测试&#39;, &#39;age&#39;: 81&#125;)</span><br><span class="line"># 必须调用了is_valid之后才能调用save方法</span><br><span class="line">serializer_data.is_valid()</span><br><span class="line">serializer_data.save()</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
<li><p>梳理:</p>
<ol>
<li><p>创建数据 serializer_data = MyTestSerializer(data={‘name’:’测试’,’age’:81})后save是调用create方法</p>
</li>
<li><p>更新数据 serializer_data = MyTestSerializer2(Mytest, data={‘id’:4,’name’: ‘测试’, ‘age’: 81}) 由于没有指定更新到哪个model 所以我们需要把Model传递给我们的MyTestSerializer2</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>ModelSerializer </p>
<ol>
<li><p>简介 ModelSerializer 类似于我们的formModel类，你需要给定一个数据库的,他会自动的帮你生成验证规则。然后你给定要验证哪些字段(field)就可以了</p>
</li>
<li><p>model serializer中也自带了create和update的方法,我们验证了数据之后可以直接存入数据库(因为我们已经给定了model)</p>
</li>
<li><p>ModelSerializer相当于我们基础serializer的升级版,帮我们简化了很多操作</p>
</li>
<li><p>使用示例</p>
<blockquote>
<p>mytest.serializer_test2.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">  # 外部启动django的方法</span><br><span class="line">  import sys, os</span><br><span class="line">  from django.core.wsgi import get_wsgi_application</span><br><span class="line">		</span><br><span class="line">  base_dir &#x3D; os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line">  sys.path.append(base_dir)</span><br><span class="line">  os.environ[&#39;DJANGO_SETTINGS_MODULE&#39;] &#x3D; &#39;drf_movie_rimi.settings&#39;</span><br><span class="line">  application &#x3D; get_wsgi_application()</span><br><span class="line">		</span><br><span class="line">  from rest_framework import serializers</span><br><span class="line">  from mytest.models import Mytest</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">  class MyTestSerializer(serializers.ModelSerializer):</span><br><span class="line">      class Meta:</span><br><span class="line">          model &#x3D; Mytest</span><br><span class="line">          fields &#x3D; (&quot;name&quot;, &#39;age&#39;)</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">  data &#x3D; MyTestSerializer(data&#x3D;&#123;&#39;name&#39;: &#39;model&#39;, &#39;age&#39;: 54&#125;)</span><br><span class="line">  data.is_valid()</span><br><span class="line">  data.save()</span><br><span class="line">     </span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
<li><p>扩展方法:</p>
<ol>
<li>fields : <ol start="2">
<li>’“__all__”‘ 代表所有的字段</li>
<li>exclude = (‘users’,) 代表除了 user字段 其他字段都可以</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>综合使用示例:</p>
<blockquote>
<p>mytest.test1_views.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class BookListV2ViewSet(mixins.DestroyModelMixin,mixins.ListModelMixin,mixins.UpdateModelMixin,</span><br><span class="line">						mixins.RetrieveModelMixin,GenericViewSet):</span><br><span class="line">    queryset &#x3D; Book.objects.all()</span><br><span class="line">    serializer_class &#x3D; BookListSerializer</span><br><span class="line"></span><br><span class="line">    def get_queryset(self):</span><br><span class="line"></span><br><span class="line">        method &#x3D; self.request.method</span><br><span class="line"></span><br><span class="line">        x &#x3D; self.action</span><br><span class="line">        return Book.objects.all()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">实现一个方法:放里面有书,</span><br><span class="line">1.随便哪个用户可以去创建一本书</span><br><span class="line">2.只有创建这本书的用户可以去修改这本书</span><br><span class="line">3.只有创建这本书的用户可以去删除这本书</span><br><span class="line">4.所有用户可以看到所有的书</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">class BookSerializer(serializers.ModelSerializer):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; Book</span><br><span class="line">        fields &#x3D; &quot;__all__&quot;</span><br><span class="line"></span><br><span class="line">    def create(self, validated_data):</span><br><span class="line">        validated_data[&#39;creator&#39;] &#x3D; self.context[&#39;request&#39;]._user</span><br><span class="line">        validated_data[&#39;name&#39;] &#x3D; &#39;不好意思&#39;</span><br><span class="line"></span><br><span class="line">        return super().create(validated_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def update(self, instance, validated_data):</span><br><span class="line"></span><br><span class="line">        if self.context[&#39;request&#39;]._user !&#x3D; instance.creator:</span><br><span class="line">            raise serializers.ValidationError(&#39;不是创建者&#39;)</span><br><span class="line">        return super().update(instance,validated_data)</span><br><span class="line">	</span><br><span class="line">	</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-url-路由表定义"><a href="#3-url-路由表定义" class="headerlink" title="3. url 路由表定义"></a>3. url 路由表定义</h3><p>1.router.register() 只有继承了viewset的类才能使用</p>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h3 id="1-项目简介"><a href="#1-项目简介" class="headerlink" title="1. 项目简介"></a>1. 项目简介</h3><ol>
<li><p>下载猫眼电影 高仿猫眼电影app</p>
</li>
<li><p>restful的风格的基本概念</p>
<ol>
<li>api接口开发模式</li>
</ol>
<p> 后台服务器只提供数据接口和返回数据,由前端js负责获取数据。然后动态的展现在前端。</p>
<p> 前后分离的好处–&gt;后端只负责逻辑接口和数据,前端只负责页面展现逻辑。前后端工作进度<br> 互不干扰</p>
<p> 现在主流的开发模式基本都是前后分离</p>
<ol start="2">
<li><p>restful基本概念</p>
<ol>
<li>一切的url代表的是资源,api通过get post del等动作去操控资源</li>
</ol>
<p> restful的目的在于统一化清晰化url的,一个大型网站有很多不同的url,使用restful之后可以很好的管理资源</p>
<p> 相关资料</p>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">http://www.ruanyifeng.com/blog/2014/05/restful_api.html</a></p>
</blockquote>
<blockquote>
<p> <a href="http://www.ruanyifeng.com/blog/2011/09/restful.html">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p>
</blockquote>
<ol start="2">
<li>restful只是一套url设计理念,具体还是需要自己去实现</li>
</ol>
</li>
<li><p>再次查看接口文档</p>
<ol>
<li><p>create 创建一个实例 post方法</p>
</li>
<li><p>list 获取多个实例 get方法</p>
</li>
<li><p>read 方法 获取指定的实例</p>
</li>
<li><p>update partial_update更新 put PATCH</p>
</li>
<li><p>delete 销毁一个实例 delete</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2-项目登录"><a href="#2-项目登录" class="headerlink" title="2.项目登录"></a>2.项目登录</h3><ol>
<li><p>新建用户model</p>
<ol>
<li><p>分析:</p>
<ol>
<li>我们知道 django自带的用户系统里面有很多可以用的数据,比如email 是否激活等等,但是还有其他信息需要我们自己去定义,比如手机 生日 昵称 地址 用户头像</li>
</ol>
</li>
<li><p>创建app和user的model</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">startapp users</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建用户模型</p>
</li>
</ol>
<blockquote>
<p>users.model.py</p>
</blockquote>
<pre><code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     from django.db import models</span><br><span class="line">from django.contrib.auth.models import AbstractUser</span><br><span class="line">		</span><br><span class="line"># Create your models here.</span><br><span class="line"></span><br><span class="line">class UserProfile(AbstractUser):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用户信息</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    IS_VIP &#x3D; (</span><br><span class="line">        (False, &#39;非会员&#39;),</span><br><span class="line">        (True, &#39;会员&#39;)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    GENDER &#x3D; (</span><br><span class="line">        (&quot;male&quot;, &quot;男&quot;),</span><br><span class="line">        (&quot;female&quot;, &quot;女&quot;)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    nick_name &#x3D; models.CharField(default&#x3D;&quot;&quot;, max_length&#x3D;50, verbose_name&#x3D;&quot;昵称&quot;, null&#x3D;True, </span><br><span class="line">    								blank&#x3D;True)</span><br><span class="line">    birthday &#x3D; models.DateTimeField(verbose_name&#x3D;&quot;生日&quot;, null&#x3D;True, blank&#x3D;True, </span><br><span class="line">    						auto_created&#x3D;True)</span><br><span class="line">    gender &#x3D; models.CharField(max_length&#x3D;1, choices&#x3D;((&quot;1&quot;, &quot;男&quot;), (&quot;2&quot;, &quot;女&quot;)), default&#x3D;&quot;1&quot;, </span><br><span class="line">    						null&#x3D;True,blank&#x3D;True)</span><br><span class="line">    address &#x3D; models.CharField(max_length&#x3D;100, default&#x3D;&quot;&quot;, verbose_name&#x3D;&#39;用户所在城市&#39;, </span><br><span class="line">    						null&#x3D;True, blank&#x3D;True)</span><br><span class="line">    mobile &#x3D; models.CharField(max_length&#x3D;14, default&#x3D;&quot;&quot;, verbose_name&#x3D;&#39;手机号&#39;)</span><br><span class="line">    register_time &#x3D; models.DateTimeField(auto_now&#x3D;True)</span><br><span class="line">    </span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name &#x3D; &quot;用户信息&quot;</span><br><span class="line">        verbose_name_plural &#x3D; verbose_name</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return str(self.mobile)</span><br><span class="line">     </span><br><span class="line">     </span><br></pre></td></tr></table></figure>
</code></pre>
<blockquote>
<p>settings.py</p>
</blockquote>
<pre><code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  ...</span><br><span class="line">  AUTH_USER_MODEL &#x3D; &quot;users.UserProfile&quot;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  INSTALLED_APPS &#x3D; [</span><br><span class="line">		...</span><br><span class="line">    &#39;users.apps.UsersConfig&#39;</span><br><span class="line">]</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
 
  注释掉settings.py里面的 &#39;django.contrib.admin&#39;, 这一行
 
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">makemigrations</span><br><span class="line">migrate</span><br></pre></td></tr></table></figure>
 

  打开注释掉settings.py里面的 &#39;django.contrib.admin&#39;, 这一行
  
</code></pre>
<ol start="4">
<li><p>知识点:</p>
<ol>
<li> 扩展django已经有的user需要去继承django本身的用户模型表</li>
</ol>
<blockquote>
<p>users.model.py</p>
</blockquote>
<pre><code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     </span><br><span class="line">       from django.contrib.auth.models import AbstractUser</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line"># Create your models here.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserProfile(AbstractUser):</span><br><span class="line">...</span><br><span class="line">     </span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="2">
<li><p>在字段信息中新建 choices 参数,表示字段里面的只能是choices里面元组的几个值之一,tuple里面的第一个值是数据库里面值,第二个是备注,比如 数据库里面存 1 表示男 2表示女</p>
<blockquote>
<p>users.model.py</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     ...</span><br><span class="line">     </span><br><span class="line">       GENDER &#x3D; (</span><br><span class="line">    (&quot;1&quot;, &quot;男&quot;),</span><br><span class="line">    (&quot;2&quot;, &quot;女&quot;)</span><br><span class="line">)</span><br><span class="line">				</span><br><span class="line">nick_name &#x3D; models.CharField(default&#x3D;&quot;&quot;, max_length&#x3D;50, verbose_name&#x3D;&quot;昵称&quot;, </span><br><span class="line">							null&#x3D;True, blank&#x3D;True)</span><br><span class="line">birthday &#x3D; models.DateTimeField(verbose_name&#x3D;&quot;生日&quot;, null&#x3D;True, </span><br><span class="line">							blank&#x3D;True, auto_created&#x3D;True)</span><br><span class="line">gender &#x3D; models.CharField(max_length&#x3D;1, choices&#x3D;GENDER, default&#x3D;&quot;1&quot;, null&#x3D;True,</span><br><span class="line">     </span><br><span class="line">     ...</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
<li><p>参数 null=True , blank=True分别表示数据里面可以存null这个值,和数据库里面可以存空值,记住 null 和空值是不一样的</p>
</li>
<li><p>参数 auto_now auto_now_add 表示添加数据的时候默认添加当前时间,以后不会自动修改; 修改数据的时候默认添加当前时间,每次修改都会自动变化</p>
</li>
<li><p>class Meta: 里面的verbose_name 表示amdin查看这个表的时候 会出现你输入的表名</p>
</li>
<li><p>def <strong>str</strong>(self） 表示查看数据的时候(admin中),每一条数据会返回你定制化的标题,比如我们这个表就会返回一系列的手机号</p>
</li>
<li><p>字段里面加入unique表示我们不能重复！             </p>
<blockquote>
<ol>
<li>但是这个unique会造成我们的一个困境,如果是注册手机号的话,我们每次新建用户就必须输入不同的手机号,你不能不输入,但是如果我们是用户名和邮箱注册的话,那么我们在注册的时候是不会用到手机号。</li>
</ol>
</blockquote>
</li>
</ol>
<blockquote>
<ol start="2">
<li>解决方案是给他设置null=True,defalut=None</li>
<li>解决方案的原理是计算机中有一个null|None表示(无),这个在这个计算机中是唯一的</li>
</ol>
</blockquote>
</li>
</ol>
</li>
<li><p>制作 注册 登录 注销模块</p>
<ol>
<li>JWT<ol>
<li>简介: 传统的session登录方式受限于设备和浏览器,如果我们制作的是一个app而不是使用浏览器去访问。那么我们的整个的</li>
</ol>
</li>
</ol>
<pre><code>保持用户登录就会变得很麻烦,再者 判断用户登录是否成功也不能依赖于我们的模板文件了 官网地址：
</code></pre>
<blockquote>
<p><a href="http://getblimp.github.io/django-rest-framework-jwt/">http://getblimp.github.io/django-rest-framework-jwt/</a></p>
</blockquote>
<pre><code>2. token: token有令牌的意思,他类似以于我们的session，是一串加密数字。我们可以把它理解为session的升级版,因为token更灵活,他可以用于手机app 网页任何地方
 
3. JWT: JWT-&gt; json web token 是token的一个json实现标准,你可以理解为一般互联网企业都是这样做的。所以我们也拿来用即可。JWT最明显的特征是 JWT不会存在于数据库，它类似于csrf_token，我们只用去验证加密是否通过,通过之后就是合法的用户。
</code></pre>
</li>
</ol>
<pre><code>      4. 安装

          <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install djangorestframework-jwt</span><br></pre></td></tr></table></figure>

          在配置文件里面加入,下面这行代码的意思是使用token来认证用户身份

          &gt;settings.py

          <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  ...</span><br><span class="line">  REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line">    # Use Django&#39;s standard &#96;django.contrib.auth&#96; permissions,</span><br><span class="line">    # or allow read-only access for unauthenticated users.</span><br><span class="line">    # &#39;DEFAULT_PERMISSION_CLASSES&#39;: [</span><br><span class="line">    #     &#39;rest_framework.permissions.DjangoModelPermissionsOrAnonReadOnly&#39;</span><br><span class="line">    # ]</span><br><span class="line"></span><br><span class="line">    &#39;DEFAULT_AUTHENTICATION_CLASSES&#39;: (</span><br><span class="line">        &#39;rest_framework_jwt.authentication.JSONWebTokenAuthentication&#39;,</span><br><span class="line">    ),</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

          &gt;urls.py

          <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework_jwt.views import obtain_jwt_token</span><br><span class="line">  #...</span><br><span class="line"></span><br><span class="line">  urlpatterns &#x3D; [</span><br><span class="line">      &#39;&#39;,</span><br><span class="line">      # ...</span><br><span class="line"></span><br><span class="line">      url(r&#39;^api-token-auth&#x2F;&#39;, obtain_jwt_token),</span><br><span class="line">  ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      5. 访问 /docs/接口，就可以看到登录的界面(文档自动生成)

      6. 试着登录 就可以看到返回,这个就是我们的登录秘钥,拿着这个秘钥就可以去验证
      用户信息

      <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">&quot;token&quot;: &quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoxLCJ1c2VybmFtZSI6ImNhbnZhcyIsImV4cCI6MTUzMjAwODg5OSwiZW1haWwiOiIyQDIuY29tIn0.mVhVHMIZZ2qqhzBen7kS8csylx7yrif1gQhw-09wcus&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
      7. 我们把token取出来,在postman上面添加上我们的token
          1. 在post man headers里面去添加一个 key 为 Authorization
          value为 JWT（空格） eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoxLCJ1c2VybmFtZSI6ImNhbnZhcyIsImV4cCI6MTUzMjAwODg5OSwiZW1haWwiOiIyQDIuY29tIn0.mVhVHMIZZ2qqhzBen7kS8csylx7yrif1gQhw-09wcus
      
      8. 在我们的views里面去配置用户认证
      
          <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework_jwt.authentication import JSONWebTokenAuthentication</span><br><span class="line">class xxxView()</span><br><span class="line">...</span><br><span class="line">	authentication_classes &#x3D; (JSONWebTokenAuthentication,)</span><br></pre></td></tr></table></figure>
          
      9. 再访问我们的接口看看是不是把用户取出来了

      10. JWT配置:
    
        设置token的过期时间JWT_EXPIRATION_DELTA
        
      <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      </span><br><span class="line">       JWT_AUTH &#x3D; &#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">   &#39;JWT_EXPIRATION_DELTA&#39;: datetime.timedelta(seconds&#x3D;3600),</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">&#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure>
          
     
      
  2. 利用JWT做登录接口
      
      1. 我们可以从后台新建用户,所以我们可以先做登录,上面我们看到 JWT 登录成功之后返回的是一串token,所以我们登录的任务就是验证数据库账户密码,然后返回一串token给前端。前端以后的请求每次都会带上这个token来,关于前端具体情况我们不用关心。
      
      2. 所以我们的问题流程就分解为
      
          1. 接收用户传递过来的账户密码
          2. 验证账户密码
          3. 验证成功返回token(这里就不用去调用login 接口了 因为我们不用session去做登录) 
          
      3. 根据上面的问题流程我们的代码聚体步骤就分为:
          1. 通过一个view去接收参数,这个view不需要多余的功能,也不会创建遍历数据,只是接收和返回值，所以我们选用 APIView来做view


          2. 我们需要一个函数去验证用户名和密码,这个函数我们已经知道,django的auth接口
          3. 我们在最后需要一个东西去加密用户信息成为标准token,然后返回给前端,我们需要jwt的标准接口 查看官网 
          
          http://getblimp.github.io/django-rest-framework-jwt/
          
          我们可以看到最后官网给了我们标准的token加密方法,代码指出,我们给定用户,然后交给他的用户,他就会给出token,然后我们把token返回给前段即可
          
              <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      </span><br><span class="line">       from rest_framework_jwt.settings import api_settings</span><br><span class="line">		</span><br><span class="line">jwt_payload_handler &#x3D; api_settings.JWT_PAYLOAD_HANDLER</span><br><span class="line">jwt_encode_handler &#x3D; api_settings.JWT_ENCODE_HANDLER</span><br><span class="line"></span><br><span class="line">payload &#x3D; jwt_payload_handler(user)</span><br><span class="line">token &#x3D; jwt_encode_handler(payload）</span><br></pre></td></tr></table></figure>
              
          4. 根据以上思想形成真实代码示例:
           
           &gt; users.views.py
           
                   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       </span><br><span class="line">          from rest_framework.views import APIView</span><br><span class="line">from rest_framework_jwt.settings import api_settings</span><br><span class="line">from rest_framework.response import Response</span><br><span class="line">from django.contrib.auth import authenticate</span><br><span class="line">from .serializers import UserLoginSerializer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserLogin(APIView):</span><br><span class="line">    def post(self, request):</span><br><span class="line"></span><br><span class="line">        datas &#x3D; UserLoginSerializer(data&#x3D;request.POST)</span><br><span class="line">        if datas.is_valid():</span><br><span class="line">            user &#x3D; authenticate(**datas.validated_data)</span><br><span class="line">            if user:</span><br><span class="line">                jwt_payload_handler &#x3D; api_settings.JWT_PAYLOAD_HANDLER</span><br><span class="line">                jwt_encode_handler &#x3D; api_settings.JWT_ENCODE_HANDLER</span><br><span class="line"></span><br><span class="line">                payload &#x3D; jwt_payload_handler(user)</span><br><span class="line">                token &#x3D; jwt_encode_handler(payload)</span><br><span class="line">                return Response(token)</span><br><span class="line"></span><br><span class="line">        return Response(status&#x3D;401)</span><br><span class="line">	</span><br><span class="line">       </span><br></pre></td></tr></table></figure>
                   
               &gt; users.serializers.py
               
               <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     </span><br><span class="line">     from rest_framework import serializers</span><br><span class="line"></span><br><span class="line">class UserLoginSerializer(serializers.Serializer):</span><br><span class="line">    username &#x3D; serializers.CharField(max_length&#x3D;20,help_text&#x3D;&#39;用户名&#39;)</span><br><span class="line">    password &#x3D; serializers.CharField(max_length&#x3D;20,help_text&#x3D;&#39;密码&#39;)</span><br><span class="line">     </span><br></pre></td></tr></table></figure>
               
               
3. 利用JWT做注册接口

    1. 流程解析:
        1. 用户提交注册申请,也就是用户名密码
        2. 后端验证用户名是否存在,存在返回错误
        3. 生成用户
        4. 给生成的用户返回token 然后直接登录成功
        
    2. 代码解析:
    
        1. 接收用户的参数
        2. 验证用户名是否重复
        3. 生成用户
        4. 返回token
    
    3. 代码示例:
            &gt;users.views.py
            
           <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  class UserRegister(APIView):</span><br><span class="line"># 如果是post请求</span><br><span class="line">def post(self, request):</span><br><span class="line">    # 我们验证他的post数据,和序列化</span><br><span class="line">    datas &#x3D; UserLoginSerializer(data&#x3D;request.POST)</span><br><span class="line">    if datas.is_valid():</span><br><span class="line">        # 我们把验证成功的数据交给django验证</span><br><span class="line">        data &#x3D; datas.validated_data</span><br><span class="line">        # 获取用户model</span><br><span class="line">        User &#x3D; get_user_model()</span><br><span class="line">        # 获取用户信息</span><br><span class="line">        user &#x3D; User.objects.filter(username&#x3D;data[&#39;username&#39;])</span><br><span class="line">        # 如果有用户则不创建用户</span><br><span class="line">        if not user:</span><br><span class="line">            user &#x3D; User.objects.create_user(**data)</span><br><span class="line">            # 调用jwt官方指定的方法加密用户信息获取到token</span><br><span class="line">            jwt_payload_handler &#x3D; api_settings.JWT_PAYLOAD_HANDLER</span><br><span class="line">            jwt_encode_handler &#x3D; api_settings.JWT_ENCODE_HANDLER</span><br><span class="line">			</span><br><span class="line">            payload &#x3D; jwt_payload_handler(user)</span><br><span class="line">            token &#x3D; jwt_encode_handler(payload)</span><br><span class="line">            return Response(&#123;&#39;token&#39;: token&#125;)</span><br><span class="line">    # 如果失败,我们统一返回401表示登录不成功</span><br><span class="line">    return Response(status&#x3D;401)</span><br><span class="line">      </span><br></pre></td></tr></table></figure>
           
       还可以使用mixins去注册用户
&gt; users.views.py

        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line"># 通过mixin来创建用户</span><br><span class="line">from django.contrib.auth.hashers import make_password</span><br><span class="line">from django.contrib.auth import get_user_model</span><br><span class="line">from rest_framework import mixins</span><br><span class="line"></span><br><span class="line">User &#x3D; get_user_model()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserInfoSerializer(serializers.ModelSerializer):</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">略</span><br></pre></td></tr></table></figure>


           
4. 扩展注册接口
    1. 简介:我们的注册远没有那么多简单,我们需要手机注册,发送短信验证码。或者邮箱验证码之类的。然后填入验证码才能激活用户
    2. 为了防止爬虫,我们需要在下面多添加一个图形验证码。每次请求需要用户提交图形验证码系统才会执行发送短信的接口。
    3. 试想一个问题:
    
        1. 发送短信的原理其实就是我们首先去运营商那里购买短信服务,然后提交要送发的短信内容,和接收的短信的手机号。是运营商帮我们去发送短信。然后发送成功后,运营商通知我们短信发送成功。我们去通知用户。

        2. 上面那个流程有一个重大的bug,在上面的步骤中,请求运营商发送短信和等待运营商通知我们的服务器接收短信的时间是很长的。用户会一直卡在那里,程序也会一直卡在那里。如果运营商发送短信的时间很长,那么势必会卡死我们的程序线程。那么一个新开的网站,用户访问量大得时候,你是无法去承载这个网站的
        3. 这个时候,我们需要异步接口,即把发送短信请求或者发送邮箱请求的接口交给其他程序去做,我们不用理会,直接返给给用户申请成功。请求等待短信即可


        4. 画图解释
        
    4. 问题解决思路:
        1. 我们需要知道注册的具体流程:
        
            1. 首先 注册时候手机验证码是在后台生成的,然后存入数据库,但是要首先验证码账户是否存在
            2. 把这个验证码 通过一定的接口发送给用户
            3. 用户得到验证码之后,再把账户和验证码和密码一起提交,服务器收到验证码和用户名之后,对比数据库,如有符合的数据,就可以确认这个手机(收到验证码的手机)是这个用户的。
            4. 传统方式下 第一步第二步是链接在一起的
            5. 如果是异步接口,我们的程序只到第一步,第二步骤会有专门的程序去执行这个接口。
            6. 执行这个异步接口的实现方案是 队列任务,顾名思义,就是让发送验证码这个耗时的操作去让其他程序执行,如果其他程序执行不过来,那么发送验证码任务就会排队处理（在其他程序中,主程序已经结束）,但是这不会影响到用户体验,因为用户收到验证码这个时间本来就是耗时的。
            
    5. 代码思路:
        1. 接受用户账户的接口,验证账户是否已经存在
        2. 生成随机验证码的接口
        3. 请求发送验证码的接口
        4. 接受异步任务的接口
        5. 由于没有手机验证码,我们使用邮箱验证码做替代
        
    6. 基本代码实现 
    
       1. 传统的同步方式 没有图像验证码 发送接收一个邮箱,然后发送邮箱验证码,我们首先建立一个接受验证码的model 里面有邮件 验证码两个字段 外键添加时间判断验证码是否过期
       
          &gt;users.models.py
       
           <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">class CaptchaReg(models.Model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用户注册验证码</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    captcha &#x3D; models.CharField(max_length&#x3D;6, verbose_name&#x3D;&#39;验证码&#39;, help_text&#x3D;&#39;验证码&#39;)</span><br><span class="line">    email &#x3D; models.EmailField(verbose_name&#x3D;&#39;注册邮箱&#39;,help_text&#x3D;&#39;注册邮箱&#39;)</span><br><span class="line">    add_time &#x3D; models.DateTimeField(auto_now&#x3D;True, verbose_name&#x3D;&#39;添加时间&#39;, </span><br><span class="line">    help_text&#x3D;&#39;添加时间&#39;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name &#x3D; &#39;用户注册验证码&#39;</span><br><span class="line">        verbose_name_plural &#x3D; &#39;用户注册验证码&#39;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
           
       2. 我们使用createmixins来做view 因为我们相当于去创建一条验证码的数据
       3. 我们需要在serializer中改写captcha的方式,让captcha字段自动去生成,而且不是让用户传递过来

                  
             
      4. 我们还需要创建两个函数
     
          1. 一个是生成随机验证码的

              <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def gen_captcha():</span><br><span class="line">   captcha_str &#x3D; &quot;&quot;</span><br><span class="line">   for i in range(6):</span><br><span class="line">       captcha_str +&#x3D; str(random.randint(0, 9))</span><br><span class="line">   return captcha_str</span><br><span class="line"></span><br></pre></td></tr></table></figure>
          2. 把生成的随机验证码通过邮件发送

        5. 把生成验证码的函数放在serializer里面
            1. 知识点
                1. serializer里面的validate函数可以帮我们验证数据,并且把合法的数据传递给create函数去创建数据,由于我们没有定义captcha字段,但是又需要captcha字段去写入数据库,所以我们在validate里面取增加captcha 当然 增加的是我们函数调用的生成随机验证码
                
            
                    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">			    </span><br><span class="line">class UserRegisterCaptchaCreateSerializer(serializers.ModelSerializer):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    验证邮箱是否已经被注册了</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def create(self, validated_data):</span><br><span class="line">        email &#x3D; validated_data[&#39;email&#39;]</span><br><span class="line">        if User.objects.filter(email&#x3D;email).exists():</span><br><span class="line">            raise serializers.ValidationError(&#39;邮箱已经存在&#39;)</span><br><span class="line"></span><br><span class="line">        return super().create(validated_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def validate(self, attrs):</span><br><span class="line">        captcha &#x3D; captchas.gen_captcha()</span><br><span class="line">        attrs[&#39;captcha&#39;] &#x3D; captcha</span><br><span class="line">        return super().validate(attrs)</span><br><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure>
            
    
        6. 生成一个发送通过邮件发送验证码的接口:
            1. 知识点:
            
                1. smtp邮件服务器
                
                    1. smtp邮件服务器是一种协议
                    2. 我们可以调用网易的smtp邮件接口给其他人发邮件
                    3. 其实就相当于你去登录网易邮件手写一封邮件
                    4. 不过由于你有了邮件接口,你可以在程序中配置好账户密码 然后调用程序去帮你发送验证码。效果和3差不多
                2. 邮件发送接口调用
                    1. 查看自己的邮件接口
                        1. https://mail.163.com
                        2. 查看设置 最下面有pop3 smtp imap服务
                        3. 查看网易邮件服务的端口 http://help.163.com/09/1223/14/5R7P3QI100753VB8.html
                        4. 在settings.py里面去配置

                           &gt; mytest.settings.py

                                <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EMAIL_HOST &#x3D; &#39;smtp.163.com&#39;                   #SMTP地址</span><br><span class="line">EMAIL_PORT &#x3D; 25                                 #SMTP端口</span><br><span class="line">EMAIL_HOST_USER &#x3D; &#39;qq360167228@163.com&#39;       #我自己的邮箱</span><br><span class="line">EMAIL_HOST_PASSWORD &#x3D; &#39;rimi123&#39;                  #我的邮箱授权码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

                        5. 然后我们调用邮件函数就可以去发送,函数主要需要邮件标题,邮件内容,收件人的地址三个参数

                            1. 测试版本

                                &gt; mytest.test_mail.py

                                <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    # 外部启动django的方法</span><br><span class="line">    import sys, os</span><br><span class="line">    from django.core.wsgi import get_wsgi_application</span><br><span class="line"></span><br><span class="line">    base_dir &#x3D; </span><br><span class="line">    os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line">    sys.path.append(base_dir)</span><br><span class="line">    os.environ[&#39;DJANGO_SETTINGS_MODULE&#39;] &#x3D; </span><br><span class="line">    &#39;drf_movie_rimi.settings&#39;</span><br><span class="line">    </span><br><span class="line">    application &#x3D; get_wsgi_application()</span><br><span class="line"></span><br><span class="line">    from django.core.mail import send_mail</span><br><span class="line"></span><br><span class="line">    x &#x3D; send_mail(&#39;注册验证码&#39;, &#39;Here is the message.&#39;, </span><br><span class="line">    &#39;qq360167228@163.com&#39;,[&#39;qq360167229@163.com&#39;])</span><br><span class="line"></span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>

                            2. 正式版本:
                                
                                &gt;utils.send_sms_email.py

                                   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            		</span><br><span class="line">            		from django.core.mail import send_mail</span><br><span class="line">from drf_movie_rimi.settings import EMAIL_HOST_USER</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def my_send_mail(title, context, to_mail):</span><br><span class="line">    # 三个参数为 发送标题 内容 收件人</span><br><span class="line">    res &#x3D; send_mail(title, context, EMAIL_HOST_USER,</span><br><span class="line">                    [to_mail])</span><br><span class="line"></span><br><span class="line">    return bool(res)</span><br><span class="line"></span><br><span class="line">            		</span><br><span class="line">            		</span><br></pre></td></tr></table></figure>

                3. django注册发送验证码的流程

                    1. 知识点:
                    
                        1. 我们需要在整体流程的最后一步 也就是先发送验证码,发送验证码成功后,存储验证码到数据库,然后返回给用户发送成功信息。所以我们需要改写views里面的最后一步 perform_create 在这一步里面,views会存储合法数据到数据库。
                        2. 改写 serializers.py里面的validate 函数,由于我们只提供了email参数,所以我们必须把验证码(captcha加入进去)
                        3. 知识点梳理 

                            perform_create是createmixin里面的方法。他是在最后存储数据的时候调用
                            
                            validate 是serializer里面的方法,他控制了所有有效数据的,我们可以在这里面去改写有效数据
                        
                 
                    
                               
                    &gt;users.views.py
                    
                    
                    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...		</span><br><span class="line"></span><br><span class="line">class UserRegisterCaptchaCreateViewSet(CreateModelMixin, GenericViewSet):</span><br><span class="line">    queryset &#x3D; UserRegisterCaptchaCreateSerializer.Meta.model.objects.all()</span><br><span class="line">    serializer_class &#x3D; UserRegisterCaptchaCreateSerializer</span><br><span class="line"></span><br><span class="line">    def perform_create(self, serializer):</span><br><span class="line">        data &#x3D; serializer.validated_data</span><br><span class="line">        captcha &#x3D; &#39;您的验证码为&#123;&#125;&#39;.format(data[&#39;captcha&#39;])</span><br><span class="line">        res &#x3D; my_send_mail(&#39;注册验证码&#39;,captcha,data[&#39;email&#39;])</span><br><span class="line">        if not res:</span><br><span class="line">            return Response(status&#x3D;401)</span><br><span class="line">        return super().perform_create(serializer)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
        
        
                    &gt;users.serializers.py
                    
                    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">class UserRegisterCaptchaCreateSerializer(serializers.ModelSerializer):</span><br><span class="line">   &quot;&quot;&quot;</span><br><span class="line">   验证邮箱是否已经被注册了</span><br><span class="line">   &quot;&quot;&quot;</span><br><span class="line">					</span><br><span class="line">    def create(self, validated_data):</span><br><span class="line">        email &#x3D; validated_data[&#39;email&#39;]</span><br><span class="line">        if User.objects.filter(email&#x3D;email).exists():</span><br><span class="line">            raise serializers.ValidationError(&#39;邮箱已经存在&#39;)</span><br><span class="line"></span><br><span class="line">        return super().create(validated_data)</span><br><span class="line"></span><br><span class="line">    def validate(self, attrs):</span><br><span class="line">        captcha &#x3D; captchas.gen_captcha()</span><br><span class="line">        attrs[&#39;captcha&#39;] &#x3D; captcha</span><br><span class="line">        return super().validate(attrs)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; CaptchaReg</span><br><span class="line">        fields &#x3D; (&#39;email&#39;,)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
                    
            4. 通过mixins去做用户注册操作的版本
                &gt;users.serializers.py
                
                <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">					#验证码升级版##############</span><br><span class="line">class UserInfoSerializer(serializers.ModelSerializer):</span><br><span class="line"></span><br><span class="line">    # 这个步骤是专门给你用的,用于你去修改已经验证好的数据,大前提是你的数据通过验证了</span><br><span class="line">    # 才去做定制化</span><br><span class="line">    def validate(self, attrs):</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
                
                &gt;users.views.py
                
                <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class UserRegisterCaptchaCreateViewSet(CreateModelMixin, GenericViewSet):</span><br><span class="line">    queryset &#x3D; UserRegisterCaptchaCreateSerializer.Meta.model.objects.all()</span><br><span class="line">    serializer_class &#x3D; UserRegisterCaptchaCreateSerializer</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
        
                
        7. 升级版,使用队列异步发送代码 
        
            1. [首要步骤django-celery知识点](#django-celery)
            
        8. 继续升级邮箱验证码时间的验证
            1. 问题:
                1. 我们不能让一个邮箱才发送了一个邮件就又马上又发送,一般会有一分钟的间隔
                2. 验证码拿过来也是有时效的,一般5分钟内有效
                3. 如果一个验证码验证了,那么他就失效了
            2. 流程梳理:
            
                1. 如果你一个邮件发送后,他会有发送时间，我们规定，在1分钟之后才能发送
                2. 验证邮箱验证码时,我们永远去验证最新（时间）的验证码
                3. 如果验证码发送时间距离验证的时间超过五分钟，那么他也是无效的

            3. 代码实现:
            
                &gt;users.serializers.py
                
                    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class UserRegisterCaptchaCreateSerializer(serializers.ModelSerializer):</span><br><span class="line">		</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">     #验证是否是发送验证码过于频繁</span><br><span class="line">       expire_time &#x3D; timezone.now() -</span><br><span class="line">       timezone.timedelta(minutes&#x3D;EMAIL_CAPTCHA[&#39;delay_time&#39;][&#39;register&#39;])</span><br><span class="line">					</span><br><span class="line">       if CaptchaReg.objects.filter(email&#x3D;email,add_time__gt&#x3D;expire_time).exists():</span><br><span class="line">           raise serializers.ValidationError(&#39;请稍后再发送邮件&#39;)</span><br><span class="line">					</span><br><span class="line">       return super().create(validated_data)</span><br></pre></td></tr></table></figure>
                    
                &gt;users.settins.py
                    
                    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#邮箱验证码过期时间</span><br><span class="line"></span><br><span class="line">EMAIL_CAPTCHA &#x3D; &#123;</span><br><span class="line">    &#39;expire_time&#39;:&#123;</span><br><span class="line">       &#39;register&#39;:5</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#39;delay_time&#39;:</span><br><span class="line">        &#123;</span><br><span class="line">            &#39;register&#39;:1</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
                    
            4. 现在 用户注册的时候,需要把邮箱验证码提交给我们,通过了才能注册
                1.我们加入验证email password username captcha的四个字段的验证码程序
                2.email和capcha要在有效时间内找到才能通过,通过后 用户基本验证成功
            
                &gt;users.views.py
                
                <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class UserRegisterV2(APIView):</span><br><span class="line">    # 如果是post请求</span><br><span class="line">    def post(self, request):</span><br><span class="line">        # 我们验证他的post数据,和序列化</span><br><span class="line">        datas &#x3D; UserLoginV2Serializer(data&#x3D;request.POST)</span><br><span class="line">        if datas.is_valid():</span><br><span class="line">            # 我们把验证成功的数据交给django验证</span><br><span class="line">            data &#x3D; datas.validated_data</span><br><span class="line">            # 获取用户model</span><br><span class="line">            User &#x3D; get_user_model()</span><br><span class="line">            # 获取用户信息</span><br><span class="line">            user &#x3D; User.objects.filter(username&#x3D;data[&#39;username&#39;])</span><br><span class="line">            # 如果有用户则不创建用户</span><br><span class="line">            if user:</span><br><span class="line">                raise serializers.ValidationError(&#39;用户名重复&#39;)</span><br><span class="line"></span><br><span class="line">            # 验证验证码码是否正确</span><br><span class="line">            expire_time &#x3D; timezone.now() - </span><br><span class="line">            timezone.timedelta(minutes&#x3D;EMAIL_CAPTCHA[&#39;expire_time&#39;][&#39;register&#39;])</span><br><span class="line"></span><br><span class="line">            if not CaptchaReg.objects.filter(email&#x3D;data[&#39;email&#39;], </span><br><span class="line">            captcha&#x3D;data[&#39;captcha&#39;],add_time__gt&#x3D;expire_time).exists():</span><br><span class="line">                raise serializers.ValidationError(&#39;邮箱错误或验证码失效&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            user &#x3D; User.objects.create_user(**data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

            
        
5. JWT 升级登录接口        
    1. 我们登录接口需要验证用户名或者邮箱然后密码 合法就登录

        代码实现，我们需要把登录的合法用户取出来,然后给JWT加密 返回token信息
               <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		   		</span><br><span class="line">class UserLogin(APIView):</span><br><span class="line"> # 如果是post请求</span><br><span class="line"> def post(self, request):</span><br><span class="line">     # 我们验证他的post数据,和序列化</span><br><span class="line">     datas &#x3D; UserLoginSerializer(data&#x3D;request.POST)</span><br><span class="line">     if datas.is_valid():</span><br><span class="line">         # 我们把验证成功的数据交给django验证</span><br><span class="line">         user &#x3D; authenticate(**datas.validated_data)</span><br><span class="line">         if user:</span><br><span class="line">             # 调用jwt官方指定的方法加密用户信息获取到token</span><br><span class="line">             jwt_payload_handler &#x3D; api_settings.JWT_PAYLOAD_HANDLER</span><br><span class="line">             jwt_encode_handler &#x3D; api_settings.JWT_ENCODE_HANDLER</span><br><span class="line">					</span><br><span class="line">             payload &#x3D; jwt_payload_handler(user)</span><br><span class="line">             token &#x3D; jwt_encode_handler(payload)</span><br><span class="line">             return Response(&#123;&#39;token&#39;: token&#125;)</span><br><span class="line">     # 如果失败,我们统一返回401表示登录不成功</span><br><span class="line">     return Response(status&#x3D;401)</span><br><span class="line">		   		</span><br></pre></td></tr></table></figure>
               
</code></pre>
<h3 id="3-项目页面展示"><a href="#3-项目页面展示" class="headerlink" title="3.项目页面展示"></a>3.项目页面展示</h3><ol>
<li><p>项目需求分析:</p>
<ol>
<li><p>电影模型分析:</p>
<ol>
<li>首先我们需要一部影片信息的model 存储电影的信息</li>
<li>我们的电影有职员(演员 导演 编辑等等) 他们和电影是多对多</li>
<li>电影职员和类型也是对多对 比如马特达蒙 是演员 导演编辑</li>
<li>电影有所属国家 是多对多关系</li>
<li>电影有制作类型,比如2D, 3D等等 他和电影是对多对关系</li>
<li>电影有分类,比如动作,悬疑,科幻 他和电影是多对多关系</li>
</ol>
</li>
<li><p>影院模型分析:</p>
<ol>
<li>我们购买电影会细化到某个影院,某个座位,某个时间的电影</li>
<li>我们需要影院</li>
<li>我们的影院里面有很多影厅,他和影院是一对多关系</li>
<li>影厅中很多座位,他和影厅是一对多关系</li>
<li>我们电影有很多的片场,每个片场必须有一个影厅,他和影厅是一对多关系</li>
<li>影院有所属城市,他和影院是一对多关系</li>
</ol>
</li>
<li><p>根据上面的分析 我们的模型设计如下</p>
<pre><code> &gt;movie.model.py
</code></pre>
<p> 知识点:</p>
<ol>
<li>help_text 可以做描述文档使用</li>
<li>manytomanyfield  through 可以定制manytomany表</li>
</ol>
</li>
<li><p>合并 迁移数据, 把数据交给amdin后台管理</p>
</li>
</ol>
</li>
<li><p>数据的展示:</p>
<ol>
<li><p>添加了部分数据之后,我们需要把数据给展示出来,运用我们之间学习的知识,做一个电影的数据展示接口</p>
<p> 课堂练习: 1.做一个把所有电影列表展示出来的接口(get方法)</p>
</li>
<li><p>思路梳理:</p>
<ol>
<li>我们需要把数据库的里面的电影信息都展示出来,展示分为两种 一种是遍历一个列表 一种是获取一条数据的详细信息 我们一般来说 遍历只需要大致的信息,而获取详细信息需要更多的信息和关联信息比如演员 演员的相关文章等等</li>
<li>所以我们需要一个 view 一个url 两个serializer</li>
<li>views根据不同的请求 来给出不同的serializer展示信息</li>
</ol>
</li>
<li><p>代码实现(基础):</p>
<ol>
<li><p>我们获取详细信息的时候 我们需要 </p>
<ol>
<li>电影名</li>
<li>电影是否是热门电影</li>
<li>电影是否是最新电影</li>
<li>上映时间</li>
<li>电影类型</li>
<li>电影制片类型(2D,3D)</li>
<li>电影目前的状态(上映中 下架中等等)</li>
<li>电影的部分演员 导演</li>
<li>id号</li>
<li>点赞数量</li>
<li>影片长度</li>
<li>国家</li>
<li>分数(评级)</li>
<li>用户浏览数量<br>…</li>
</ol>
</li>
<li><p>但是我们获取列表的时候只需要</p>
<ol>
<li>电影名</li>
<li>电影想看次数</li>
<li>评分</li>
</ol>
<blockquote>
<p>movie.serializer.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from rest_framework import serializers</span><br><span class="line">	</span><br><span class="line">from .models import MovieDetail</span><br><span class="line">class MovieListSerializer(serializers.ModelSerializer):</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; MovieDetail</span><br><span class="line">        fields &#x3D; (&#39;name&#39;,&#39;status&#39;,&#39;user_want_num&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MovieDetailSerializer(serializers.ModelSerializer):</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; MovieDetail</span><br><span class="line">        fields &#x3D; &quot;__all__&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>movie.views.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from rest_framework import viewsets</span><br><span class="line"></span><br><span class="line">from .models import MovieDetail</span><br><span class="line"></span><br><span class="line">from .serializers import MovieListSerializer</span><br><span class="line">	</span><br><span class="line">class MovieViewSet(viewsets.ReadOnlyModelViewSet):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    获取电影信息接口</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    queryset &#x3D; MovieDetail.objects.all()</span><br><span class="line">    def get_serializer_class(self):</span><br><span class="line">        if self.action &#x3D;&#x3D; &#39;list&#39;:</span><br><span class="line">            return MovieListSerializer</span><br><span class="line">        if self.action &#x3D;&#x3D; &#39;retrieve&#39;:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>代码实现 高级</p>
<ol>
<li>通过上面的接口可以看到,很多数据是没有详细的信息的, 比如kind_category,他只有id号,但是没有具体的信息,我们需要获取这些具体的信息来返回给用户</li>
</ol>
<p>  知识点:</p>
<pre><code> 1. 我们需要遍历嵌套的序列化数据
 2. 我们可以通过加入其它的serializer到字段里面取,他就会自动的给我们遍历出嵌套的关系
 3. 如果是manytomany关系 我们需要定义参数 many=true

     &gt;movie.serializers.py
         
         
         <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from rest_framework import serializers</span><br><span class="line">			</span><br><span class="line">from .models import MovieDetail, MovieCountry, SubTitle, MovieStaff, MovieStaffCategory, </span><br><span class="line">MovieKindCategory,MovieTypeCategory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MovieListSerializer(serializers.ModelSerializer):</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; MovieDetail</span><br><span class="line">        fields &#x3D; (&#39;name&#39;, &#39;status&#39;, &#39;user_want_num&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MovieCountrySerializer(serializers.ModelSerializer):</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; MovieCountry</span><br><span class="line">        fields &#x3D; &quot;__all__&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SubTitleSerializer(serializers.ModelSerializer):</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; SubTitle</span><br><span class="line">        fields &#x3D; &quot;__all__&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MovieStaffSerializer(serializers.ModelSerializer):</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; MovieStaff</span><br><span class="line">        fields &#x3D; &quot;__all__&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MovieStaffCategorySerializer(serializers.ModelSerializer):</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; MovieStaffCategory</span><br><span class="line">        fields &#x3D; &quot;__all__&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MovieKindCategorySerializer(serializers.ModelSerializer):</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; MovieKindCategory</span><br><span class="line">        fields &#x3D; &quot;__all__&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MovieTypeCategorySerializer(serializers.ModelSerializer):</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; MovieTypeCategory</span><br><span class="line">        fields &#x3D; &quot;__all__&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MovieDetailSerializer(serializers.ModelSerializer):</span><br><span class="line">    movie_state &#x3D; MovieCountrySerializer(many&#x3D;True, read_only&#x3D;True)</span><br><span class="line">    sub_title &#x3D; SubTitleSerializer(many&#x3D;True, read_only&#x3D;True)</span><br><span class="line">    staffs &#x3D; MovieStaffSerializer(many&#x3D;True, read_only&#x3D;True)</span><br><span class="line">    kind_category &#x3D; MovieKindCategorySerializer(many&#x3D;True, read_only&#x3D;True)</span><br><span class="line">    type_category &#x3D; MovieTypeCategorySerializer(many&#x3D;True, read_only&#x3D;True)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; MovieDetail</span><br><span class="line">        fields &#x3D; &quot;__all__&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
         
         
</code></pre>
</li>
<li><p>我们需要统计用户点赞数量和打分情况</p>
<ol>
<li><p>新建点赞和打分情况的类视图(有打分和修改打分,有点赞和取消点赞)</p>
<p> 代码知识点:</p>
<pre><code> 1. 如果两个类都引用的话 会造成循环引用,所以使用第三方来操作两个类
 2. serializers 里面有 hiddenfields 可以隐藏我们需要的值,然后使用                  
 3. serializers.CurrentUserDefault() 可以取出当前用户
</code></pre>
<blockquote>
<p>user_movie_operations.models.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	from django.db import models</span><br><span class="line">from django.contrib.auth import get_user_model</span><br><span class="line"># Create your models here.</span><br><span class="line"></span><br><span class="line">from movie.models import MovieDetail</span><br><span class="line"></span><br><span class="line">User &#x3D; get_user_model()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserStarMovie(models.Model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用户对电影的评分,一个用户可以对多个电影评分,一部电影也可以拥有多个用户的评分,用户评分之后</span><br><span class="line">    就不能再去评分这个电影了</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    STAR &#x3D; (</span><br><span class="line">        (&#39;1&#39;, &#39;&#39;),</span><br><span class="line">        (&#39;2&#39;, &#39;&#39;),</span><br><span class="line">        (&#39;3&#39;, &#39;&#39;),</span><br><span class="line">        (&#39;4&#39;, &#39;&#39;),</span><br><span class="line">        (&#39;5&#39;, &#39;&#39;),</span><br><span class="line">        (&#39;6&#39;, &#39;&#39;),</span><br><span class="line">        (&#39;7&#39;, &#39;&#39;),</span><br><span class="line">        (&#39;8&#39;, &#39;&#39;),</span><br><span class="line">        (&#39;9&#39;, &#39;&#39;),</span><br><span class="line">        (&#39;10&#39;, &#39;&#39;),</span><br><span class="line">    )</span><br><span class="line">    user &#x3D; models.ForeignKey(User, verbose_name&#x3D;&#39;评论用户&#39;, help_text&#x3D;&#39;评论用户&#39;)</span><br><span class="line">    movie &#x3D; models.ForeignKey(MovieDetail, verbose_name&#x3D;&#39;所属电影&#39;, help_text&#x3D;&#39;所属电影&#39;)</span><br><span class="line">    star &#x3D; models.CharField(max_length&#x3D;2, choices&#x3D;STAR, </span><br><span class="line">    verbose_name&#x3D;&#39;用户对电影的评分&#39;, help_text&#x3D;&#39;用户对电影的评分&#39;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name &#x3D; &#39;用户评论一部电影&#39;</span><br><span class="line">        verbose_name_plural &#x3D; verbose_name</span><br><span class="line"></span><br><span class="line">        unique_together &#x3D; (&quot;user&quot;, &quot;movie&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserFavMovie(models.Model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用户点赞一个电影</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    user &#x3D; models.ForeignKey(User, verbose_name&#x3D;&#39;点赞用户&#39;, help_text&#x3D;&#39;点赞用户&#39;)</span><br><span class="line">    movie &#x3D; models.ForeignKey(MovieDetail, verbose_name&#x3D;&#39;所属电影&#39;, help_text&#x3D;&#39;所属电影&#39;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name &#x3D; &#39;用户评论一部电影&#39;</span><br><span class="line">        verbose_name_plural &#x3D; verbose_name</span><br><span class="line"></span><br><span class="line">        unique_together &#x3D; (&quot;user&quot;, &quot;movie&quot;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>user_movie_operations.serializers.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">	from rest_framework import serializers</span><br><span class="line">from django.contrib.auth import get_user_model</span><br><span class="line">from .models import UserStarMovie,UserFavMovie</span><br><span class="line"></span><br><span class="line">from movie.serializers import MovieListSerializer</span><br><span class="line"></span><br><span class="line">User &#x3D; get_user_model()</span><br><span class="line"></span><br><span class="line"># class UserStarMovieSerializer(serializers.ModelSerializer):</span><br><span class="line">#     model &#x3D; UserStarMovie</span><br><span class="line">#     fields &#x3D; &quot;__all__&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserFavMovieCreateSerializer(serializers.ModelSerializer):</span><br><span class="line">    user &#x3D; serializers.HiddenField(</span><br><span class="line">        default&#x3D;serializers.CurrentUserDefault()</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; UserFavMovie</span><br><span class="line">        fields &#x3D; (&quot;user&quot;,&quot;movie&quot;,&quot;id&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserFavMovieReadSerializer(serializers.ModelSerializer):</span><br><span class="line">    user &#x3D; serializers.HiddenField(</span><br><span class="line">        default&#x3D;serializers.CurrentUserDefault()</span><br><span class="line">    )</span><br><span class="line">    movie &#x3D; MovieListSerializer(many&#x3D;False)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; UserFavMovie</span><br><span class="line">        fields &#x3D; (&quot;user&quot;,&quot;movie&quot;,&quot;id&quot;)</span><br><span class="line">	</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<blockquote>
<p>user_movie_operations.views.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>在遍历电影的时候获取打分获取点赞数量<br> 简介: 我们已经可以让用户对电影打分和点赞,取消点赞了,但是我们需要在浏览电影的时候,把点赞数量和打分情况返回给我们的前端,我们需要在遍历电影的serializer里面做文章</p>
<pre><code>   1. 代码实现:
 
 &gt;movie.serializers.py
 
     <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db.models import Avg</span><br><span class="line">class MovieListSerializer(serializers.ModelSerializer):</span><br><span class="line">   fav_num &#x3D; serializers.SerializerMethodField(read_only&#x3D;True)</span><br><span class="line">   star_num &#x3D; serializers.SerializerMethodField(read_only&#x3D;True)</span><br><span class="line">				</span><br><span class="line">   def get_star_num(self, obj):</span><br><span class="line">       score &#x3D; UserStarMovie.objects.filter(movie&#x3D;obj).aggregate(Avg(&#39;star&#39;))</span><br><span class="line">       return round(score[&#39;star__avg&#39;],1)</span><br><span class="line">   def get_fav_num(self, obj):</span><br><span class="line">       return UserFavMovie.objects.filter(movie&#x3D;obj).count()</span><br><span class="line">				</span><br><span class="line">   class Meta:</span><br><span class="line">       model &#x3D; MovieDetail</span><br><span class="line">       fields &#x3D; (&#39;name&#39;, &#39;status&#39;, &#39;user_want_num&#39;, &#39;fav_num&#39;, &#39;star_num&#39;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
       6. 知识点:

 1. 我们可以在serializer里面取定义自定义字段方法,只需要继承SerializerMethodField方法,设置read_only = True,然后在下面写上关于他的函数,固定用法 get_xxxx ,serializer就会自动的帮我们使用自定义方法去约束字段信息
 
 
     &gt;serializers.SerializerMethodField(read_only=True)
 
 2. 我们使用了count(),方法去计算点赞的数量

 3. 我们使用了 aggregate 去做统计数据的平均值
 
</code></pre>
</li>
<li><p>使用缓存系统去升级我们的页面</p>
<ol>
<li>简介:每次请求我们都需要大量的计算用户点赞数量，打分的平均值如果请求数量过多,这势必是一个很大的开销,但是这些数据又是相对固定的,你不会每分钟都更新一次电影吧,所以我们需要在获取信息的页面增加缓存</li>
<li>web后台缓存原理:为什么要做缓存,缓存其实就是把数据存储在redis，或者文件系统中,你每次访问,我就把这个缓存的信息返给你,这样,我们就避免了查询数据库的过大开销</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="4-评论系统和权限控制"><a href="#4-评论系统和权限控制" class="headerlink" title="4.评论系统和权限控制"></a>4.评论系统和权限控制</h3><ol>
<li><p>简介:</p>
<p> 1.我们的电影下方带有评论,评论有对评论回复功能,显示回复评论功能,然后有评论的点赞行为<br> 2.用户可以去删除评论,修改评论,管理员看评论不当,也可以去删除评论,屏蔽用户发帖的功能</p>
</li>
<li><p>电影评论的基本实现:</p>
<ol>
<li><p>模型梳理:</p>
<ol>
<li>哪个用户去评论</li>
<li>评论哪一部电影</li>
<li>评论的内容</li>
<li>评论的时间</li>
<li>回复评论(也就是所外键是自己)</li>
</ol>
</li>
<li><p>模型代码实现:</p>
<p> 1.知识点: 在外键中 使用 ‘self’ 可以表示自己对应自己</p>
<blockquote>
<p>user_movie_opertions.models.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class UserMovieShortComments(models.Model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用户对一个电影进行评论</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    user &#x3D; models.ForeignKey(User, verbose_name&#x3D;&#39;评论用户&#39;, help_text&#x3D;&#39;评论用户&#39;)</span><br><span class="line">    movie &#x3D; models.ForeignKey(MovieDetail, verbose_name&#x3D;&#39;评论的电影&#39;, help_text&#x3D;&#39;评论的电影&#39;)</span><br><span class="line">    comments &#x3D; models.TextField(max_length&#x3D;255, verbose_name&#x3D;&#39;短评的内容&#39;, help_text&#x3D;&#39;短片的内容&#39;)</span><br><span class="line">    add_time &#x3D; models.DateTimeField(auto_now&#x3D;True, verbose_name&#x3D;&#39;评论的时间&#39;, help_text&#x3D;&#39;评论时间&#39;)</span><br><span class="line">    reply_to &#x3D; models.ForeignKey(&#39;self&#39;,verbose_name&#x3D;&#39;回复某个评论&#39;,</span><br><span class="line">    help_text&#x3D;&#39;回复某个评论也可以不回复&#39;,null&#x3D;True)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name &#x3D; &#39;用户对一个电影进行短评论&#39;</span><br><span class="line">        verbose_name_plural &#x3D; verbose_name</span><br><span class="line"></span><br><span class="line">        unique_together &#x3D; (&#39;user&#39;, &#39;movie&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>评论思路梳理:</p>
<ol>
<li>用户创建评论</li>
<li>用户可以修改评论(自己的)</li>
<li>用户可以删除评论(自己的)</li>
<li>用户可以查看所有评论(自己的)</li>
<li>用户可以查看评论的详细信息(自己的)</li>
</ol>
</li>
<li><p>评论代码实现:</p>
<ol>
<li><p>逻辑代码</p>
<blockquote>
<p>user_movie_opertions.views.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">	</span><br><span class="line">	class UserMovieShortCommentsViewSet(ModelViewSet):</span><br><span class="line">	    &quot;&quot;&quot;</span><br><span class="line">	    create:</span><br><span class="line">	        用户增加一条对电影的评论</span><br><span class="line">	    list:</span><br><span class="line">	        查看自己的所有短评</span><br><span class="line">	    retrieve:</span><br><span class="line">	        查看自己的一条短评</span><br><span class="line">	    update:</span><br><span class="line">	        修改自己的短评信息</span><br><span class="line">	    destroy:</span><br><span class="line">	        删除自己的评论信息</span><br><span class="line">	    &quot;&quot;&quot;</span><br><span class="line">	</span><br><span class="line">	    serializer_class &#x3D; UserMovieShortCommentsCreateSerializer</span><br><span class="line">	    queryset &#x3D; UserMovieShortCommentsCreateSerializer.Meta.model.objects.all()</span><br><span class="line">	    permission_classes &#x3D; (IsAuthenticated,)</span><br><span class="line">	</span><br><span class="line">	    def get_throttles(self):</span><br><span class="line">	        if self.action &#x3D;&#x3D; &quot;create&quot;:</span><br><span class="line">	            return [t() for t in (OncePerDayUserThrottle,)]</span><br><span class="line">	</span><br><span class="line">	&#96;&#96;&#96;		</span><br><span class="line">2. 限制用户的速度限速代码</span><br><span class="line"></span><br><span class="line">	&gt;user\_movie_opertions.throttles.py</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<pre><code> from rest_framework.throttling import UserRateThrottle

 
 class OncePerDayUserThrottle(UserRateThrottle):
     rate = &#39;10/minute&#39;
</code></pre>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">			</span><br><span class="line">3. 升级版,用户评论的权限控制逻辑</span><br><span class="line">	</span><br><span class="line">	1. 简介:</span><br><span class="line">		之前的代码逻辑为用户只能浏览自己的帖子,删除自己的帖子,修改自己的帖子。但是这样的代码逻辑过于简单,我们无法把这些评论交由专门的管理员去管理这些帖子。所以我们需要让某些管理员能够管理其他用户的帖子。这就不仅仅的需要判断一下帖子属于谁这么简单了。我们需要存储帖子的权限是什么,谁能够操控这些权限。</span><br><span class="line">	</span><br><span class="line">	2. 逻辑分析:</span><br><span class="line">	</span><br><span class="line">		1. 首先建立管理员组</span><br><span class="line">		2. 在发帖的时候对用户(个人)和管理员(组)授权</span><br><span class="line">		3. 授权内容为:</span><br><span class="line">			用户: 查看 删除 修改 这个篇帖子</span><br><span class="line">			管理员组: 查看 删除 这个篇帖子</span><br><span class="line">	    4. 用户发帖如果被设置为不能发帖的状态,用户就不能发帖</span><br><span class="line">	3. 代码实现:</span><br><span class="line">		</span><br><span class="line">		1.在创建帖子的时候去添加权限</span><br><span class="line">		&gt;user\_movie_operations.views.py</span><br><span class="line">		</span><br></pre></td></tr></table></figure></li>
</ol>
<p> class UserMovieShortCommentsViewSet(ModelViewSet):</p>
<pre><code> &quot;&quot;&quot;
 create:
     用户增加一条对电影的评论
 list:
     查看自己的所有短评
 retrieve:
     查看自己的一条短评
 update:
     修改自己的短评信息
 destroy:
     删除自己的评论信息
 &quot;&quot;&quot;

 serializer_class = UserMovieShortCommentsCreateSerializer
 queryset = UserMovieShortCommentsCreateSerializer.Meta.model.objects.all()
 permission_classes = (IsAuthenticated,)

 def perform_create(self, serializer):
     user = self.request._user
     group = Group.objects.get_or_create(name=&#39;site_managers&#39;)[0]
     #在创建这篇帖子的时候,授予权限
     #然后再在做操作的时候,查看验证有木有这个权限
     instance = serializer.save()
     assign_perm(&#39;change_usermovieshortcomments&#39;, user, instance)
     assign_perm(&#39;delete_usermovieshortcomments&#39;, user, instance)
     assign_perm(&#39;delete_usermovieshortcomments&#39;, group, instance)


 def get_throttles(self):
     if self.action == &quot;create&quot;:
         return [t() for t in (OncePerDayUserThrottle,)]
</code></pre>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. 在必要的时候去查看权限</span><br><span class="line">&gt;user_movie_operations.serialziers.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> class UserMovieShortCommentsCreateSerializer(serializers.ModelSerializer):</p>
<pre><code> # 创建短评论的用户
 user = serializers.HiddenField(
     default=serializers.CurrentUserDefault()
 )

 update = serializers.SerializerMethodField(read_only=True)
 delete = serializers.SerializerMethodField(read_only=True)

 def get_update(self, ins):
     user = self.context[&#39;request&#39;]._user

     return &#39;change_usermovieshortcomments&#39; in get_perms(user,ins)

 def get_delete(self, ins):
     user = self.context[&#39;request&#39;]._user
     return &#39;delete_usermovieshortcomments&#39; in get_perms(user,ins)

 class Meta:
     model = UserMovieShortComments
     fields = (&#39;id&#39;,&#39;user&#39;, &quot;movie&quot;, &quot;comments&quot;, &#39;reply_to&#39;,&#39;update&#39;,&#39;delete&#39;)
</code></pre>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		</span><br><span class="line">4.过多评论 我们需要给他分页,筛选评论</span><br><span class="line"></span><br><span class="line">&gt;参见 分页部分</span><br><span class="line"></span><br><span class="line">### 5. 支付功能的原理与实现</span><br><span class="line"></span><br><span class="line">1. 简介: 我们需要为网站加上支付的功能,他是网站能存活下去的基本</span><br><span class="line"></span><br><span class="line">2. 支付流程: </span><br><span class="line"></span><br><span class="line">	1. 用户在网站内选择想要的商品,点击支付功能</span><br><span class="line">	2. 网站后台先查看用户是否合法,商品是否还有剩余等等</span><br><span class="line">	3. 检查合格后,网站把用户想买的商品锁定起来,以免其他人来购买,并根据付款金额,商品,付款人生成流水号。</span><br><span class="line">	4. 第三步骤还不能成为订单号,因为这个时候用户还没有付款,所以我们需要占时的锁定这个商品。生成流水号,交给用户要支付的平台。</span><br><span class="line">	5. 支付平台会生成支付链接返回给网站后台</span><br><span class="line">	6. 网站后台把支付链接交给用户</span><br><span class="line">	7. 用户通过支付链接付款 </span><br><span class="line">	8. 付款完成后 平台会通过网站支付已经成功</span><br><span class="line">	9. 网站校验平台推送的支付成功信息,没有问题就会把商品交给用户</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	####路梳理</span><br><span class="line">	角色:</span><br><span class="line">	</span><br><span class="line">	    1. 用户</span><br><span class="line">	    2 .网站后台</span><br><span class="line">	    3. 支付平台</span><br><span class="line">	</span><br><span class="line">	 交互:</span><br><span class="line">	 </span><br><span class="line">	     1. 用户是在平台上面给钱,收钱的也是平台</span><br><span class="line">	     2. 平台是发送通知让后台知道用户已经给钱了</span><br><span class="line"></span><br><span class="line">3. 电影项目逻辑梳理:</span><br><span class="line"></span><br><span class="line">	1. 用户选中还没有锁定或者售出的电影座位（用户其实够买的是电影片场里面的座位）</span><br><span class="line">	2. 用户提交够买或者订购的申请</span><br><span class="line">	3. 系统再次检测座位是否被锁定住或者出售</span><br><span class="line">	4. 系统生成一个流水号(为什么叫流水号,因为这个时候用户还没有给钱,他可以取消不给钱,所以只是一个临时的订单叫做流水号） 流水号里面包含用户信息,订单价格,要购买的商品信息(座位)</span><br><span class="line">	5. 系统把这个流水号信息,和要支付的信息交给支付宝或者微信等第三方平台。第三方平台会生成一个支付链接,我们把这个支付链接转交给用户。</span><br><span class="line">	6. 用户一旦得到了支付链接之后,就会在网页或者app里面去跳转 然后支付</span><br><span class="line">	7. 平台收到用户支付的钱之后,会通知系统里面的一个收货接口。</span><br><span class="line">	8. 系统收到收货接口支付成功或者失败的通知之后,把商品正式的提交给那个用户</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">### &lt;span id&#x3D;&quot;django-celery&quot;&gt;5.缓存系统(django-cache)&lt;&#x2F;span&gt;		</span><br><span class="line"></span><br><span class="line">1. django 缓存简介:</span><br><span class="line">	1. django的缓存很灵活,你可以设置缓存到memcached,文件,数据库系统,也可以共享缓存</span><br><span class="line"></span><br><span class="line">2. 缓存分类设置:</span><br><span class="line"></span><br><span class="line">	1. Memcahed缓存:</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p> CACHES = {</p>
<pre><code> &#39;default&#39;: &#123;
     &#39;BACKEND&#39;: &#39;django.core.cache.backends.memcached.MemcachedCache&#39;,
     &#39;LOCATION&#39;: &#39;127.0.0.1:11211&#39;,
 &#125;
</code></pre>
<p> }</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">2. 数据库缓存:</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p> CACHES = {</p>
<pre><code> &#39;default&#39;: &#123;
     &#39;BACKEND&#39;: &#39;django.core.cache.backends.db.DatabaseCache&#39;,
     &#39;LOCATION&#39;: &#39;my_cache_table&#39;,
 &#125;
</code></pre>
<p> }</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建缓存表,使用数据库缓存之前，你必须用这个命令来创建缓存表：</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p> python manage.py createcachetable</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3. 文件系统:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> CACHES = {</p>
<pre><code> &#39;default&#39;: &#123;
     &#39;BACKEND&#39;: &#39;django.core.cache.backends.filebased.FileBasedCache&#39;,
     &#39;LOCATION&#39;: &#39;/var/tmp/django_cache&#39;,
 &#125;
</code></pre>
<p> }</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">4. 缓存时间全局设置:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  ‘TIMEOUT’: 60</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		</span><br><span class="line">3. 缓存函数视图</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">	1. 使用函数视图 加上装饰器,查看页面是否会缓存</span><br><span class="line">	</span><br><span class="line">		&gt;my\_test.cache_view.py</span><br><span class="line">		</span><br><span class="line">		在装饰器后面加上cache_page(10) 表示缓存10秒</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<pre><code> from django.views.decorators.cache import cache_page
 @cache_page(10)
 def cache_view(request):
     pass
</code></pre>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">			</span><br><span class="line">2. 同时 我们也可以在url上面加上缓存</span><br><span class="line"></span><br><span class="line">	&gt;my\_test.urls.py</span><br><span class="line">		   </span><br><span class="line">		   </span><br></pre></td></tr></table></figure>
<pre><code>    from django.views.decorators.cache import cache_page
    ...
    url(r&#39;^test13/$&#39;,cache_page(10)(cache_view))
    
</code></pre>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">4. django-redis缓存:</span><br><span class="line">		通过这个设置开启redis缓存功能</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<p> CACHES = {</p>
<pre><code> &#39;default&#39;: &#123;
     &#39;BACKEND&#39;: &#39;django_redis.cache.RedisCache&#39;,
     &#39;LOCATION&#39;: &#39;redis://your_host_ip:6379&#39;,
     &quot;OPTIONS&quot;: &#123;
         &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;,
          &quot;PASSWORD&quot;: &quot;yoursecret&quot;,
     &#125;,
 &#125;,
</code></pre>
<p> }</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		</span><br><span class="line">	1. 使用redis-cli去查看缓存的数据</span><br><span class="line">	2. 查看redis中的key</span><br><span class="line">	</span><br><span class="line">5. 高级缓存配置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	1. TIMEOUT 全局缓存时间设置</span><br><span class="line">	2. OPTIONS:</span><br><span class="line">		</span><br><span class="line">		1. MAX_ENTRIES:高速缓存允许的最大条目数，超出这个数则旧值将被删除. 这个参数默认是300.</span><br><span class="line">		2. CULL_ENTRIES:当达到MAX_FREQUENCY 的时候,被删除的条目比率。 实际比率是 1 &#x2F; CULL_FREQUENCY, 所以设置CULL_FREQUENCY 为2会在达到MAX_ENTRIES 所设置值时删去一半的缓存。 这个参数应该是整数，默认为 3.</span><br><span class="line">		</span><br><span class="line">		 把 CULL_FREQUENCY的值设置为 0 意味着当达到MAX_ENTRIES时,缓存将被清空。 某些缓存后端 (database尤其)这将以很多缓存丢失为代价,大大 提高接受访问的速度。</span><br><span class="line">		 </span><br><span class="line">		3. KEY_PREFIX: 缓存的key的开头</span><br><span class="line">		4. KEY_FUNCTION:一个字符串，其中包含一个函数的虚线路径，该函数定义了如何将前缀，版本和密钥组合成最终缓存密钥。</span><br><span class="line">		5. VERSION：由Django服务器生成的缓存键的默认版本号。</span><br><span class="line">	</span><br><span class="line">	3. 实际的示例</span><br><span class="line">	</span><br></pre></td></tr></table></figure></li>
</ol>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6. drf_extension缓存配置</span><br><span class="line">	1. 库简介: drf_extension是一个drf的扩展库,它带有对view的扩展和缓存的扩展</span><br><span class="line">	2. 使用的必要条件: 必须是继承了 APIView的类才能使用</span><br><span class="line">	3. CacheResponseMixin 类视图的缓存</span><br><span class="line">		1. 他一般会缓存 get方法</span><br><span class="line">		2. 使用方法</span><br><span class="line">			</span><br><span class="line">	</span><br><span class="line">	4. 配置简介</span><br><span class="line"></span><br><span class="line">		1. DEFAULT_CACHE_RESPONSE_TIMEOUT全局设置缓存的时间</span><br><span class="line">		2. DEFAULT_USE_CACHE 选择使用哪个缓存方式去缓存,一搬不会写</span><br><span class="line">		3. </span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<pre><code> REST_FRAMEWORK_EXTENSIONS = &#123;
     &#39;DEFAULT_CACHE_RESPONSE_TIMEOUT&#39;: 60 * 15
     &#39;DEFAULT_USE_CACHE&#39;: &#39;special_cache&#39;
 &#125;
 
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">5. 使用方式:</span><br><span class="line">	</span><br><span class="line">	&gt;mytest.cache_view.py</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
     from rest_framework_extensions.cache.mixins import CacheResponseMixin
     class BookViewSet(CacheResponseMixin,viewsets.ReadOnlyModelViewSet):


 queryset = Book.objects.all()
 serializer_class = BookSerializer
 
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">7. drf_extension配置深度解析</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">### &lt;span id&#x3D;&quot;django-celery&quot;&gt;5.队列任务(django-celery)&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">1. 队列任务的基础概念:</span><br><span class="line">    1. 高并发环境下，由于来不及同步处理，我们需要把这些东西交给一套系统去排队处理。这样不会导致我们主程序卡死,从而不能接受请求，出现大面积404</span><br><span class="line">    2. 画图解释队列架构</span><br><span class="line">    </span><br><span class="line">2. 队列任务的实现方式:</span><br><span class="line">    1. 我们以django celery为例:</span><br><span class="line">        1. 调度器:就是我们的django-celery 他去调用这些任务的执行,我们存储任务执行的结果</span><br><span class="line">        2. 任务执行器:我们发送邮件的函数就是一个任务执行器,celery可以去调度他执行发送邮件的任务。也可以在任务较多的时候。然他排队去执行。</span><br><span class="line">        3. 消息中间件: 我们把一个任务交给了任务执行器。但是任务多久完成，我们是不知道的。他可能在排队,也可能执行失败。也可能执行成功。我们需要一个东西去存储他目前的状态。通用的消息中间件有 redis rabbitMQ。</span><br><span class="line">    2. 队列任务大致流程梳理:</span><br><span class="line">        1. 把发送邮件的任务交给django-celery处理,并把调用任务的变量传递给django-celery</span><br><span class="line">        2. django-celery把这个任务给定一个唯一任务id号,然后存储到消息中间件中(这里我们用redis)</span><br><span class="line">        3. django-celery 把这个任务排队,等到能执行这个任务的时候，他去调用我们发送邮件程序去发送邮件</span><br><span class="line">        4. 当任务执行成功或者失败他都会把这个消息存入到我们的消息中间件中.</span><br><span class="line"></span><br><span class="line"> 3. django-celery:</span><br><span class="line"> </span><br><span class="line">     1. 安装 celery</span><br><span class="line">     </span><br><span class="line">     		第一个安装 celery 第二个安装 python redis 让python能使用redis 第三个安装celery的任务执行结果存储地区</span><br><span class="line">     		</span><br></pre></td></tr></table></figure>
          pip install celery
          pip install redis
          pip install django-celery-results
          
      
      <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">2. 使用redis作为消息中间件,安装redis</span><br><span class="line">	</span><br><span class="line">		[redis安装使用相关知识点](#redis)</span><br><span class="line">		</span><br><span class="line">3. django中配置celery</span><br><span class="line"></span><br><span class="line">    1. 在配置文件下面新加celery.py</span><br><span class="line"></span><br><span class="line">   		</span><br><span class="line">   	</span><br><span class="line">    </span><br><span class="line">    		&gt; drf\_movie_rimi.celery.py</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
         from __future__ import absolute_import, unicode_literals
         import os
         from celery import Celery
         
         # set the default Django settings module for the &#39;celery&#39; program.
         os.environ.setdefault(&#39;DJANGO_SETTINGS_MODULE&#39;, &#39;drf_movie_rimi.settings&#39;)
         
         #启动项目的名字 最好和项目名字一样 broker中间件  backend 存储结果的地方
         app = Celery(&#39;drf_movie_rimi&#39;,
                      broker=&#39;redis://localhost:6379&#39;,
                      backend=&#39;redis://localhost:6379&#39;
         
                      )
         
         #在redis中以CELERY
         app.config_from_object(&#39;django.conf:settings&#39;, namespace=&#39;CELERY&#39;)
         
         #使celery能够读取到所有apps里面分配的任务
         app.autodiscover_tasks()
</code></pre>
</li>
</ol>
<pre><code>         <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">2. drf\_movie_rimi.settings.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
          
          INSTALLED_APPS = [
                    ...
                &#39;django_celery_results&#39;,
            ]
            
            ...
            
            CELERY_RESULT_BACKEND = &#39;django-db&#39;
          <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">安装好app之后做迁移</span><br><span class="line"></span><br></pre></td></tr></table></figure>
          makemigrations
          migrate
          <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      </span><br><span class="line">3. 在项目配置的init.py里面加入启动文件</span><br><span class="line"></span><br><span class="line">	drf\_movie_rimi.__init__.py</span><br><span class="line">  				</span><br></pre></td></tr></table></figure>
              
              from __future__ import absolute_import, unicode_literals

            # This will make sure the app is always imported when
            # Django starts so that shared_task will use this app.
            from .celery import app as celery_app
            
            __all__ = (&#39;celery_app&#39;,)
              
              <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         </span><br><span class="line">4. 启动和使用celery</span><br><span class="line"></span><br><span class="line">	1. 启动django</span><br><span class="line">	2. 在命令行中启动celery</span><br><span class="line">		        </span><br><span class="line">          &gt;启动命令 虚拟环境下 项目目录下执行</span><br><span class="line">          </span><br></pre></td></tr></table></figure>
              celery -A drf_movie_rimi worker -l info 
              <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     </span><br><span class="line">3. 把我们的发送邮件任务转移给celery去执行</span><br><span class="line"></span><br><span class="line">	   1. 按照固定用法引入包</span><br><span class="line">	   2. 在函数前面加入@shared_task装饰器来使他成为队列任务</span><br><span class="line"></span><br><span class="line">     &gt;users.tasks.py</span><br><span class="line">     </span><br></pre></td></tr></table></figure>
              
                 # Create your tasks here
                    from __future__ import absolute_import, unicode_literals
                    from celery import shared_task
                    from utitls import send_sms_email
                    
                    ...
                    
                    
                    @shared_task
                    def reg_send_mail(title, context, to_mail):
                        res = send_sms_email.my_send_mail(title, context, to_mail)
                    
                        success_context = &#39;向&#123;&#125;邮箱发送注册验证码成功,信息内容:&#123;&#125;&#39;.format(to_mail, context)
                        fail_context = &quot;向&#123;&#125;发送邮箱验证码失败&quot;.format(to_mail)
                    
                        if res == 1:
                            return success_context
                        return fail_context

              <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3. 在views里面去调用队列,引入我们刚才的队列函数,使用xxx.delay()去唤醒他</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&gt; users.views.py</span><br></pre></td></tr></table></figure>
                     
                    class UserRegisterCaptchaCreateViewSet(CreateModelMixin, GenericViewSet):
                        queryset = UserRegisterCaptchaCreateSerializer.Meta.model.objects.all()
                        serializer_class = UserRegisterCaptchaCreateSerializer
                    
                        def perform_create(self, serializer):
                            data = serializer.validated_data
                            captcha = &#39;您的验证码为&#123;&#125;&#39;.format(data[&#39;captcha&#39;])
                            #res = my_send_mail(&#39;注册验证码&#39;,captcha,data[&#39;email&#39;])
                            reg_send_mail.delay(&#39;注册验证码&#39;,captcha,data[&#39;email&#39;])
                            
                            ...
                     
                     <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		            	 </span><br><span class="line">		        4. 在我们的admin后台去查看结果</span><br><span class="line"></span><br><span class="line">		5. 总结：</span><br><span class="line">		</span><br><span class="line">			1. 队列任务是一个抽象概念</span><br><span class="line">			2. 队列任务的标准是叫你去实现 </span><br><span class="line">				1. 调度队列的程序(celery) </span><br><span class="line">				2. 消息中间件-broker(redis)</span><br><span class="line">				3. 执行结果存储器 backend (mysql或者redis)</span><br><span class="line">			3. celery只是python里面去实现了队列的程序,当然你可以自己写,java那些也有自己的程序			</span><br><span class="line">   				</span><br><span class="line"></span><br><span class="line">   			</span><br><span class="line">   			</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">### &lt;span id&#x3D;&quot;redis&quot;&gt;6.redis&lt;&#x2F;span&gt;   </span><br><span class="line"></span><br><span class="line">1. redis的简介:</span><br><span class="line">	1. redis是一个nosql数据库</span><br><span class="line">	2. redis他是一个存在于内存上面的数据库</span><br><span class="line">	3. redis他有时候会用来做缓存</span><br><span class="line">	4. nosql数据库一张表只能有一个特定的用途</span><br><span class="line"></span><br><span class="line">2. redis的安装:</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">3. redis的配置,他的软件的用法</span><br><span class="line"></span><br><span class="line">	1. Makefile: make &amp;&amp; make install的安装依据文档,如果你安装出问题的话,就可以去找个文件</span><br><span class="line">	2. redis.conf 配置文件</span><br><span class="line">	3. sentinel.conf 我们redis 哨兵,高可用配置,如果reids崩掉的话,监听,然后做出决策</span><br><span class="line">	4. 文件夹 src:</span><br><span class="line">		1. redis-benchmark redis的压测工具</span><br><span class="line">		2. redis-server redis-cli redis服务器 reids客户端</span><br><span class="line">		3. redis-sentinel 启动我们的哨兵</span><br><span class="line">	5. 配置文件（redsi.conf）:</span><br><span class="line">		1. bind 127.0.0.1  启动的监听ip 一般监听内网ip</span><br><span class="line">		2. port 6379 监听端口 一般会改掉</span><br><span class="line">		3. masterauth &lt;master-password&gt; 主从备份密码 主的密码 等于你主机 requirepass 前提是你配置了 slaveof</span><br><span class="line">		4. requirepass redis密码</span><br><span class="line">		5. slaveof 127.0.0.1 6379 配置主从 主的ip和端口 让自己成为slaveof（从库）</span><br><span class="line">		7. dump.rdb redis的持久化数据</span><br><span class="line">		8. save 60 10000 表示 60秒之内 你有大于等于10000次数据变化,他就会给你存储到rdb(硬盘)上面</span><br><span class="line">		9. redis有两种存储方式, 一种是rdb 一种是 aof 默认是rdb</span><br><span class="line">			1. rdb的原理是一段时间内把你磁盘的镜像存储下来(思考git) 坏处是:发生灾难,灾难的期间的数据是没有的 比如你 12.00保存了数据 12.00：30秒发生灾难, 30秒的数据就没有了</span><br><span class="line">			2. aof 存储 append only 原理是把你每一次数据库的变化记录下来，恢复数据的时候,根据你每次的变化来推演。 好处: 发生灾难了数据很会很小。坏处:无法达到性能或者是很耗性能</span><br><span class="line">		10. 数据过期命令:</span><br><span class="line">			expire value second 给一个key设置过期时间,完成之后就被删除</span><br><span class="line">			最主要的地方用在缓存数据上面</span><br><span class="line">			</span><br><span class="line">			ttl key可以去看他有还有多少的寿命</span><br><span class="line">			</span><br><span class="line">		</span><br><span class="line">	6. redis命令:</span><br><span class="line">		-h hostip</span><br><span class="line">		-p 端口</span><br><span class="line">		-a 密码</span><br><span class="line">		tips:如果你的密码错误,你是可以链接的,但是你无法看到数据</span><br><span class="line">		链接命令: src&#x2F;redis-cli -h 192.168.0.169 -p 16379 -a rimi12345678</span><br><span class="line">	</span><br><span class="line">	7. redis的数据库结构:</span><br><span class="line">		1. 前提</span><br><span class="line">			1. 大前提 redis 数据库结构是基于nosql的 所以的数据库都是 key value</span><br><span class="line">			2. 没有主键和外键 比如设了外键,主键被删了之后,他的没有任何影响</span><br><span class="line">			3. 表于表之间没有任何关系 </span><br><span class="line">		2. 数据结构:</span><br><span class="line">			1. string 字符串 key value 存储字符串和数字 </span><br><span class="line">				命令: </span><br><span class="line">					1. set 设置key和value</span><br><span class="line">					2. get 获取key所代表的value</span><br><span class="line">					3. incr 自增1</span><br><span class="line">					4. decr 自减1</span><br><span class="line">					5. incrby key num </span><br><span class="line">					6. decrby </span><br><span class="line">			2. hash 散列表:</span><br><span class="line">				1. 相当于一个 dict 但是只有一层</span><br><span class="line">				  命令:</span><br><span class="line">				  	hset 设置一个散列表 hset person1 name luhan age 25 gender renyao</span><br><span class="line">				  	hgetall key 获取hash里面的所有key value</span><br><span class="line">				  	</span><br><span class="line">				  	hmget key field1 field2 ... 获取执行的value  hmget person1 name age</span><br><span class="line">				  	hmset key fiels value 精准的修改hash表(已经存在)里值,没有就会新建</span><br><span class="line">				  	</span><br><span class="line">				  2. 性能优化:</span><br><span class="line">				 		1. 一般不会用hash表,我们用string表来代替他（存入json）</span><br><span class="line">						2. 或者他推荐我们去使用 hgetall命令,少用hmget</span><br><span class="line">				</span><br><span class="line">			3. zset 有序集合:</span><br><span class="line">			</span><br><span class="line">				1. 是一个有排名的集合数据，每一条数据他都有排名:</span><br><span class="line">				</span><br><span class="line">				2. 命令：</span><br><span class="line">					1. 添加数据: zadd key score value 给定数据的分数</span><br><span class="line">					2. 取出数据并且排名: ZREVRANGE hackers 0 -1 withscores</span><br><span class="line">						1. withscores 会把分数一并的给你显示出来</span><br><span class="line">					3. zcard value 统计我们的集合里面的数据量</span><br><span class="line">					4. zscore value key 取出某个key的分数</span><br><span class="line">					5. zrem value key  移除某个分数</span><br><span class="line">			4. set 无序结合:</span><br><span class="line">				</span><br><span class="line">				1. 是一个无需集合:</span><br><span class="line">				</span><br><span class="line">					2.命令:</span><br><span class="line">						1. sadd key value1 value2 .... 添加值到我们的集合里面去</span><br><span class="line">						2. smembers key 获取集合里面的信息</span><br><span class="line">						3. scard key 获取集合的数据</span><br><span class="line">						4. sdiff 集合的差集</span><br><span class="line">			5. list 双向列表结构:</span><br><span class="line">			</span><br><span class="line">				1. 他是双向列表,他可以把数据从左边或者右边压入,压入之后可以左右弹出</span><br><span class="line">				2. 可以用这个来做队列任务</span><br><span class="line"></span><br><span class="line">				</span><br><span class="line">			6. eval redis脚本:</span><br><span class="line">			</span><br><span class="line">				执行脚本可以保证你的数据的一致性</span><br><span class="line">				</span><br><span class="line">				script表示的是lua脚本:</span><br><span class="line">				</span><br><span class="line">					1. lua申明变量需要local</span><br><span class="line">					2. lua拼接字符串需要 ..</span><br><span class="line">					3. 调用脚本的时候 使用 redis.call() 跟你的命令</span><br><span class="line">					4. keys args相当于传递参数进去，在脚本里面大写入KEYS[1]</span><br><span class="line">					</span><br></pre></td></tr></table></figure>
            def new_user():
                script = &quot;&quot;&quot;
                    local user_id = redis.call(&quot;incr&quot;, KEYS[1])
                    local hash_table_name = &quot;user:&quot;..user_id
                    redis.call(&quot;zadd&quot;,&quot;user_set&quot;,user_id,hash_table_name)
                    redis.call(&quot;hmset&quot;,hash_table_name,&quot;name&quot;,user_id)
                &quot;&quot;&quot;
                script1 = r.register_script(script)
                x = script1(keys=[&quot;user_id&quot;], args=[])
            
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">6. pipeline:</span><br><span class="line">	可以帮我们加速redis执行效率,一次性执行所有的所有操作</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
                with r.pipeline() as p:
                    for i in range(100000):
                        user_id = p.incr(&#39;user_id&#39;)
                        hash_table_name = &quot;user:&#123;&#125;&quot;.format(user_id)
                        p.zadd(&#39;user_set&#39;, user_id, hash_table_name)
                        p.hmset(hash_table_name, &#123;&quot;name&quot;: &quot;user:&#123;&#125;&quot;.format(user_id), &#39;password&#39;: 
                        &#39;rimiaaa&#123;&#125;&#39;.format(user_id)&#125;)
                    p.execute()
                            
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">				</span><br><span class="line">		1. 实验：设计一张表:</span><br><span class="line"></span><br><span class="line">			要求: 使用redis来做用户表</span><br><span class="line">			</span><br><span class="line">			    1. 存入账户密码</span><br><span class="line">			    2. 用户新建之后,id自增</span><br><span class="line">			    3. 可以查看到所有的用户</span><br><span class="line">			    4. 可以统计用户的数量</span><br><span class="line">		</span><br><span class="line">			mytest.redis_test.py</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 8.django-gurdian 控制用户权限的逻辑</span><br><span class="line"></span><br><span class="line">1. 简介:</span><br><span class="line">	  1. 他是django第三方权限管理扩展库</span><br><span class="line">	  2. 为什么要使用权限管理系统?我们参考一下百度贴吧,你发的帖子会被管理员删除掉,当然你自己也可以删除掉自己的帖子,但是你是不能删除其他人或者管理员发出的帖子的。这就是一个典型的权限管理系统</span><br><span class="line">	  3. RBAC-&gt;刚才所讲的问题我们可以通过RBAC模型去解决,RBAC的全称为 role-based access control,即基于角色的访问控制。</span><br><span class="line">	  4. 那其实我们刚才的那个问题就可以化解为授予权限,和在要使用权限的时候去检查这个用户是否有权限。</span><br><span class="line">	  5. django-guradian是一个实现了rabc模型的强大工具,它是专门扩展django权限管理的第三方库。</span><br><span class="line">	  6. 具有授予,删除,查看权限等等丰富的功能</span><br><span class="line">	  7. 官网: http:&#x2F;&#x2F;django-guardian.readthedocs.io&#x2F;en&#x2F;latest&#x2F;</span><br><span class="line">	  8. 他是对象级别的权限控制</span><br><span class="line">	  9. django是model级别的权限控制</span><br><span class="line"></span><br><span class="line">2. 安装:</span><br><span class="line">	  1. 库安装</span><br><span class="line">	  </span><br></pre></td></tr></table></figure>
  $ pip install django-guardian
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. 把guardian放入django的apps里面</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
      INSTALLED_APPS = (
     ...
     &#39;guardian&#39;,
    )
  
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	  </span><br></pre></td></tr></table></figure>
  $ pip install django-guardian
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3. api使用规范:</span><br><span class="line">	1. 权限授予: guardian.shortcuts.assign_perm(perm, user_or_group, obj&#x3D;None) </span><br><span class="line">	</span><br><span class="line">	2. 权限查看:guardian.shortcuts.get_perms(user_or_group, obj)—返回一个用户给这个对象权限的list,其实就是一个含有perm的list</span><br><span class="line">	</span><br><span class="line">	3. 参数说明: perm要授予的权限(删除或者修改权限),user_or_group授予权限的用户或者用户组(用户),obj被操控的对象(博文</span><br><span class="line">	4. 在model中加入权限: model的Meta里面可以加扩展permissons,这个扩展的permissions就是上面perm参数</span><br><span class="line"></span><br><span class="line">4. 实现我们的逻辑代码:</span><br><span class="line">	1. 我们这个时候就需要给用户分组了 </span><br><span class="line">		1. 普通用户 （使用普通的网站功能）</span><br><span class="line">		2. 网站管理员 （管理用户回复评论中的帖子,删帖,修改用户帖子,屏蔽用户发帖）</span><br><span class="line">		3. 系统管理员 (添加或者删除网站管理员)</span><br><span class="line">	2. 用户发帖之后,帖子是一个对象,所以我们的授权就应该在这个时候去完成</span><br><span class="line">		1. 删除权限</span><br><span class="line">		2. 修改权限</span><br><span class="line">		3. 授予网站管理员和发帖用户这个权限</span><br><span class="line"></span><br><span class="line">5. 底层原理:</span><br><span class="line">	其实是数据库的中数据的记录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 9.pagination django的分页</span><br><span class="line">1. 简介 如果页面的数据过多,那么我们不能在页给他显示完成,我们可以采用分页显示数据,减少数据库压力</span><br><span class="line">2. 实现分页所需要的部件:</span><br><span class="line">	最大数据量 返回给前端表示我们有多少的数据量</span><br><span class="line">	每页数据量 返回给前端每页能显示多少的数据量 当然这个可以修改</span><br><span class="line">	当前页面页码 让前端知道当前在哪个页面上面</span><br><span class="line">3. django中的分页配置:</span><br><span class="line"></span><br><span class="line">    1. 全局默认配置 当我们配置好了之后,会在list页面看到我们的分页信息</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
    
    REST_FRAMEWORK = &#123;
            ...
        
            &#39;DEFAULT_PAGINATION_CLASS&#39;: &#39;rest_framework.pagination.LimitOffsetPagination&#39;,
            &#39;PAGE_SIZE&#39;: 10
&#125;
    
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. 定制化分页配置</span><br><span class="line"></span><br><span class="line">	参数解释:</span><br><span class="line">		1. page_size 默认每页个数</span><br><span class="line">		2. page_size_query_param 在url里面去设置每页个数</span><br><span class="line">		3. max_page_size 每页最大的个数 page_size_query_param最大值不能超过他</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    
    
    from rest_framework.pagination import PageNumberPagination
    
    class LargeResultsSetPagination(PageNumberPagination):
        page_size = 10
        page_size_query_param = &#39;page_size&#39;
        max_page_size = 100
        
        
    class MovieShortCommentsReadAllViewSet(ListModelMixin,GenericViewSet):
        &quot;&quot;&quot;
        查看相关电影的所有评论,并且返回可以管理这条评论
        &quot;&quot;&quot;
        serializer_class = UserMovieShortCommentsCreateSerializer
        queryset = UserMovieShortCommentsCreateSerializer.Meta.model.objects.all()
    
        pagination_class = LargeResultsSetPagination
    
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 10.django-filter 筛选数据</span><br><span class="line">1. 简介:</span><br><span class="line"></span><br><span class="line">2. django-filter使用方法:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	1. 在drf中使用filter去搜索或者排序数据</span><br><span class="line">		用法: 1.我们使用 filters去激活 filter_backends让他拥有搜索和排序的功能,然后我们给定搜索和排序的位置即可</span><br><span class="line">		</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
    
    from rest_framework import filters
    class MovieViewSet(mixins.ListModelMixin,mixins.RetrieveModelMixin,mixins.
    UpdateModelMixin,viewsets.GenericViewSet):
        &quot;&quot;&quot;
        获取电影信息接口
        &quot;&quot;&quot;
    
        queryset = MovieDetail.objects.all()
        filter_backends = (filters.SearchFilter, filters.OrderingFilter)
        search_fields = (&#39;name&#39;,)
        ordering_fields = (&#39;id&#39;,)
    
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">2. 分类筛选器</span><br><span class="line"></span><br><span class="line">   1. 简介: 通过上面的配置我们已经可以去搜索字段,然后给定字段的排序了,但是我们还需要分类筛选信息,比如电影类型筛选,上映时间筛选等等</span><br><span class="line">   2. 安装:</span><br><span class="line">   </span><br><span class="line">   	    1. 官方地址: http:&#x2F;&#x2F;django-filter.readthedocs.io&#x2F;en&#x2F;master&#x2F;</span><br><span class="line">   		 2. 安装命令:</span><br><span class="line">   			</span><br></pre></td></tr></table></figure>
               $ pip install django_fliter
               <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">		</span><br><span class="line">3. 使用方法:</span><br><span class="line"></span><br><span class="line">	1. movies.views.py</span><br><span class="line">	 </span><br></pre></td></tr></table></figure>
            
            class MovieViewSet(mixins.ListModelMixin,mixins.RetrieveModelMixin,
            mixins.UpdateModelMixin,viewsets.GenericViewSet):
                &quot;&quot;&quot;
                获取电影信息接口
                &quot;&quot;&quot;
            
                queryset = MovieDetail.objects.all()
                filter_backends = (DjangoFilterBackend,filters.SearchFilter, filters.OrderingFilter)
                search_fields = (&#39;name&#39;,)
                ordering_fields = (&#39;id&#39;,)
                filter_class = MovieDetailFilter
            
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">2. 在专门的filters中去配置 类似于我们的form功能</span><br><span class="line"></span><br></pre></td></tr></table></figure>
            
            import django_filters.rest_framework as filters
            from .models import MovieDetail
            
            
            class MovieDetailFilter(filters.FilterSet):
                class Meta:
                    model = MovieDetail
                    fields = [
                        &#39;name&#39;,
                    ]
            
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		</span><br><span class="line">4. fields使用方法:</span><br><span class="line">	 可以用更多选择去约束筛选条件</span><br><span class="line">	 </span><br></pre></td></tr></table></figure>
         
             class Meta:
                model = MovieDetail
                fields = &#123;
                    &#39;name&#39;:[&#39;exact&#39;, &#39;contains&#39;]
                &#125;
         
         <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">			 </span><br><span class="line">			 上面的会给你创建两个筛选字段 一个给你精确匹配，一个给你模糊pip</span><br><span class="line">			 </span><br><span class="line">		5. 筛选条件详解</span><br><span class="line">		</span><br><span class="line">			1. exact 精确匹配</span><br><span class="line">			2. contains icontains 包含 i表示忽略大小写</span><br><span class="line">			3. gt gte 大于 大于等于</span><br><span class="line">			4. lt lte 小于 小于等于</span><br><span class="line">		6. 外键的使用:</span><br><span class="line">		    1. __ 表示魔术方法</span><br><span class="line">		    2. kind_category__name</span><br><span class="line">	   		</span><br><span class="line">	   			</span><br><span class="line">	   		</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">### 11.admin 后台管理定制化</span><br><span class="line"></span><br><span class="line">1. 简介:</span><br><span class="line">   我们的admin里面包含了字段的所有信息,但是有些信息我们是不想让人去修改的,比如所点赞数量,浏览数量,或者其他定制化的东西,所以我们需要调用admin里面的方法去修改我们对admin里面字段的约束</span><br><span class="line">   </span><br><span class="line">2. 约束修改方法:</span><br><span class="line">	1. 只显示哪些字段</span><br><span class="line">		fields &#x3D; (&#39;name&#39;, &#39;status&#39;) </span><br><span class="line">	2. 不显示哪些字段</span><br><span class="line">		exclude &#x3D; (&#39;name&#39;,)</span><br><span class="line">	3. 哪些字段在一行里面去显示:</span><br><span class="line">	</span><br><span class="line">		1. 注意点: 不能把外键放在里面</span><br><span class="line">	</span><br><span class="line">		fields &#x3D; ((&#39;name&#39;, &#39;status&#39;), &#39;sub_title&#39;)</span><br><span class="line">	4. 组合字段展示,可以把字段放在合集里面展示，给出标题和样式。collapse表示下拉栏</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
        fieldsets = (
            (None, &#123;
                &#39;fields&#39;: ((&#39;name&#39;, &#39;status&#39;), &#39;sub_title&#39;)
            &#125;),
            (&#39;Advanced options&#39;, &#123;
                &#39;classes&#39;: (&#39;collapse&#39;,),
                &#39;fields&#39;: (&#39;view_num&#39;, &#39;is_banner&#39;),
            &#125;),
        )
    
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5. list_display:</span><br><span class="line">	顾名思义,会在展示list的时候,展示哪些数据</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
        ...    
        list_display = (&#39;id&#39;,&#39;name&#39;,&#39;status&#39;)
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6. list_display_links:</span><br><span class="line">	配置了之后会生成一个连接 直接连接过去:</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
    ...    
    list_display_links = (&#39;name&#39;, &#39;status&#39;)
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7. list_editable:</span><br><span class="line">	</span><br><span class="line">	可以直接在list面板修改值,不用进入到里面去修改</span><br><span class="line">	</span><br><span class="line">	list_editable &#x3D; (&quot;status&quot;,)</span><br><span class="line">	</span><br><span class="line">8. list_filter:</span><br><span class="line">	可以在list面板配置分类功能 </span><br><span class="line">	</span><br></pre></td></tr></table></figure>
    list_filter = (&#39;kind_category&#39;,)
    
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9. search_fields:</span><br><span class="line">	搜索框搜索页面</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
    search_fields = [&#39;name&#39;]
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">10. inlines:</span><br><span class="line">	如果有外键指向了这个model,就可以使用inlines方便的管理,而不用去外面单独的编辑外键</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
    class Img(admin.TabularInline):

        model = MovieImages
    
        inlines = [Img]
    
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">	11. 其他:</span><br><span class="line">	</span><br><span class="line">	   https:&#x2F;&#x2F;yiyibooks.cn&#x2F;xx&#x2F;Django_1.11.6&#x2F;ref&#x2F;contrib&#x2F;admin&#x2F;index.html</span><br><span class="line"></span><br><span class="line">3. 富文本编辑器 ckeditor</span><br><span class="line"></span><br><span class="line">    1. 官网 https:&#x2F;&#x2F;github.com&#x2F;django-ckeditor&#x2F;django-ckeditor</span><br><span class="line"></span><br><span class="line">    2. 安装</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    pip install django-ckeditor
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在settings的app里面加入 ckeditor</span><br><span class="line"></span><br><span class="line">新建文件夹 static</span><br><span class="line"></span><br><span class="line">配置 STATIC_ROOT &#x3D; static</span><br><span class="line"></span><br></pre></td></tr></table></figure>
                
        CKEDITOR_UPLOAD_PATH = &#39;ckeditor/&#39;
        CKEDITOR_RESTRICT_BY_USER = True
        CKEDITOR_BROWSE_SHOW_DIRS = True
        CKEDITOR_RESTRICT_BY_DATE = True
        CKEDITOR_IMAGE_BACKEND = &#39;PIL&#39;
        CKEDITOR_BASEPATH = &quot;/static/ckeditor/ckeditor/&quot;
        CKEDITOR_CONFIGS = &#123;
            &#39;default&#39;: &#123;
                &#39;update&#39;: [&#39;Image&#39;, &#39;Update&#39;, &#39;Flash&#39;, &#39;Table&#39;, &#39;HorizontalRule&#39;, 
                &#39;Smiley&#39;, &#39;SpecialChar&#39;, &#39;PageBreak&#39;],
                &#39;skin&#39;: &#39;moono&#39;,
                # &#39;skin&#39;: &#39;office2013&#39;,
                &#39;toolbar_Basic&#39;: [
                    [&#39;Source&#39;, &#39;-&#39;, &#39;Bold&#39;, &#39;Italic&#39;]
                ],
                # &#39;toolbar_YourCustomToolbarConfig&#39;: [
                #     &#123;&#39;name&#39;: &#39;document&#39;, &#39;items&#39;: [&#39;Source&#39;, &#39;-&#39;, &#39;Save&#39;, &#39;NewPage&#39;,
                 &#39;Preview&#39;, &#39;Print&#39;, &#39;-&#39;, &#39;Templates&#39;]&#125;,
                #     &#123;&#39;name&#39;: &#39;clipboard&#39;, &#39;items&#39;: [&#39;Cut&#39;, &#39;Copy&#39;, &#39;Paste&#39;,
                 &#39;PasteText&#39;, &#39;PasteFromWord&#39;, &#39;-&#39;, &#39;Undo&#39;, &#39;Redo&#39;]&#125;,
                #     &#123;&#39;name&#39;: &#39;editing&#39;, &#39;items&#39;: [&#39;Find&#39;, &#39;Replace&#39;, &#39;-&#39;, 
                &#39;SelectAll&#39;]&#125;,
                #     &#123;&#39;name&#39;: &#39;forms&#39;,
                #      &#39;items&#39;: [&#39;Form&#39;, &#39;Checkbox&#39;, &#39;Radio&#39;, &#39;TextField&#39;, 
                &#39;Textarea&#39;, &#39;Select&#39;, &#39;Button&#39;, &#39;ImageButton&#39;,
                #                &#39;HiddenField&#39;]&#125;,
                #     &#39;/&#39;,
                #     &#123;&#39;name&#39;: &#39;basicstyles&#39;,
                #      &#39;items&#39;: [&#39;Bold&#39;, &#39;Italic&#39;, &#39;Underline&#39;, &#39;Strike&#39;, 
                &#39;Subscript&#39;, &#39;Superscript&#39;, &#39;-&#39;, &#39;RemoveFormat&#39;]&#125;,
                #     &#123;&#39;name&#39;: &#39;paragraph&#39;,
                #      &#39;items&#39;: [&#39;NumberedList&#39;, &#39;BulletedList&#39;, &#39;-&#39;, 
                &#39;Outdent&#39;, &#39;Indent&#39;, &#39;-&#39;, &#39;Blockquote&#39;, &#39;CreateDiv&#39;, &#39;-&#39;,
                #                &#39;JustifyLeft&#39;, &#39;JustifyCenter&#39;, &#39;JustifyRight&#39;, 
                &#39;JustifyBlock&#39;, &#39;-&#39;, &#39;BidiLtr&#39;, &#39;BidiRtl&#39;,
                #                &#39;Language&#39;]&#125;,
                #     &#123;&#39;name&#39;: &#39;links&#39;, &#39;items&#39;: [&#39;Link&#39;, &#39;Unlink&#39;, &#39;Anchor&#39;]&#125;,
                #     &#123;&#39;name&#39;: &#39;insert&#39;,
                #      &#39;items&#39;: [&#39;Image&#39;, &#39;Flash&#39;, &#39;Table&#39;, &#39;HorizontalRule&#39;, 
                &#39;Smiley&#39;, &#39;SpecialChar&#39;, &#39;PageBreak&#39;, &#39;Iframe&#39;]&#125;,
                #     &#39;/&#39;,
                #     &#123;&#39;name&#39;: &#39;styles&#39;, &#39;items&#39;: [&#39;Styles&#39;, &#39;Format&#39;, &#39;Font&#39;, &#39;FontSize&#39;]&#125;,
                #     &#123;&#39;name&#39;: &#39;colors&#39;, &#39;items&#39;: [&#39;TextColor&#39;, &#39;BGColor&#39;]&#125;,
                #     &#123;&#39;name&#39;: &#39;tools&#39;, &#39;items&#39;: [&#39;Maximize&#39;, &#39;ShowBlocks&#39;]&#125;,
                #     &#123;&#39;name&#39;: &#39;about&#39;, &#39;items&#39;: [&#39;About&#39;]&#125;,
                #     &#39;/&#39;,  # put this to force next toolbar on new line
                #     &#123;&#39;name&#39;: &#39;yourcustomtools&#39;, &#39;items&#39;: [
                #         # put the name of your editor.ui.addButton here
                #         &#39;Preview&#39;,
                #         &#39;Maximize&#39;,
                #
                #     ]&#125;,
                # ],
                # &#39;toolbar&#39;: &#39;YourCustomToolbarConfig&#39;,  # put selected toolbar config here
                # # &#39;toolbarGroups&#39;: [&#123; &#39;name&#39;: &#39;document&#39;, &#39;groups&#39;: 
                [ &#39;mode&#39;, &#39;document&#39;, &#39;doctools&#39; ] &#125;],
                # # &#39;height&#39;: 291,
                # # &#39;width&#39;: &#39;100%&#39;,
                # # &#39;filebrowserWindowHeight&#39;: 725,
                # # &#39;filebrowserWindowWidth&#39;: 940,
                # # &#39;toolbarCanCollapse&#39;: True,
                # # &#39;mathJaxLib&#39;: &#39;//cdn.mathjax.org/mathjax/2.2-latest/MathJax.js
                ?config=TeX-AMS_HTML&#39;,
                # &#39;tabSpaces&#39;: 4,
                # &#39;extraPlugins&#39;: &#39;,&#39;.join([
                #     # &#39;uploadimage&#39;,  # the upload image feature
                #     # your extra plugins here
                #     &#39;div&#39;,
                #     &#39;autolink&#39;,
                #     &#39;autoembed&#39;,
                #     &#39;embedsemantic&#39;,
                #     &#39;autogrow&#39;,
                #     # &#39;devtools&#39;,
                #     &#39;widget&#39;,
                #     &#39;lineutils&#39;,
                #     &#39;clipboard&#39;,
                #     &#39;dialog&#39;,
                #     &#39;dialogui&#39;,
                #     &#39;elementspath&#39;
                # ]),
            &#125;
        &#125;
    
    
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">执行 collectstatic</span><br><span class="line"></span><br><span class="line">在url里面取配置静态文件服务器和ckeditor的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
        
        
        urlpatterns = [
                ...
                url(r&#39;^ckeditor/&#39;, include(&#39;ckeditor_uploader.urls&#39;)),
                ...
            
            ]
        ...
        
        urlpatterns += [
                # 启动一个文件服务器(django的文件服务器 实际上线后使用nginx之类的服务器作为文件服务器)
                url(r&#39;^static/(?P&lt;path&gt;.*)$&#39;, serve, &#123;
                    &#39;document_root&#39;: settings.STATIC_ROOT
                &#125;),
                url(r&#39;^media/(?P&lt;path&gt;.*)$&#39;, serve, &#123;
                    &#39;document_root&#39;: settings.MEDIA_ROOT
                &#125;)
            ]
                    
        
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">    CKEDITOR_BASEPATH 一定要在结尾加上 &#x2F; 比如 &quot;&#x2F;static&#x2F;ckeditor&#x2F;ckeditor&#x2F;&quot;</span><br><span class="line">    </span><br><span class="line">3. 在model中取替换我们的field即可,然后去admin里面取查看</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    
        from ckeditor_uploader.fields import RichTextUploadingField
        
        class MovieDetail(models.Model):
        ...
        movie_brief = RichTextUploadingField(default=&#39;目前没有还有简介&#39;, max_length=500, 
        verbose_name=&#39;电影简介&#39;, help_text=&#39;电影简介&#39;)
        ...

    
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	       </span><br><span class="line">### 12. django 文件存储系统</span><br><span class="line"></span><br><span class="line">1. python 文件基础:</span><br><span class="line">	1. 使用python 打开文件:</span><br><span class="line">	</span><br><span class="line">		1. 使用python 打开文件并写入字符串:</span><br><span class="line"></span><br><span class="line">			读写模式:</span><br><span class="line">			</span><br><span class="line">				r: 只读</span><br><span class="line">				</span><br><span class="line">				r+: 读写</span><br><span class="line">				</span><br><span class="line">				w: 只写</span><br><span class="line">				</span><br><span class="line">				w+: 读写</span><br><span class="line">				</span><br><span class="line">				a: 只写(追加写入)</span><br><span class="line">				</span><br><span class="line">				a+: 读写(追加写入)</span><br><span class="line">				</span><br><span class="line">			&gt;my_test.file_test1.py</span><br><span class="line">			</span><br></pre></td></tr></table></figure>
        def test1():
            file = os.path.join(base_dir,&#39;test1.txt&#39;)
            with open(file,&#39;w+&#39;) as f:
                f.write(&#39;hello worasdfld&#39;)
        
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">2. 读取文件 读取大型文件或者打印大型文件的时候需要循环遍历</span><br><span class="line">	</span><br><span class="line">	&gt;my_test.file_test1.py</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
        
        def test3():
            file = os.path.join(base_dir,&#39;test2.txt&#39;)
            with open(file,&#39;r&#39;) as f:
                datas = f.readlines()
                for i in datas:
                    print(i)
        
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">			</span><br><span class="line"></span><br><span class="line">2. form-data x-www-form-urlencoded raw binary区别</span><br><span class="line"></span><br><span class="line">	https:&#x2F;&#x2F;blog.csdn.net&#x2F;shangmingtao&#x2F;article&#x2F;details&#x2F;74463500</span><br><span class="line">	</span><br><span class="line">3. urlencode解释:</span><br><span class="line">	</span><br><span class="line">	因为有时候我们get方法里面的参数会带空格 问号等等,但是这些是我们Url的特殊符号,如果url里面带有了空格问号，他就会执行其他命令。而不是把他作为字符串看待，所以我们需要把们encode 变成url不会识别成特殊符号的字符串，参考我们的正则表达式。</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&gt;my\_test.file_test1.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
        
def test4():
    from urllib import parse

    url_test = &#39;www.baidu.com?&#39;
    url_params = &#39;a=阿凡达拉水电费&amp;b=发的说法发?生?的浪费阿斯蒂芬&#39;
    print(url_test+ parse.quote(url_params))
        
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">	思考 post方法需要urlencode吗?</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">4. django 文件理清思路: static vs media</span><br><span class="line">	</span><br><span class="line">	1. static是静态文件</span><br><span class="line">	2. media是资源文件,资源文件是随时会变的,比如用户上传的头像,后台发布的文章,他是随时会变的</span><br><span class="line">	3. 你看的网页是如何显示的图片的?</span><br><span class="line">		一般会有img标签,浏览器遍历到Img标签,取出img标签里面的关于资源文件(图片,视频的网址),然后访问这个url得到的资源文件,显示给用户去看。</span><br><span class="line">	</span><br><span class="line">	4. 图片是如何生成如何传输的?</span><br><span class="line">	</span><br><span class="line">		计算机以RGB三原色或者其他算法来显示图片,其实对计算机来说,图片就是一个普通的txt文件,里面存放的是把这个图片哪个位置显示哪个颜色的信息。比如1080p就是有 1080*1920个像素点,每个像素点表现什么颜色就是我们里面存入的信息。</span><br><span class="line">		</span><br><span class="line">		那么如何传输,只需要传输txt信息给浏览器,浏览器会根据这些信息来解密,展示图片</span><br><span class="line">		</span><br><span class="line">		jpg,png是什么?</span><br><span class="line">			就是把同一个图片里面的信息加密的方式,就像我们的utf8 utf16等等,加密过程中可能会有部分信息的删除。</span><br><span class="line">	</span><br><span class="line">	5. 那么django的媒体系统是如何设计的?</span><br><span class="line">		</span><br><span class="line">		我们可以指定存储图片的位置, media_root，然后我们上传图片后,图片会存在于文件夹中。数据库里面存储的是图片存储的位置信息</span><br><span class="line">	</span><br><span class="line">5. django文件上传基础:</span><br><span class="line"></span><br><span class="line">	1. django 接受的文件上传模式是 form-data模式,如此他会把我们的文件信息(或者二进制流)放入他的 request.FILES,我们使用post上传一个文件,断点查看files里面的信息。</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		查看我们传过来的file是什么: 他是一个 inMemoryUploadFile 类</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">		&gt;mytest.file_view.py</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
    
    @csrf_exempt
    def test_files(request):
        # write_files(request.FILES[&#39;test_files&#39;])
    
        return HttpResponse(&#39;hello world&#39;)
    
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 我们可以把这个二进制数据写入到文件中(这个时候 信息还在变量中(内存))</span><br><span class="line"></span><br><span class="line">	1. 我们使用wb+模式来写入文件 因为图片等文件是用二进制流传入的</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		&gt;mytest.file_view.py</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
        
        def write_files(file):
            media_dir = os.path.join(BASE_DIR, &#39;media&#39;, &#39;test1&#39;)
            media_file = os.path.join(media_dir, file.name)
        
            with open(media_file, &#39;wb+&#39;) as f:
                #断点查看i 二进制
                for i in file.chunks():
                    f.write(i)
        
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">2. 我们可以利用这个方法把文件写在外部，注意 你需要文件的写入权限</span><br><span class="line"></span><br><span class="line">	&gt;mytest.file_view.py</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
        def write_files_out_side(file):
            media_dir = os.path.dirname(BASE_DIR)
            media_file = os.path.join(media_dir, &#39;test_store&#39;,file.name)
        
            with open(media_file, &#39;wb+&#39;) as f:
                #断点查看i
                for i in file.chunks():
                    f.write(i)
        
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">3. django中自带的文件写入类,我们使用这个类就不用去想我们刚才使用函数方法一样去自己做这些事情了,定义ImageField即可或者FileField。然后我们把inMemoryUploadFile类的对象传递给我们imgfield 他就会自动的帮我们上传完成图片。其实我们刚才的函数是一样的,不过有部分限制:</span><br><span class="line">   1. 图片的传入顶层目录必须是我们在settings中去指定的图片目录。</span><br><span class="line"></span><br><span class="line">   2. 如果图片有重名，他会自动的给我们重命名文件。</span><br><span class="line">   </span><br><span class="line">   3. 他的img字段里面存储的是图片的存储路径,而不是图片</span><br><span class="line"></span><br><span class="line">	&gt;mytest.models.py</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
    class FileTestImage(models.Model):
        name = models.CharField(max_length=20,verbose_name=&#39;文件写入测试名称&#39;)
        img = models.ImageField(upload_to=&#39;test1&#39;,verbose_name=&#39;测试图片&#39;)
    
        class Meta:
            verbose_name = &#39;图片写入测试&#39;
            verbose_name_plural = verbose_name
    
        def __str__(self):
            return self.name
    
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt; mytest.file\_test.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    
    @csrf_exempt
    def test_files(request):
    
        data = request.FILES[&#39;test_files&#39;]
        # write_files_out_side(request.FILES[&#39;test_files&#39;])
        FileTestImage.objects.create(name=&#39;测试1&#39;,img=data)
    
    
        return HttpResponse(&#39;hello world&#39;)
    
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. 问题:我们存储文件需要分开存储,试想一个大型网站有多少用户,一个文件夹里面存储10w张图片?光是系统打开这个文件都已经够消耗资源了。所以我们需要合理的去分割图片存储的文件。最常见的是以日期为准,比如每个月的图片存在于当月文件夹中，又或者每个文件夹存1000张,存满后换下一文件。但是这一切的核心问题是你需要自己去接管图片存储位置的逻辑,然后做适合业务的算法出来</span><br><span class="line"></span><br><span class="line">5. django 文件存储自定义文件夹:</span><br><span class="line"></span><br><span class="line">    1. 我们可以自定义文件的存储位置,只需要给定upload一个函数(平时我们给定的一个字符串,表示文件定死存储在哪里)</span><br><span class="line">	    </span><br></pre></td></tr></table></figure>
        def test_directory_path(instance, filename):
            ext = filename.split(&#39;.&#39;)[-1]
            filename = &#39;&#123;&#125;.&#123;&#125;&#39;.format(uuid.uuid4().hex[:8], ext)
            # return the whole path to the file
            return &quot;&#123;0&#125;/&#123;1&#125;/&quot;.format(&quot;avatar&quot;, filename)
        
        
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 升级版:</span><br><span class="line">    我们需要给定传递给哪个文件夹</span><br><span class="line">     </span><br></pre></td></tr></table></figure>
        
           import uuid
            from django.utils.deconstruct import deconstructible
            from django.utils.timezone import now
            import os
            
            
            @deconstructible
            class UploadToPathAndRename(object):
                def __init__(self, path):
                    year = str(now().year)
                    month = str(now().month)
            
                    self.sub_path = os.path.join(path, year, month)
            
                def __call__(self, instance, filename):
                    ext = filename.split(&#39;.&#39;)[-1]
                    filename = &#39;&#123;&#125;.&#123;&#125;&#39;.format(uuid.uuid4().hex[:8], ext)
                    return os.path.join(self.sub_path, filename)
        
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		    </span><br><span class="line">	6. </span><br><span class="line"></span><br><span class="line">&lt;!--3. 分布式文件传输</span><br><span class="line"></span><br><span class="line">	1. 新的问题:</span><br><span class="line">		我们已经把图片路径切割为自己定制化的路径了，但是依然有一个问题，一般线上的服务器都是把图片存储在一个专门的目录</span><br><span class="line">		或者一个专门的文件服务器上面,我们这样存在整体代码里面是不可行的。静态文件可以在代码文件里面,但是媒体文件不行。</span><br><span class="line">		</span><br><span class="line">	2. 解决上面的问题其实就是做一个系统把文件可以写到另外的文件夹(本机器中)</span><br><span class="line">	3. 我们可以使用分布式存储库来解决这个问题 django-resto</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    $ pip install django-resto
    
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		</span><br></pre></td></tr></table></figure>
    
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 13. django 部署</span><br><span class="line"></span><br><span class="line">1. 基础知识:</span><br><span class="line">	1. 我们的web服务是一个deamon程序,他们需要一直稳定的跑在服务器上面,每当有浏览器请求过来,他就需要去解析报文,然后把含有(get post参数等)的信息传递给我们的程序</span><br><span class="line">	2. web服务也有可能崩掉,所以我们需要一个第三方的程序去监听他,在web服务down的时候去自动的启动</span><br><span class="line"></span><br><span class="line">2. gunicorn 部署</span><br><span class="line">	1. 简介 gunicorn是一个django的cgi服务,它最主要的特点是轻量化 简单配置 可以使用python来做配置文件</span><br><span class="line"></span><br><span class="line">	2. 使用:</span><br><span class="line">	</span><br><span class="line">		1. 安装gunicorn服务</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
        $ pip install gunicorn
        
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. gunicorn的配置文件</span><br><span class="line"></span><br><span class="line">	</span><br></pre></td></tr></table></figure>
        
        import multiprocessing
        import os
        
        base_dir = os.path.dirname(os.path.abspath(__file__))
        # unix:file_path 使用socket方式
        bind = &quot;0.0.0.0:8009&quot;
        #socket_file = os.path.join(base_dir,&#39;mysocket&#39;,&#39;mysock.sock&#39;)
        #bind = &quot;unix:&#123;&#125;&quot;.format(socket_file)
        # 2-4 x $(NUM_CORES) range
        workers = multiprocessing.cpu_count() * 2 + 1
        #worker_class= &quot;gevent&quot;
        # port = 8002
        backlog = 2048  # 就是设置允许挂起的连接数的最大值
        # timeout默认值：30
        # reload 默认值：False 重载 更改代码的时候重启workers， 只建议在开发过程中开启。
        reload = False
        # daemon以守护进程形式来运行Gunicorn进程。默认值：False
        daemon = False
        # accesslog 设置访问日志存放的地方
        # 默认值：None
        accesslog = os.path.join(base_dir, &#39;log&#39;, &#39;gunicorn&#39;, &#39;access.log&#39;)
        # errorlog 设置错误日志的存放地址
        errorlog = os.path.join(base_dir, &#39;log&#39;, &#39;gunicorn&#39;, &#39;error.log&#39;)

        
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">3. 在django项目下面去启动服务器</span><br><span class="line"></span><br></pre></td></tr></table></figure>
        
        command=/Users/canvas/virtualenvs/django_drf_rimi_teaching/bin/gunicorn -c 
        gunicorn_conf.py drf_movie_rimi.wsgi &amp;
        
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">			</span><br><span class="line">3. superviosr</span><br><span class="line"></span><br><span class="line">	1. 在上面我们完成了gunicorn的部署之后,我们需要一个第三方监听程序去监听他。所以我们决定使用superviosr来做这个事情</span><br><span class="line">	2. supservioser的安装</span><br><span class="line">	</span><br><span class="line">		注意使用sudo 和python 2.4 以上版本，不能使用python3</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
    sudo pip2.7 install supervisor
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 安装完成之后,首选配置</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    
        
        ; Sample supervisor config file.
        ;
        ; For more information on the config file, please see:
        ; http://supervisord.org/configuration.html
        ;
        ; Notes:
        ;  - Shell expansion (&quot;~&quot; or &quot;$HOME&quot;) is not supported.  Environment
        ;    variables can be expanded using this syntax: &quot;%(ENV_HOME)s&quot;.
        ;  - Quotes around values are not supported, except in the case of
        ;    the environment= options as shown below.
        ;  - Comments must have a leading space: &quot;a=b ;comment&quot; not &quot;a=b;comment&quot;.
        ;  - Command will be truncated if it looks like a config file comment, e.g.
        ;    &quot;command=bash -c &#39;foo ; bar&#39;&quot; will truncate to &quot;command=bash -c &#39;foo &quot;.
        
        [unix_http_server]
        file=/tmp/supervisor.sock   ; the path to the socket file
        ;chmod=0700                 ; socket file mode (default 0700)
        ;chown=nobody:nogroup       ; socket file uid:gid owner
        ;username=user              ; default is no username (open server)
        ;password=123               ; default is no password (open server)
        
        [inet_http_server]         ; inet (TCP) server disabled by default
        port=127.0.0.1:9001        ; ip_address:port specifier, *:port for all iface
        username=user              ; default is no username (open server)
        password=123               ; default is no password (open server)
        
        [supervisord]
        logfile=/tmp/supervisord.log ; main log file; default $CWD/supervisord.log
        logfile_maxbytes=50MB        ; max main logfile bytes b4 rotation; default 50MB
        logfile_backups=10           ; # of main logfile backups; 0 means none, default 10
        loglevel=info                ; log level; default info; others: debug,warn,trace
        pidfile=/tmp/supervisord.pid ; supervisord pidfile; default supervisord.pid
        nodaemon=false               ; start in foreground if true; default false
        minfds=1024                  ; min. avail startup file descriptors; default 1024
        minprocs=200                 ; min. avail process descriptors;default 200
        ;umask=022                   ; process file creation umask; default 022
        ;user=chrism                 ; default is current user, required if root
        ;identifier=supervisor       ; supervisord identifier, default is &#39;supervisor&#39;
        ;directory=/tmp              ; default is not to cd during start
        ;nocleanup=true              ; don&#39;t clean up tempfiles at start; default false
        ;childlogdir=/tmp            ; &#39;AUTO&#39; child log dir, default $TEMP
        ;environment=KEY=&quot;value&quot;     ; key value pairs to add to environment
        ;strip_ansi=false            ; strip ansi escape codes in logs; def. false
        
        ; The rpcinterface:supervisor section must remain in the config file for
        ; RPC (supervisorctl/web interface) to work.  Additional interfaces may be
        ; added by defining them in separate [rpcinterface:x] sections.
        
        [rpcinterface:supervisor]
        supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface
        
        ; The supervisorctl section configures how supervisorctl will connect to
        ; supervisord.  configure it match the settings in either the unix_http_server
        ; or inet_http_server section.
        
        [supervisorctl]
        serverurl=unix:///tmp/supervisor.sock ; use a unix:// URL  for a unix socket
        ;serverurl=http://127.0.0.1:9001 ; use an http:// url to specify an inet socket
        ;username=chris              ; should be same as in [*_http_server] if set
        ;password=123                ; should be same as in [*_http_server] if set
        ;prompt=mysupervisor         ; cmd line prompt (default &quot;supervisor&quot;)
        ;history_file=~/.sc_history  ; use readline history if available
        
        ; The sample program section below shows all possible program subsection values.
        ; Create one or more &#39;real&#39; program: sections to be able to control them under
        ; supervisor.
        
        ;[program:theprogramname]
        ;command=/bin/cat              ; the program (relative uses PATH, can take args)
        ;process_name=%(program_name)s ; process_name expr (default %(program_name)s)
        ;numprocs=1                    ; number of processes copies to start (def 1)
        ;directory=/tmp                ; directory to cwd to before exec (def no cwd)
        ;umask=022                     ; umask for process (default None)
        ;priority=999                  ; the relative start priority (default 999)
        ;autostart=true                ; start at supervisord start (default: true)
        ;startsecs=1                   ; # of secs prog must stay up to be running (def. 1)
        ;startretries=3                ; max # of serial start failures when starting (default 3)
        ;autorestart=unexpected        ; when to restart if exited after running (def: unexpected)
        ;exitcodes=0,2                 ; &#39;expected&#39; exit codes used with autorestart (default 0,2)
        ;stopsignal=QUIT               ; signal used to kill process (default TERM)
        ;stopwaitsecs=10               ; max num secs to wait b4 SIGKILL (default 10)
        ;stopasgroup=false             ; send stop signal to the UNIX process group (default false)
        ;killasgroup=false             ; SIGKILL the UNIX process group (def false)
        ;user=chrism                   ; setuid to this UNIX account to run the program
        ;redirect_stderr=true          ; redirect proc stderr to stdout (default false)
        ;stdout_logfile=/a/path        ; stdout log path, NONE for none; default AUTO
        ;stdout_logfile_maxbytes=1MB   ; max # logfile bytes b4 rotation (default 50MB)
        ;stdout_logfile_backups=10     ; # of stdout logfile backups (0 means none, default 10)
        ;stdout_capture_maxbytes=1MB   ; number of bytes in &#39;capturemode&#39; (default 0)
        ;stdout_events_enabled=false   ; emit events on stdout writes (default false)
        ;stderr_logfile=/a/path        ; stderr log path, NONE for none; default AUTO
        ;stderr_logfile_maxbytes=1MB   ; max # logfile bytes b4 rotation (default 50MB)
        ;stderr_logfile_backups=10     ; # of stderr logfile backups (0 means none, default 10)
        ;stderr_capture_maxbytes=1MB   ; number of bytes in &#39;capturemode&#39; (default 0)
        ;stderr_events_enabled=false   ; emit events on stderr writes (default false)
        ;environment=A=&quot;1&quot;,B=&quot;2&quot;       ; process environment additions (def no adds)
        ;serverurl=AUTO                ; override serverurl computation (childutils)
        
        ; The sample eventlistener section below shows all possible eventlistener
        ; subsection values.  Create one or more &#39;real&#39; eventlistener: sections to be
        ; able to handle event notifications sent by supervisord.
        
        ;[eventlistener:theeventlistenername]
        ;command=/bin/eventlistener    ; the program (relative uses PATH, can take args)
        ;process_name=%(program_name)s ; process_name expr (default %(program_name)s)
        ;numprocs=1                    ; number of processes copies to start (def 1)
        ;events=EVENT                  ; event notif. types to subscribe to (req&#39;d)
        ;buffer_size=10                ; event buffer queue size (default 10)
        ;directory=/tmp                ; directory to cwd to before exec (def no cwd)
        ;umask=022                     ; umask for process (default None)
        ;priority=-1                   ; the relative start priority (default -1)
        ;autostart=true                ; start at supervisord start (default: true)
        ;startsecs=1                   ; # of secs prog must stay up to be running (def. 1)
        ;startretries=3                ; max # of serial start failures when starting (default 3)
        ;autorestart=unexpected        ; autorestart if exited after running (def: unexpected)
        ;exitcodes=0,2                 ; &#39;expected&#39; exit codes used with autorestart (default 0,2)
        ;stopsignal=QUIT               ; signal used to kill process (default TERM)
        ;stopwaitsecs=10               ; max num secs to wait b4 SIGKILL (default 10)
        ;stopasgroup=false             ; send stop signal to the UNIX process group (default false)
        ;killasgroup=false             ; SIGKILL the UNIX process group (def false)
        ;user=chrism                   ; setuid to this UNIX account to run the program
        ;redirect_stderr=false         ; redirect_stderr=true is not allowed for eventlisteners
        ;stdout_logfile=/a/path        ; stdout log path, NONE for none; default AUTO
        ;stdout_logfile_maxbytes=1MB   ; max # logfile bytes b4 rotation (default 50MB)
        ;stdout_logfile_backups=10     ; # of stdout logfile backups (0 means none, default 10)
        ;stdout_events_enabled=false   ; emit events on stdout writes (default false)
        ;stderr_logfile=/a/path        ; stderr log path, NONE for none; default AUTO
        ;stderr_logfile_maxbytes=1MB   ; max # logfile bytes b4 rotation (default 50MB)
        ;stderr_logfile_backups=10     ; # of stderr logfile backups (0 means none, default 10)
        ;stderr_events_enabled=false   ; emit events on stderr writes (default false)
        ;environment=A=&quot;1&quot;,B=&quot;2&quot;       ; process environment additions
        ;serverurl=AUTO                ; override serverurl computation (childutils)
        
        ; The sample group section below shows all possible group values.  Create one
        ; or more &#39;real&#39; group: sections to create &quot;heterogeneous&quot; process groups.
        
        ;[group:thegroupname]
        ;programs=progname1,progname2  ; each refers to &#39;x&#39; in [program:x] definitions
        ;priority=999                  ; the relative start priority (default 999)
        
        ; The [include] section can just contain the &quot;files&quot; setting.  This
        ; setting can list multiple files (separated by whitespace or
        ; newlines).  It can also contain wildcards.  The filenames are
        ; interpreted as relative to this file.  Included files *cannot*
        ; include files themselves.
        
        ;[include]
        ;files = relative/directory/*.ini
        
        [program:django3]
        command=/Users/canvas/virtualenvs/django_drf_rimi_teaching/bin/gunicorn -c 
        gunicorn_conf.py drf_movie_rimi.wsgi &amp;
        directory=/Users/canvas/project/django_drf_rimi_teaching/drf_movie_rimi
        startsecs=0
        stopwaitsecs=0
        autostart=true
autorestart=true


    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">4. 启动它</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    

    supervisord -c supervisor1.conf    
    
    
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		</span><br><span class="line">	5. 使用supervisorctl去查看状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 14. nginx 服务器</span><br><span class="line"></span><br><span class="line">1. nginx 服务器说明:</span><br><span class="line">	</span><br><span class="line">	nginx是一款反向代理服务器 -&gt; 代理服务器意思是本身不会处理任何代码,他只是将你的请求转发给其他端口处理 比如他可以把服务交给django服务程序处理</span><br><span class="line">	</span><br><span class="line">	nginx是纯C语言实现的 性能很高 他的意义是引擎的意思</span><br><span class="line">	</span><br><span class="line">	一般我们会把nginx作为文件服务器,因为文件服务器的特性是没有什么逻辑程序在其中,只需要单纯的按照协议来发送文件请求即可,这点也符合nginx的代码简单 效率高的特点。</span><br><span class="line">	</span><br><span class="line">	我们一般会把django中的文件交给nginx处理,django只负责逻辑代码，比如复杂的数据库请求，序列化等等</span><br><span class="line">	</span><br><span class="line">2. nginx的安装</span><br><span class="line"></span><br><span class="line">	1. 官网下载 编译安装</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
    $ http://nginx.org/download/nginx-1.15.2.tar.gz
    
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">解压</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    $ ./configure
    $ sudo make &amp;&amp; make install
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. nginx启动命令和重启命令</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    $ sudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx_test.conf 
    
    $ sudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx_test.conf -s reload
    
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. nginx服务器配置解释</span><br><span class="line"></span><br><span class="line">	1. user 后面跟启动用户 和用户所在的用户组</span><br><span class="line">	2. worker_processes 启动多少个线程</span><br><span class="line">	3. events 需要多少最大连接</span><br><span class="line">	4. error_log 错误日志</span><br><span class="line">	5. http 代码http模块 nginx里面只能有一个http&#123;&#125;</span><br><span class="line">	6. server 表示虚拟服务器 一个http里面可以有很多虚拟服务器</span><br><span class="line">	7. listen 表示绑定到哪个端口</span><br><span class="line">	8. location 表示端口对应的url匹配模式(正则表达式)</span><br><span class="line">	9. root表示如果是文件服务的话，他会去哪里找到文件</span><br><span class="line">	10. proxy_pass 表示转发到哪个服务上面去</span><br><span class="line"></span><br></pre></td></tr></table></figure>
#使用nginx的 用户和用户组
user  canvas staff;
worker_processes  2;

#错误日志地方
error_log  /Users/canvas/project/django_drf_rimi_teaching/drf_movie_rimi/log/nginx/error_run.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events &#123;
    worker_connections  4096;
&#125;


http &#123;
    include       mime.types;
    default_type  application/octet-stream;


    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    #监听18080端口
    server &#123;
        charset utf-8;
        listen 18080;

        #client_max_body_size 5;
           #location /static &#123;
        #    client_max_body_size 5m;
           #    alias /root/project/moudu_movie_online_test/backend/static;
        #    allow all;
           #&#125;

        location / &#123;
            client_max_body_size 5m;
               proxy_set_header Host $host;
               #把18080端口转发给8005
               proxy_pass http://127.0.0.1:8005;
        &#125;

        error_log /Users/canvas/project/django_drf_rimi_teaching/drf_movie_rimi/log/nginx/error.log;
        access_log /Users/canvas/project/django_drf_rimi_teaching/drf_movie_rimi/log/nginx/access.log;
    &#125;

    server &#123;
        listen 10081;
        root  /Users/canvas/project/django_drf_rimi_teaching/drf_movie_rimi;
        location ~ .*\.(js|css|html|gif|jpg|jpeg|png|bmp|dat|zip|jz|mp3|exe|dds|alpha|rar|spr|dll|pdb|
        pak|xxx|pck|cur|rs|atf|pwz|flv|lnk|psd|pwb|wav)$
        
        &#123;
            expires      240h;
        &#125;

        error_log /Users/canvas/project/django_drf_rimi_teaching/drf_movie_rimi/log/nginx/
        static_error.log;
        access_log /Users/canvas/project/django_drf_rimi_teaching/drf_movie_rimi/log/nginx/
        static_access.log;
    &#125;
&#125;


```
</code></pre>
]]></content>
      <categories>
        <category>python框架</category>
      </categories>
      <tags>
        <tag>Django语法整理</tag>
      </tags>
  </entry>
  <entry>
    <title>Django框架04--基础知识</title>
    <url>/jwangcloud/3407305082/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/Django.jpeg"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装：</span><br><span class="line">pip3 install django -i https:&#x2F;&#x2F;pypi.doubanio.com&#x2F;simple&#x2F;</span><br><span class="line"></span><br><span class="line">查看：</span><br><span class="line">django-admin</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pycharm中可直接创建</span><br><span class="line"></span><br><span class="line">或者命令行：django-admin startproject priject_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行Django：python3 manage.py runserver   浏览器打开有小火箭即成功</span><br><span class="line"></span><br><span class="line">创建app：python3 manage.py  startapp app_name</span><br><span class="line"></span><br><span class="line">pycharm: debug运行  ：edit可设置ip和端口</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h3><h4 id="配置目录"><a href="#配置目录" class="headerlink" title="配置目录"></a>配置目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">与Django一样名字的目录为配置目录</span><br><span class="line"></span><br><span class="line">urls：各种链接，功能的实现，路由URL    </span><br><span class="line">	1.path(‘地址栏取名’,相关函数)</span><br><span class="line">		例如：path(&#39;hello&#x2F;&#39;, views.hello_world) </span><br><span class="line">	2.需要使用import调用函数所在文件 调用的为views中的函数</span><br><span class="line">		例如：from app1 import views</span><br><span class="line">settings：</span><br><span class="line">	1.allowed_hosts（允许访问的IP）bug:同一局域网里IP可随意访问</span><br><span class="line">	2.templates:模版  ‘dirs’：确认html放置的文件夹</span><br><span class="line">		例如：&#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)]</span><br><span class="line">			base_dir:该项目的路径</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="app操作"><a href="#app操作" class="headerlink" title="app操作"></a>app操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">自己建立的app包中：</span><br><span class="line"></span><br><span class="line">views：创建函数   </span><br><span class="line">	1.httpresponse函数：创建报文内容 用于return HttpResponse(‘html语句’)  需要使用import导入该函数</span><br><span class="line">	2.requests参数：创建函数时必须加上该参数，用于接收数据等便于使用 </span><br><span class="line">	3.render(re参数,html位置—&gt;直接html名,参数dict) ：将其发送给浏览器</span><br></pre></td></tr></table></figure>



<h4 id="文件发送"><a href="#文件发送" class="headerlink" title="文件发送"></a>文件发送</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html：</span><br><span class="line">	1.创建放置html文件夹</span><br><span class="line">	2.确认文件夹位置：settings 2  templates中</span><br><span class="line">	3.书写html</span><br><span class="line">	4.编写调用函数 views 3</span><br><span class="line">	5.urls增加该网页 urls 1，2</span><br><span class="line"></span><br><span class="line">css&#x2F;js&#x2F;images(静态文件访问):</span><br><span class="line">	1.在编写的html中增加</span><br><span class="line">		&lt;head&gt;中加：</span><br><span class="line">		激活：</span><br><span class="line">             &#123;% load static %&#125;</span><br><span class="line">             自动生成静态文件链接：</span><br><span class="line">	      &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&#39;&#123;% static &quot;css.css&quot; %&#125;&#39;&gt;</span><br><span class="line">		html中的&#123;&#123;&#125;&#125;</span><br><span class="line">		&lt;li&gt;&#123;&#123; age &#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">		编写views中的函数内容时可以将&#123;&#123;&#125;&#125;中的参数以dict的形式发送过来并替换其中的字段</span><br><span class="line">	2.创建css js文件夹</span><br><span class="line">	3.settings添加：</span><br><span class="line">		1.设置访问url的路径（网址名）：STATIC_URL &#x3D; &#39;&#x2F;static&#x2F;&#39;	</span><br><span class="line">		2.确认位置：STATICFILES_DIRS &#x3D; [os.path.join(BASE_DIR, “html存放路径”),] </span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">	4.配置urls:</span><br><span class="line">	    from django.conf import settings  调用上面的设置</span><br><span class="line">	 from django.conf.urls.static import static   调用该函数</span><br><span class="line">	 urlpatterns &#x3D; [</span><br><span class="line">				]+static(settings.STATIC_URL)</span><br><span class="line">	5.书写css js images</span><br><span class="line">	6.浏览器访问：&#x2F;static&#x2F;css.css</span><br><span class="line">	7.浏览器访问对应html便可以</span><br></pre></td></tr></table></figure>


<h4 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h4><p>1.与settings在相同文件夹下创建：my.cnf普通文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># my.cnf</span><br><span class="line">[client]</span><br><span class="line">database &#x3D; NAME</span><br><span class="line">user &#x3D; USER</span><br><span class="line">password &#x3D; PASSWORD</span><br><span class="line">default-character-set &#x3D; utf8mb4</span><br></pre></td></tr></table></figure>

<p>2.settings设置：databases 中将本身数据库配置替换成mysql的配置代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># settings.py</span><br><span class="line">DATABASES &#x3D; &#123;</span><br><span class="line">  		&#39;default&#39;: &#123;</span><br><span class="line">   		   &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,</span><br><span class="line">    		  &#39;OPTIONS&#39;: &#123;</span><br><span class="line">    		      &#39;read_default_file&#39;: os.path.join(base_dir,‘django_s’,’my.cnf’),</span><br><span class="line">    		  &#125;,</span><br><span class="line"> 		 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.安装pymysql : </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pymsql </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; pycharm&#x2F;preferences&#x2F;project.django_s&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.Django使用mysql：settings同级的__init__中增加代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		</span><br><span class="line">(1).__init__中代码：</span><br><span class="line"></span><br><span class="line">	import pymysql			</span><br><span class="line">	pymysql.version_info(2,0,0)        &lt;—版本报错问题解决 无可不修改</span><br><span class="line">	pymysql.install_as_MySQLdb()</span><br><span class="line"></span><br><span class="line">(2).在external library&#x2F;&#x2F;site-packages&#x2F;django&#x2F;db&#x2F;backends&#x2F;mysql&#x2F;operations</span><br><span class="line">中将与下面5 1对应修改146行  可以先运行会自定跳到该错误这里修改即可</span><br><span class="line"></span><br><span class="line">last_executed_query中query.decode改成encode</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><p>1.命令行：在manage.py同级目录下执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 manage.py migrate   —&gt;在mysql中直接创建django内置的表 </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(1).出现’decode’:在 external library&#x2F;python 3.7&#x2F;site-packages&#x2F;django&#x2F;db&#x2F;backends&#x2F;mysql&#x2F;operations</span><br><span class="line">last_executed_query中query.decode改成encode  (直接vim修改)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>2.orm:通过对象操作数据库</p>
<p>（1）在views同级的models.py中编写定义自己的数据库表：即class创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如：创建一个文章发布的数据库</span><br><span class="line">	score &#x3D; models.FloatField(default &#x3D; 0,verbose_name&#x3D;‘电影评分’)</span><br><span class="line">	class Article(models.Model):</span><br><span class="line">	title &#x3D; models.CharField(max_length&#x3D;255)  #文章标题</span><br><span class="line">	punish_time &#x3D; models.DateTimeField()  #文章发布时间</span><br><span class="line">	author &#x3D; models.CharField(max_length&#x3D;20) #文章作者</span><br><span class="line">	text &#x3D; models.CharField(max_length&#x3D;2000)  #文章内容</span><br><span class="line">		</span><br><span class="line">	def __str__(self):</span><br><span class="line">		return self.title       (admin中直接以title字段显示)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）在settings：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">installed_apps&#x3D;[‘添加自己创建的app,即views所在文件夹名’ 例：’app1’]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（3）生成数据库表：命令行执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.python3 manage.py makemigrations    (会在migrations文件夹下生成一个数据库迁移文件) </span><br><span class="line">2.python3 manage.py migrate     （根据（3）生成的建表文件在数据库中建表）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>注意：1执行成功的迁移文件会在数据库中django_migrations表中也创建一个该记录  
        必须同时存在才行 不然会一直报错：table
解决：
    （1）删除migrations中的相关文件 再删除数据库表中的对应的记录 重新执行上述两个命令
</code></pre>
<p>(4）数据库表数据读取并在html中显示出来：</p>
<pre><code>1.创建html相关网页
2.views：
    创建函数提取：
            引入models中的相关class  即2(1)中创建的相关表的类名
            from app1.models import Article
            
    编写发送函数：
            def article(requests):
                #相当于select * from article where id = 1 语句（并未执行）：
                data = Article.objects.filter(id=1)
                #切片执行该语句：
                res = data[0]
                return render(requests,’article.html’,&#123;html中&#123;&#123;&#125;&#125;&#125;的对应值dict&#125;)
3.配置urls ：与上面urls配置一样 先导入再添加
</code></pre>
<h4 id="admin用户创建"><a href="#admin用户创建" class="headerlink" title="admin用户创建"></a>admin用户创建</h4><p>1.命令行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 manage.py createsuperuser  (本次设置user:wangqi password:wang1995)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.添加数据库到admin：</p>
<p>   （1）admin文件中添加代码</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 导入models中创建的数据库类名：</span><br><span class="line"> from app1.models import Article</span><br><span class="line">添加到admin中：</span><br><span class="line">@admin.register(Article)</span><br><span class="line">class ArticleAdmin(admin.ModelAdmin):</span><br><span class="line">	pass</span><br></pre></td></tr></table></figure>
</code></pre>
<p>   (2）浏览器中进入admin即有自己创建的数据库，可以进行相关插入等操作</p>
<h4 id="外部app-或者html"><a href="#外部app-或者html" class="headerlink" title="外部app(或者html)"></a>外部app(或者html)</h4><p>1.在django文件夹下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 manage.py startapp ‘名字’  创建新的app</span><br><span class="line">先运行 python3 manage.py rumserver  确定Django开启成功</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.将其外部的网页代码放入django 项目下</p>
<p>3.配置路径 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">settings installed_apps添加该app名 templates:添加html存放路径  </span><br><span class="line">在最后添加存放静态文件（html中的css&#x2F;js）的代码以及媒体文件的media路径（见下）</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>4.配置urls  先连接index.html看是否成功</p>
<p>5.设置css/js/images</p>
<pre><code>    1) python中 提供 win+r 可以查询+替换修改代码中的相关代码  
    2) 在使用正则表达式时需要勾选Regex  
    3) 查询：(css/.*\.css)  加括号表示一个整体    \ 转译     
    4) 替换：&#123;% static ‘$1’ %&#125;    $1表示匹配（3）中的第一个括号里的东西 再replace
         
         
</code></pre>
<p>6.建立数据库:</p>
<pre><code>    1)modele:建表 + 命令行操作数据库链接
    2)admin建立后台
    3)settings设置路径 databases添加数据库my.cnf文件位置
    4)views添加查询和插入函数     将切片转到html代码中去：
            html中循环：&#123;% for %&#125;     循环代码     &#123;% endear %&#125;

					
	例如


	views:
				def index_movie(requests):
					data = Movie.objects.all()
					return render(requests, 'index.html', &#123;‘data’:data&#125;
	html：
						&#123;% for movie in data %&#125;
						<li><p class="title">&#123;&#123; movie.title &#125;&#125;</p></li>
						&#123;% endfor %&#125;
模版中切片：&#123;% for movie in data |slice:"0:5"%&#125;
        取前5个


5)url建立连接
</code></pre>
<p>7.图片处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">models:添加字段：</span><br><span class="line"></span><br><span class="line">		img &#x3D; models.ImageField(upload_to&#x3D;&#39;images&#39;,verbose_name&#x3D;&#39;电影图片&#39;)再执行数据库操作2（3）</span><br><span class="line">		</span><br><span class="line">注意 ：进行3第一步时会跳出选择：</span><br><span class="line">			1.后续更改 先创建 2.退出,先添加 选择1 然后随便添加内容回车html中修改图片的链接</span><br><span class="line">		   </span><br></pre></td></tr></table></figure>

<p>8.html中使用自定义函数：</p>
<p>函数模版：</p>
<pre><code>在app中建立一个目录：名字固定：templatetags  其中包含__init__文件
创建一个功能名.py文件
在该.py中自定义函数编写：
    模版：from django import template
          register = template.Library()
          import math

        @register.filter(name = ‘count_star’)  #计算星星数量
        def count_star(value):
            return range(math.floor(value))


在需要该函数的html中装载：&#123;% load 功能名 %&#125;
</code></pre>
<p>9.媒体文件访问</p>
<p>图片以及视频与静态文件分开：</p>
<p>(1)创建图片视频等存放文件夹</p>
<p>(2)settings : </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">templates添加：django.template.context_processors.media</span><br><span class="line">			最后添加：#代表媒体文件的存储路径</span><br><span class="line">			MEDIA_ROOT &#x3D; os.path.join(BASE_DIR,&#39;media&#39;)  #指定后 其媒体文件根目录为media</span><br><span class="line">			MEDIA_URL &#x3D; &#39;&#x2F;media&#x2F;&#39;</span><br><span class="line">					</span><br></pre></td></tr></table></figure>

<p>(3)urls：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">调用re_path 使用正则表达式</span><br><span class="line">		from django.urls import path,re_path</span><br><span class="line">		from django.views.static import serve</span><br><span class="line">		from p1904_django2.settings import MEDIA_ROOT,MEDIA_URL</span><br><span class="line">		urlpatterns添加：</span><br><span class="line"> 			re_path(r&#39;^media&#x2F;(?P&lt;path&gt;.*)$&#39;, serve, &#123;&#39;document_root&#39;:MEDIA_ROOT&#125;),</span><br><span class="line"> 			   </span><br></pre></td></tr></table></figure>


<p>(4)html:</p>
<pre><code>装载：&#123;% load movie_extras %&#125; 
 替换所有img:&#123;% static  movie.img.url %&#125;    \&#123; % static  &#39;(images/.*\.jpg)&#39; %\&#125;
    替换成： &#123;&#123; MEDIA_URL &#125;&#125;images/m15.jpg     \&#123; MEDIA_URL &#125;&#125;$1
    以及：&#123;&#123; movie.img.url &#125;&#125;
    
</code></pre>
<p>(5)models：</p>
<pre><code>修改img的存储结构（路径格式）其媒体跟目录为media 只需要在这个跟目录下创建images文件用来存放媒体文件即可
</code></pre>
<p>10.登陆 注册 退出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">django 自带用户表  auth_user :password   pbkdf2_sha256$150000$   使用sha256加密了150000次</span><br><span class="line">		   使用该表并使用orm继承并扩展</span><br><span class="line">		1.建立一个用户单独的app python3 manage.py startalp users    (django官网：documentation 查询user有步骤)</span><br><span class="line">		2.用户models 中 </span><br><span class="line">			from django.contrib.auth.models import AbstractUser   #在用户app中继承用户模型</span><br><span class="line">			class UserInfo(Abstract..)</span><br><span class="line">		3.添加app到 settings：确认其修改</span><br><span class="line">			INS.._APP添加：users</span><br><span class="line">			AUTH_USER_MODEL &#x3D; ‘users.UserInfo’</span><br><span class="line">		4.命令行执行：数据库迁移  执行时会出问题：用户表在数据库中存在，删除不了</span><br><span class="line">								解决办法：在Django之前就创建好上诉继承代码 若已经创建 直接删除所有表</span><br><span class="line">										然后再python3 manage两步  再创建命令行超级用户</span><br><span class="line">		5.注册功能：</span><br><span class="line">			views：导入数据库models中创建表类名</span><br><span class="line">				def register(requests):pass   </span><br><span class="line">					UserInfo.objects.create_user(username&#x3D;requ.POST[‘username’],password&#x3D;..)  creat_user:可在生成名字时就会生成密码					return HttpResponse(‘hello’) #检测链接</span><br><span class="line">				</span><br><span class="line">				出现CSRF验证：settings中middleware中注销掉Csrf  </span><br><span class="line">				     </span><br><span class="line">			urls：添加该函数到path</span><br><span class="line">				网页中找到注册表单—html中找到相应位置 修改action http:&#x2F;&#x2F;ip&#x2F;register函数   所有表单信息便传到该函数的requests中</span><br><span class="line">			</span><br><span class="line">		6.登陆功能：</span><br><span class="line">			views：def login(re..):</span><br><span class="line">				username &#x3D; re…POST[‘username’]</span><br><span class="line">				password &#x3D; re…POST[‘ps’]</span><br><span class="line">				user &#x3D; UserInfo.objects.filter(username&#x3D;username)[0]  #数据库查询语句 查询用户表中username密码</span><br><span class="line">						check_password 函数(需要导入)： 检测密码</span><br><span class="line">				return  </span><br><span class="line"></span><br><span class="line">				注意：表单形式的验证前后端需要同时做：</span><br><span class="line">				例如：密码验证需要前后端都同时做</span><br><span class="line">						前端：html：min_length &#x3D; ‘4’   （这里设置后，如果后端没改，前端网页里的限制条件仍然可以改，因其html保存在本地的，在elements中						可以修改，相当于漏洞）</span><br><span class="line">							后端：if leng(‘username’) &lt; 4:</span><br><span class="line">									return HttpResponse(‘用户名长度必须大于4’)</span><br><span class="line"></span><br><span class="line">		7.登陆注册只用后端做的方法</span><br><span class="line">			forms模块(表单渲染 生成表单和验证表单 生成表单属于index中的  解决6中注意)  class LoginForm(forms.Form)</span><br><span class="line">			charfield:数据库中为varchar()   html:type元素    </span><br><span class="line">			app中创建forms.py文件：			</span><br><span class="line">				导入forms模块  :</span><br><span class="line">			 	与创建module一样创建相关class，比如登陆表单的input字段等</span><br><span class="line">							密码字段定义：password &#x3D; forms.CharField(min_length &#x3D; 8, widget &#x3D; forms.PasswordInput)  将type中改成password</span><br><span class="line">							邮箱字段:EmailField</span><br><span class="line">							网址字段:urlfiled</span><br><span class="line">			views:添加该相关函数的值到html调用函数中进行实例化，f &#x3D; LoginForm()   表示在html中生成表单</span><br><span class="line">			html:在form表单中直接使用该字段</span><br><span class="line">		</span><br><span class="line">			验证表单：users app中</span><br><span class="line">				导入表单</span><br><span class="line">				f &#x3D; LoginForm(requests.POST)    </span><br><span class="line">				print(f.is_valid())  :ture false    表示该表单符合创建表单其中的字段限制</span><br><span class="line">				username &#x3D; f.cleaned_data[‘username’]    从cleaned中取html中验证成功的相关字段  （与form表单中的字段名需要一致） 用户不存在:try</span><br><span class="line"></span><br><span class="line">			ModelForm模块（与数据库相连，比上面更好,可以以数据库中字段创建表）：  </span><br><span class="line">					forms.py:</span><br><span class="line">					from django.contrib.auth import get_user_model  #获取user的数据库信息  类</span><br><span class="line">					User &#x3D; get_user_model()			</span><br><span class="line">					class UserForm(forms.ModelForm):      #</span><br><span class="line">						class Meta: </span><br><span class="line">							model &#x3D; User      #创建用户模版</span><br><span class="line">							fields &#x3D; (“username”, “password”)    #需要验证的字段</span><br><span class="line">							widgets &#x3D; &#123;         #选择需要修改的字段</span><br><span class="line">								‘password’: forms.PasswordInput(attrs&#x3D;&#123;“min_length”:8&#125;),     #设置最小长度 （数据库中该字段只有max_length）</span><br><span class="line">								‘username’: forms.TextInput(attrs&#x3D;&#123;“min_length”:4, ‘class’: text&#125;)  #启动class字段</span><br><span class="line">										&#125;</span><br><span class="line">					html&#x2F;views：</span><br><span class="line">					users&#x2F;views:登陆注意:is_valid()函数会验证在数据库中是否存在，需要在上述中将该方法在上面类下重写方法  def validate_unique(self):pass</span><br><span class="line">				</span><br><span class="line"></span><br><span class="line">		8.保持登陆： Django中的login方法  </span><br><span class="line">			引用：from django.contrib.auth import login as user_login</span><br><span class="line">				在登陆函数中users&#x2F;views&#x2F;login:check_password 正确后：user_login(requests, user) 将该user加到报文中，并在html中保存为session以及数据库中				保存</span><br><span class="line">			在登陆页面（index.html）：加入判断语句：&#123;% if not requests.user.is_authenticated %&#125; 判断是否登陆，以此返回不同的标签 &#123;% else %&#125;&#123;% endif %&#125; 以此保持登陆</span><br><span class="line">		退出：loginout模块</span><br><span class="line">			user&#x2F;views: def logout:user_logout(requests) return HttpResponse(‘logout success’)</span><br><span class="line">			urls中配置</span><br><span class="line">			html中加入到相关href中</span><br><span class="line">		urls:可以设置别名：name&#x3D;‘’    相应href 中可以使用&#123;% url ‘别名’ %&#125;  可以把固定地址换成与后台同步</span><br><span class="line">		</span><br><span class="line">跳转页面		</span><br><span class="line">from django.shortcuts import redirect	</span><br><span class="line">from django.urls </span><br><span class="line">return redirect(‘http&#x2F;&#x2F; …’)</span><br><span class="line">return redirect(‘别名’)</span><br></pre></td></tr></table></figure>


<p>10 评分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 新建评分app</span><br><span class="line">settings：添加app</span><br><span class="line">新建model：导入models Movie get_user_model 模块</span><br><span class="line">		User &#x3D; get_user_model</span><br><span class="line">		class Score(models.Model):</span><br><span class="line">			tags &#x3D; ((1, ‘aa’),(2,’bb’),)</span><br><span class="line">			movie_score &#x3D; models.Int..(choices&#x3D;tags)  选择分数</span><br><span class="line">			movie &#x3D; models.ForieginKey(‘movie.Movie’, on_delete&#x3D;models.CASCADE)   删除的方式</span><br><span class="line">			user &#x3D; models.for…key(‘users.UserInfo, ..’)</span><br><span class="line"></span><br><span class="line">			class Meta:</span><br><span class="line">				unique_together &#x3D; (‘movie’, ‘user’)  唯一</span><br><span class="line"></span><br><span class="line">注意：字段不能与相关联表的字段重合</span><br><span class="line"></span><br><span class="line">命令行创建数据库表	</span><br><span class="line"></span><br><span class="line">修改之前自定义打星函数：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>11.部署：将本地代码放到云服务器以便所有人都可以访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.服务器</span><br><span class="line">2.登陆部署电脑：ssh rimi@10.2.0.26</span><br><span class="line">3.本地上传代码到 git 再在部署电脑上拷贝下来</span><br><span class="line">4. 部署机：安装django, 注意版本号</span><br><span class="line">5.输出本地关于oython3的所有包版本号:pip3 freeze &gt; requirements.txt</span><br><span class="line">6.服务器:pip3 install -r requirements.txt</span><br><span class="line">7. 启动 0.0.0.0:8000 所有人都可以访问（测试用）gunicorn(上线)</span><br><span class="line">8.gunicorn:    安装   线程数量：cpu*2 +1   进程 &#x3D; 线程&#x2F;2   </span><br><span class="line">9.启动：wigs: scoket 接收http协议    需要将python的socket替换成wigs</span><br><span class="line">10.访问日志&#x2F;报错</span><br><span class="line">11.图片美化  分类搜索  活动  后台分类（分级） </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python框架</category>
      </categories>
      <tags>
        <tag>Django基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Django框架03--视图</title>
    <url>/jwangcloud/3329310760/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/Django.jpeg"></p>
<h2 id="函数视图"><a href="#函数视图" class="headerlink" title="函数视图"></a>函数视图</h2><span id="more"></span>

<ol>
<li><p>基础视图分析:</p>
<ol>
<li> request 里面有所有的信息,他的信息是我们的wsgi解析之后的报文,回想一下http协议,他所有的信息都在报文里面,是一个很长的字符串,但是我们看到的request里面是dict和object,说明django框架已经帮我们解析好了报文里面的信息</li>
<li>HttpResponse是django帮我们封装响应报文,返回我们想给浏览器返回的信息,当然也有其他的返回值,他们都是django帮我们封装好的<!--more-->   
 Http404<br> HttpResponseForbidden<br> …</li>
</ol>
<blockquote>
<p>movies/views.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def test1(request):</span><br><span class="line">    return HttpResponse(&quot;Hello, world!&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>快捷函数</p>
<ol>
<li><p>我们来写一个能够渲染模板的函数,那么他需要使用HttpResponse来给用户返回信息</p>
<blockquote>
<p>movies/views.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def test5(request):</span><br><span class="line">   from django.template import loader</span><br><span class="line">   t &#x3D; loader.get_template(&#39;movies&#x2F;index.html&#39;)</span><br><span class="line">   return HttpResponse(t.render(&#123;&#125;,request))</span><br></pre></td></tr></table></figure></li>
<li><p>如果我们觉得这样写很麻烦,那么我们可以使用快捷函数 render来帮我们做这个事情,凡是在 from django.shortcuts 中定义的函数,都是帮我们快捷的完成一些功能的函数</p>
<blockquote>
<p>movies/views.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		</span><br><span class="line">def test2(request):</span><br><span class="line">		</span><br><span class="line">   return render(request,&#39;movies&#x2F;index.html&#39;)</span><br><span class="line">		</span><br></pre></td></tr></table></figure></li>
<li><p>查看一下render的源码,我们发现 其实就是我们刚才的原始函数,不过他帮我们做了一层封装</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def render(request, template_name, context&#x3D;None, content_type&#x3D;None, status&#x3D;None, using&#x3D;None):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Returns a HttpResponse whose content is filled with the result of calling</span><br><span class="line">    django.template.loader.render_to_string() with the passed arguments.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    content &#x3D; loader.render_to_string(template_name, context, request, using&#x3D;using)</span><br><span class="line">    return HttpResponse(content, content_type, status)</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他快捷函数</p>
<ol>
<li>redirec 重定向,在访问一个网页的时候,帮助我们重定向 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">def test6(request):</span><br><span class="line"></span><br><span class="line"> 			return redirect(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;)</span><br></pre></td></tr></table></figure></li>
<li>get_object_or_404 帮助我们查找数据,如果没有数据则返回404的错误 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">			</span><br><span class="line">def test7(request):</span><br><span class="line">    obj &#x3D; get_object_or_404(Test,pk&#x3D;1)</span><br><span class="line"></span><br><span class="line">    return HttpResponse(obj.name)</span><br><span class="line">			</span><br></pre></td></tr></table></figure>
</li>
<li>课堂练习<ol>
<li>如果不使用 redict快捷函数那么要怎么实现</li>
<li>如果不使用get_object_or_404 那么要怎么实现</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>装饰器</p>
<ol>
<li><p>使用装饰器去控制函数视图的行为 </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		</span><br><span class="line">from django.views.decorators.http import require_http_methods</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">@require_http_methods([&#39;GET&#39;])</span><br><span class="line">def test8(request):</span><br><span class="line">    return HttpResponse(&#39;hello&#39;)</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<ol>
<li>require_http_methods 控制行为,list传递</li>
<li>require_GET get行为</li>
<li>require_POST() post行为</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="类视图"><a href="#类视图" class="headerlink" title="类视图"></a>类视图</h2><pre><code>lietview
deleteview
</code></pre>
]]></content>
      <categories>
        <category>python框架</category>
      </categories>
      <tags>
        <tag>Django视图</tag>
      </tags>
  </entry>
  <entry>
    <title>Django框架02--搭建第一个页面</title>
    <url>/jwangcloud/2301932064/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/Django.jpeg"></p>
<h2 id="apps详解"><a href="#apps详解" class="headerlink" title="apps详解:"></a>apps详解:</h2><span id="more"></span>

<h4 id="1-apps和整体配置文件内部结构"><a href="#1-apps和整体配置文件内部结构" class="headerlink" title="1. apps和整体配置文件内部结构"></a>1. apps和整体配置文件内部结构</h4><ol start="0">
<li><p>最外部的manage.py</p>
<p> 一个命令行工具,实现django各种功能的文件,比如数据库迁移,静态文件收集,启动django服务等等</p>
</li>
<li><p>首先我们来查看一下 djano_mvc_ppt的结构</p>
<ol>
<li>_<em>init</em>_.py 它告诉Python这个目录应该被看做一个Python包</li>
<li> settings.py 项目的整体配置文件,包含项目启动哪些app,中间件设置,第三方包配置等等都在里面</li>
<li>urls.py 总路由配置文件</li>
<li>wsgi.py 网关协议入口程序</li>
</ol>
</li>
<li><p>apps的结构</p>
<p> migrations 文件夹,数据库迁移记录文件<br> init.py apps 初始化文件 一般为空即可<br> admin.py 自定义admin后台管理的地方<br> apps.py app的在项目注册的名称,默认就行了<br> models.py 定义数据模型<br> tests.py 单元测试地址<br> views.py 视图</p>
</li>
</ol>
<h4 id="2-第一个简单页面"><a href="#2-第一个简单页面" class="headerlink" title="2. 第一个简单页面"></a>2. 第一个简单页面</h4><blockquote>
<p>movies/views.py</p>
</blockquote>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line">def test1(request):</span><br><span class="line">    return HttpResponse(&quot;Hello, world!&quot;)</span><br></pre></td></tr></table></figure>
</code></pre>
<blockquote>
<p>djano_mvc_ppt/urls.py    </p>
</blockquote>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">	</span><br><span class="line">from movies.views import test1</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    </span><br><span class="line">    url(r&#39;^test1$&#39;,test1)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</code></pre>
<blockquote>
<p>访问 <a href="http://127.0.0.1:8000/test1">http://127.0.0.1:8000/test1</a></p>
</blockquote>
<h4 id="1-解释"><a href="#1-解释" class="headerlink" title="1.解释"></a>1.解释</h4><ol>
<li>views 是我们视图函数 他们负责给用户返回什么样的信息</li>
<li>url 是路由,试想一个网站有不同的页面,怎么样来走到不同的页面,就是通过这的路由分发来做的。我们把test1的网站转发到我们的views.py里面的test1函数</li>
<li>终上所述,我们在访问页面的时候,就得到了第一个页面</li>
</ol>
<p><img data-src="/jwangcloud/2301932064/chapter2/chapter2_1.png" alt="选择编译器安装"></p>
<h4 id="3-第二个页面"><a href="#3-第二个页面" class="headerlink" title="3. 第二个页面"></a>3. 第二个页面</h4><ol>
<li>我们知道,百度等网页是复杂的html构成的,所以我们需要前端人员的html网页支持,django可以渲染出前端的html网页,使用render<blockquote>
<p>movies/views.py</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def test2(request):</span><br><span class="line">	</span><br><span class="line">   return render(request,&#39;movies&#x2F;index.html&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>djano_mvc_ppt/urls.py    </p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">	</span><br><span class="line">from movies.views import test2</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    </span><br><span class="line">    url(r&#39;^test2$&#39;,test2)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>templates/movies/index.html</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;hello html&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">	</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-解释-1"><a href="#1-解释-1" class="headerlink" title="1.解释"></a>1.解释</h4><p>django可以通过一定的方式,把html网页送给浏览器,这时候就不需要我们去直接回复一个字符串</p>
<h4 id="4-第三个页面"><a href="#4-第三个页面" class="headerlink" title="4. 第三个页面"></a>4. 第三个页面</h4><blockquote>
<p>movies/models.py</p>
</blockquote>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line"># Create your models here.</span><br><span class="line"></span><br><span class="line">class Test(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;11)</span><br></pre></td></tr></table></figure>
</code></pre>
<blockquote>
<p>djano_mvc_ppt/settings.py</p>
</blockquote>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">INSTALLED_APPS &#x3D; [</span><br><span class="line">    &#39;django.contrib.admin&#39;,</span><br><span class="line">    &#39;django.contrib.auth&#39;,</span><br><span class="line">    &#39;django.contrib.contenttypes&#39;,</span><br><span class="line">    &#39;django.contrib.sessions&#39;,</span><br><span class="line">    &#39;django.contrib.messages&#39;,</span><br><span class="line">    &#39;django.contrib.staticfiles&#39;,</span><br><span class="line">    &#39;movies&#39;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
    
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python manage.py makemigrations</span><br><span class="line">$ python manage.py migrate</span><br></pre></td></tr></table></figure>
&gt;movies/views.py

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def test3(request):</span><br><span class="line">    from movies.models import Test</span><br><span class="line">    user &#x3D; Test.objects.all()[0]</span><br><span class="line"></span><br><span class="line">    return render(request,&#39;movies&#x2F;index2.html&#39;,context&#x3D;&#123;&#39;name&#39;:user.name&#125;)</span><br></pre></td></tr></table></figure>

&gt;templates/movies/index2.html
&gt;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;hello &#123;&#123; name &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
</code></pre>
<h4 id="1-解释-2"><a href="#1-解释-2" class="headerlink" title="1.解释"></a>1.解释</h4><ol>
<li><p>model可以直接操控数据库,我们不用去写sql语句了,使用对象实例化就可以获取到语句</p>
</li>
<li><p>views可以把数据库传递给html,我们称为模板渲染,因为不是html语法,他需要python去加工一下(渲染)</p>
</li>
</ol>
<h2 id="mtv模式"><a href="#mtv模式" class="headerlink" title="mtv模式"></a>mtv模式</h2><h4 id="1-解释-3"><a href="#1-解释-3" class="headerlink" title="1. 解释"></a>1. 解释</h4><p>我们上述的模式就是mtv模式</p>
<ol>
<li>views专门负责取出数据来,怎么取,取多少数据都在views里面</li>
<li>model专门负责数据库控制,数据库字段怎么定义,这些字段代表什么就是model.py做的事情</li>
<li>html文件负责页面的展现,css js等都写在里面,他就专门负责页面怎么美观就行了</li>
</ol>
<h4 id="2-综述"><a href="#2-综述" class="headerlink" title="2. 综述"></a>2. 综述</h4><p>以上就是我们框架的基本模式,主要的思想就是各司其职,分层
    </p>
]]></content>
      <categories>
        <category>python框架</category>
      </categories>
      <tags>
        <tag>Django页面搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Django框架01--入门</title>
    <url>/jwangcloud/216270077/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/Django.jpeg"></p>
<h2 id="1-虚拟环境安装和django项目启动"><a href="#1-虚拟环境安装和django项目启动" class="headerlink" title="1. 虚拟环境安装和django项目启动"></a>1. 虚拟环境安装和django项目启动</h2><span id="more"></span>

<h4 id="1-安装python虚拟环境"><a href="#1-安装python虚拟环境" class="headerlink" title="1.安装python虚拟环境"></a>1.安装python虚拟环境</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip install virtualenv</span><br><span class="line">$ pip install virtualenvwrapper</span><br><span class="line"></span><br><span class="line">$ pip install virtualenvwrapper-win (windows系列)</span><br><span class="line"></span><br><span class="line">$ export WORKON_HOME&#x3D;~&#x2F;Envs</span><br><span class="line">$ mkdir -p $WORKON_HOME</span><br><span class="line">$ source &#x2F;usr&#x2F;local&#x2F;bin&#x2F;virtualenvwrapper.sh</span><br></pre></td></tr></table></figure>
</code></pre>
<blockquote>
<p>虚拟环境位置文档位置</p>
</blockquote>
<blockquote>
<p><a href="https://virtualenvwrapper.readthedocs.io/en/latest/">https://virtualenvwrapper.readthedocs.io/en/latest/</a></p>
</blockquote>
<ol>
<li>注意点 virtualenv是初级的工具 只能用在你当前文件夹的目录下面去新建</li>
<li>wrapper所带的 mkvirtualenv 和 workon命令可以让你在任何地方管理虚拟环境 不用考虑文件夹位置</li>
</ol>
<h4 id="2-新建一个虚拟环境-激活虚拟环境-并且安装django-查看安装的django版本"><a href="#2-新建一个虚拟环境-激活虚拟环境-并且安装django-查看安装的django版本" class="headerlink" title="2.新建一个虚拟环境 激活虚拟环境 并且安装django 查看安装的django版本"></a>2.新建一个虚拟环境 激活虚拟环境 并且安装django 查看安装的django版本</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtualenv ruimi_django -p python3.6</span><br><span class="line">source ruimi_django&#x2F;bin&#x2F;activate</span><br><span class="line">pip install django&#x3D;&#x3D;1.11</span><br><span class="line">python -m django --version</span><br></pre></td></tr></table></figure>
</code></pre>
<h4 id="3-pycharm安装django环境"><a href="#3-pycharm安装django环境" class="headerlink" title="3.pycharm安装django环境"></a>3.pycharm安装django环境</h4><ol>
<li>在pycharm中选择newproject django</li>
<li>选择虚拟环境(你在本地建好的虚拟环境)</li>
<li>点击create,新建成功</li>
</ol>
<p><img data-src="/jwangcloud/216270077/chapter1/chapter1_2.png" alt="选中新建环境"><br><img data-src="/jwangcloud/216270077/chapter1/chapter1_1.png" alt="选择编译器安装"></p>
<h4 id="4-命令行安装django"><a href="#4-命令行安装django" class="headerlink" title="4. 命令行安装django"></a>4. 命令行安装django</h4><ol>
<li><p>使用命令行创建django 效果等同于pycharm 其实pycharm的原理就是去帮你执行这些命令而已</p>
</li>
<li><p>我们需要先切换到有django的虚拟环境才行</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ django-admin startproject test</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="通过django创建第一个app和命令配置文件说明"><a href="#通过django创建第一个app和命令配置文件说明" class="headerlink" title="通过django创建第一个app和命令配置文件说明"></a>通过django创建第一个app和命令配置文件说明</h2><h4 id="1-通过django-创建第一个app"><a href="#1-通过django-创建第一个app" class="headerlink" title="1 通过django 创建第一个app"></a>1 通过django 创建第一个app</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">django-admin startapp movies</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>有两个djano_mvc_ppt 第一个是总目录 第二个djano_mvc_ppt是项目的配置目录 settings urls 路由就在里面。他是定义整个项目的配置路由等。<br>我们刚才新建的是app目录是单独的功能目录,比如用户信息就可以新建一个目录来表示。在app目录里面我们去定义视图,模型等等。这个在后面章节会讲到。</p>
</blockquote>
<h4 id="2-启动django"><a href="#2-启动django" class="headerlink" title="2 启动django"></a>2 启动django</h4><ol>
<li><p>命令行来启动django </p>
<ol>
<li>python必须是我们的django环境里面的python程序</li>
<li>manage.py是我们django项目目录下面的manage.py</li>
<li>runserver是启动django 后台服务的命令 后面跟上ip和端口即可</li>
</ol>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py runserver 0.0.0.0:8000</span><br></pre></td></tr></table></figure>
</li>
<li><p>pycharm 启动django项目</p>
<ol>
<li><p>debug模式, 使用debug模式启动django,我们可以打断点,程序过来以后,就能截取到值</p>
</li>
<li><p>run 模式,那么程序只会执行,不会有断点查看功能<br> <img data-src="/jwangcloud/216270077/chapter1/chapter1_3.png" alt="选择编译器安装"></p>
</li>
<li><p>最后 我们可以在下方 看到运行的状态 </p>
<p> <img data-src="/jwangcloud/216270077/chapter1/chapter1_4.png" alt="选择编译器安装"></p>
</li>
<li><p>启动完成后我们就可以查看启动是否成功了    </p>
<p> <img data-src="/jwangcloud/216270077/chapter1/chapter1_5.png" alt="选择编译器安装"></p>
</li>
</ol>
</li>
</ol>
<h2 id="为什么使用1-11版本"><a href="#为什么使用1-11版本" class="headerlink" title="为什么使用1.11版本"></a>为什么使用1.11版本</h2><ol>
<li>2.0版本的lts(long time serve)目前还没有出来,到2019年我们就可以顺利使用django 2.0啦</li>
</ol>
<pre><code>![选择编译器安装](md_pics/chapter1/chapter1_6.png)
</code></pre>
]]></content>
      <categories>
        <category>python框架</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>通用技术02--hexo</title>
    <url>/jwangcloud/2780304565/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/hexo.jpeg"></p>
<span id="more"></span>

<meta name="referrer" content="no-referrer">

<p>版权声明：本文为github博主「_xaoxuu」的原创文章，遵循 CC4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</p>
<p><a href="https://hexo.io/zh-cn/docs/commands">原文地址</a></p>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init [folder]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>


<p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new &quot;post title with whitespace&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>-p, –path</td>
<td align="left">自定义新文章的路径</td>
</tr>
<tr>
<td>-r, –replace</td>
<td align="left">如果存在同名文章，将其替换</td>
</tr>
<tr>
<td>-s, –slug</td>
<td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td>
</tr>
</tbody></table>
<p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 –path 参数来覆盖上述行为、自行决定文件的目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me &quot;About me&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 “About me”</p>
<p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时 Hexo 会创建 source/_posts/about/me.md，同时 me.md 的 Front Matter 中的 title 为 “page”。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。</p>
<h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ hexo generate</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生成静态文件。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>-d, –deploy</td>
<td align="left">文件生成后立即部署网站</td>
</tr>
<tr>
<td>-w, –watch</td>
<td align="left">监视文件变动</td>
</tr>
<tr>
<td>-b, –bail</td>
<td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td>
</tr>
<tr>
<td>-f, –force</td>
<td align="left">强制重新生成文件Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。使用该参数的效果接近 hexo clean &amp;&amp; hexo generate</td>
</tr>
<tr>
<td>-c, –concurrency</td>
<td align="left">最大同时生成文件的数量，默认无限制</td>
</tr>
</tbody></table>
<p>该命令可以简写为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>发表草稿。</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ hexo server</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p>
<table>
<thead>
<tr>
<th>选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>-p, –port</td>
<td align="left">重设端口</td>
</tr>
<tr>
<td>-s, –static</td>
<td align="left">只使用静态文件</td>
</tr>
<tr>
<td>-l, –log</td>
<td align="left">启动日记记录，使用覆盖记录格式</td>
</tr>
</tbody></table>
<h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>部署网站。</p>
<p>参数    |描述<br>| — | :—|<br>-g, –generate    |部署之前预先生成静态文件</p>
<p>该命令可以简写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo render &lt;file1&gt; [file2] ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>渲染文件。</p>
<p>参数    |描述<br>| — | :—|<br>-o, –output|    设置输出路径</p>
<h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ hexo migrate &lt;type&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>从其他博客系统 迁移内容。</p>
<h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>


<p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p>
<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure>


<p>列出网站资料。</p>
<h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo version</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>显示 Hexo 版本。</p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><h3 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --safe</span><br></pre></td></tr></table></figure>

<p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p>
<h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --debug</span><br></pre></td></tr></table></figure>


<p>在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。</p>
<h3 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --silent</span><br></pre></td></tr></table></figure>

<p>隐藏终端信息。</p>
<h3 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用 custom.yml 代替默认的 _config.yml</span><br><span class="line">$ hexo server --config custom.yml</span><br><span class="line"></span><br><span class="line"># 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高</span><br><span class="line">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自定义配置文件的路径，指定这个参数后将不再使用默认的 _config.yml。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 使用 custom.yml 代替默认的 _config.yml</span><br><span class="line">$ hexo server --config custom.yml</span><br><span class="line"></span><br><span class="line"># 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json</span><br><span class="line">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 _multiconfig.yml。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p>
<h3 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --draft</span><br></pre></td></tr></table></figure>

<p>显示 source/_drafts 文件夹中的草稿文章。</p>
<h3 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --cwd &#x2F;path&#x2F;to&#x2F;cwd</span><br></pre></td></tr></table></figure>

<p>自定义当前工作目录（Current working directory）的路径。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>通用技术03--hexo博客搭建</title>
    <url>/jwangcloud/3848869124/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/hexo.jpeg"></p>
<meta name="referrer" content="no-referrer">

<p>版权声明：本文为github博主「_xaoxuu」的原创文章，遵循 CC4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</p>
<p><a href="https://xaoxuu.com/blog/2017-07-05-hexo-blog/">原文链接: </a><a href="https://xaoxuu.com/blog/2017-07-05-hexo-blog/">https://xaoxuu.com/blog/2017-07-05-hexo-blog/</a></p>
<h2 id="搭建基于hexo的独立博客"><a href="#搭建基于hexo的独立博客" class="headerlink" title="搭建基于hexo的独立博客"></a>搭建基于hexo的独立博客</h2><span id="more"></span>

<h3 id="傻瓜式操作-仅限于macos系统"><a href="#傻瓜式操作-仅限于macos系统" class="headerlink" title="傻瓜式操作(仅限于macos系统)"></a>傻瓜式操作(仅限于macos系统)</h3><p>打开终端，cd 到你想创建博客的地方，执行这一行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -O &#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;xaoxuu&#x2F;hexo.sh&#x2F;master&#x2F;hexo.sh&#39; -# &amp;&amp; chmod 777 hexo.sh &amp;&amp; . hexo.sh -i init</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="详细操作"><a href="#详细操作" class="headerlink" title="详细操作"></a>详细操作</h3><h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><p>Hexo依赖Node.js和git。如果电脑上没有node环境可以去 Nodejs官网 下载。安装完成可以查看版本，在终端输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm -v    #出现版本号表示安装成功</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>macOS自带git，可以跳过此步骤。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows: Download &amp; install git.</span><br><span class="line">Mac: Install it with Homebrew, MacPorts or installer.</span><br><span class="line">Linux (Ubuntu, Debian): sudo apt-get install git-core</span><br><span class="line">Linux (Fedora, Red Hat, CentOS): sudo yum install git-core</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="安装Command-Line-Tools"><a href="#安装Command-Line-Tools" class="headerlink" title="安装Command Line Tools"></a>安装Command Line Tools</h4><p>macOS需要安装Command Line Tools，Windows可以跳过这一步骤。在终端输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>点击install 安装</p>
<h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装如图：</p>
<p>若出现下图,则需要以管理员身份运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo npm install hexo-cli -g</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h4 id="开始运行hexo"><a href="#开始运行hexo" class="headerlink" title="开始运行hexo"></a>开始运行hexo</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h4><p>执行完上面几条命令之后，在浏览器打开地址：<a href="http://localhost:4000/%E5%B0%B1%E4%BC%9A%E7%9C%8B%E5%88%B0hexo%E4%B8%BA%E4%BD%A0%E6%8F%90%E4%BE%9B%E7%9A%84%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E3%80%82%E5%A6%82%E6%9E%9C%E4%BD%A0%E4%B8%8D%E5%96%9C%E6%AC%A2hexo%E8%87%AA%E5%B8%A6%E7%9A%84%E4%B8%BB%E9%A2%98%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8E%BB">http://localhost:4000/就会看到hexo为你提供的默认主题。如果你不喜欢hexo自带的主题，可以去</a> hexo官网 找个喜欢的主题。下载主题源码到…/你的博客/themes/里面，根据主题的README文档提示，可能需要安装一些依赖包，或者对主题的_config.myl文件进行修改。如果你想使用本站的博客主题的话，只需要打开终端，cd到你博客所在的目录，执行以下这条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo.sh i x</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果提示 command not found ，说明你的电脑上还没有使用过 hexo.sh 脚本，那么可以执行下面这一段命令下载脚本然后应用主题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -O &#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;xaoxuu&#x2F;hexo.sh&#x2F;master&#x2F;hexo.sh&#39; -# &amp;&amp; chmod 777 hexo.sh &amp;&amp; . hexo.sh -i i x</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="博客书写"><a href="#博客书写" class="headerlink" title="博客书写"></a>博客书写</h4><p>你可以按照 官方文档 的方法去创建一个具有初始化内容的md文件到…/你的博客/source/_posts/位置，当然也可以通过其他任意方式创建md文件，只要文件开头有如下格式的内容即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout:     post</span><br><span class="line">date:       2017-07-05</span><br><span class="line">title:      如何搭建基于Hexo的独立博客</span><br><span class="line">categories: [Dev, Cocoa]</span><br><span class="line">tags:</span><br><span class="line">    - Hexo</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">这是预览</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">这是正文</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="在文章中添加图片、音乐等"><a href="#在文章中添加图片、音乐等" class="headerlink" title="在文章中添加图片、音乐等"></a>在文章中添加图片、音乐等</h4><p>安装图片插件-路径选择你的博客文件夹 即_plot文件夹下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br><span class="line">或者</span><br><span class="line">npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image -- save</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在_config.yml配置文件中，修改为 post_asset_folder: true， 然后新建一篇文章</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new post ceshi  #会生成一个附带的相同名字的文件夹放置图片，以及一个.md文件写内容</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>文章引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片名](图片完整名字：例如book.png) 即相对路径</span><br><span class="line"></span><br><span class="line">当然也可以使用cdn来存储图片，这样速度会相对来说快一点</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>音乐</p>
<p>大家可以看网易云音乐的官网，播放音乐可以生成外链，直接拿来用就行了。iframe插件可以在代码中设置宽高等参数，auto为自动播放。flash不可以自己设置参数。看喜好，随便你。<br>其他音乐，把插件中的链接替换成要播放的链接就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#iframe插件</span><br><span class="line"></span><br><span class="line">&lt;iframe frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;330 height&#x3D;86 src&#x3D;&quot;&#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;2&amp;id&#x3D;505820138&amp;auto&#x3D;0&amp;height&#x3D;66&quot;&gt;</span><br><span class="line">&lt;&#x2F;iframe&gt;</span><br><span class="line"></span><br><span class="line">#flash插件</span><br><span class="line"></span><br><span class="line">&lt;embed src&#x3D;&quot;&#x2F;&#x2F;music.163.com&#x2F;style&#x2F;swf&#x2F;widget.swf?sid&#x3D;40249713&amp;type&#x3D;2&amp;auto&#x3D;0&amp;width&#x3D;320&amp;height&#x3D;66&quot; width&#x3D;&quot;340&quot; height&#x3D;&quot;86&quot; allowNetworking&#x3D;&quot;all&quot;&gt;</span><br><span class="line">&lt;&#x2F;embed&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[我的微博](http:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;123455)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>视频</p>
<p>视频链接最好是打开就是视频的链接（支持youku，YouTube）<br>可以把视频上传到优酷，腾讯视频，生成外链再拿来用。（上传需要注册和实名认证）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;iframe</span><br><span class="line">height&#x3D;498 width&#x3D;510</span><br><span class="line">src&#x3D;&quot;http:&#x2F;&#x2F;player.youku.com&#x2F;embed&#x2F;XMzY0MzgxNDMyOA&#x3D;&#x3D;&quot;</span><br><span class="line">frameborder&#x3D;0 allowfullscreen&gt;</span><br><span class="line">&lt;&#x2F;iframe&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h4><p>博客发布到服务器才能被外网访问，如果你有服务器更好，可以支持一些有趣的功能，例如 hexo-admin 可以为你的博客增加后台管理功能，在其他地方只要登录管理员账号就可以在线写博文了。但是如果没有自己的服务器的，也可以将博客托管到 GitHub 、 Coding 等网站。他们的优缺点如下：</p>
<p>GitHub<br>优点：功能最强大，最知名，偏技术性的博客力荐。<br>缺点：国内访问稍慢（以前是很慢，现在已经好多了，但是仍不及国内的服务快）；GitHub服务器屏蔽了百度爬虫，要想被百度收录，需要去百度站长平台手动提交。</p>
<p>Coding<br>优点：国内访问速度很快，一键申请并配置好SSL证书，很容易被百度收录。<br>缺点：只能通过CNAME方式设置域名，也就意味着你不能同时使用域名邮箱等其他域名服务。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>hexo博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>通用技术01--git</title>
    <url>/jwangcloud/2499844314/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/git.jpeg"></p>
<h1 id="git基础"><a href="#git基础" class="headerlink" title="git基础"></a>git基础</h1><span id="more"></span>

<h2 id="认知git"><a href="#认知git" class="headerlink" title="认知git"></a>认知git</h2><ol>
<li>git知识库：<a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80">https://git-scm.com/book/zh/v1/Git-基础</a></li>
<li>安装git：brew install git 升级：brew update git</li>
<li>git: 版本控制，将一个项目（文件）作为一个仓库并对其进行监控（需要进入当前文件或者项目中）</li>
</ol>
<h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><ol>
<li>git init: 初始化文件（仓库），启动文件git仓库</li>
<li>git status: 监听该文件（项目）发生的变化</li>
<li>git add 文件名: 将工作区产生的变化记录并暂存到缓冲区</li>
<li>git commit -m “注释内容”：将add 的变化添加注释并提交本次记录（若没有-m，则会进入vim编辑器中进行编译注释）</li>
<li>git log :查看其记录，使用 jk 上下移动光标，Q键退出</li>
<li>git reset –hard 记录编号：回到该编号所在记录（编号可只截取一部分）</li>
<li>git diff:若在add前对文本进行编辑并修改过，则可通过该命令进行显示修改的内容</li>
<li>git config –global user,name “ “(user.email 邮箱)</li>
<li>git merge 分支名：合并分支</li>
<li>git log –graph :查看详细分支记录</li>
<li>删除分支：git branch -d 分支名    </li>
<li>git rm –cached 缓冲区存在的记录名: 删除加入缓冲区的该记录</li>
<li>.gitignore文件：将不想记录其改变的文件名写入该文件，此后将不会产生写入文件夹发生的变化<pre><code>注意：若在git管理的文件夹下创建空的文件夹，该变化不会被记录。
</code></pre>
</li>
</ol>
<h2 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h2><ol>
<li><p>git分支：在mmaster分支上再创建其它分支记录（使用指针head进行移动记录点）</p>
</li>
<li><p>git checkout -b ‘分支名’： 新建并切换到新分支</p>
</li>
<li><p>git branch ‘分支名’： 新建分支</p>
</li>
<li><p>git checkout ‘分支名’： 切换到该分支</p>
<pre><code> 注意：若从某一个记录移到另一个分支的某一编码上时，
 需先切换（checkout）分支再切换(reset --hard)到某一个记录。
</code></pre>
</li>
</ol>
<h2 id="git-分支合并"><a href="#git-分支合并" class="headerlink" title="git 分支合并"></a>git 分支合并</h2><ol>
<li>快进合并：只有一条分支记录发生改变，另一个未发生改变的分支合并该分支：只需要将未发生改变的分支指针直接移到另一分支末端，即：先进入未发生改变的分支（checkout） 再合并发生记录的分支（git merge 发生改变的分支）</li>
<li>非冲突合并：与快进合并一样，因其两天分支的记录或者变化互不干扰</li>
<li>冲突合并：与上述操作一样，但需要在发生冲突的地方进行手动确认，并修改，此时产生的新变化也需要进行提交并注释。</li>
</ol>
<h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><h2 id="GitHub创建"><a href="#GitHub创建" class="headerlink" title="GitHub创建"></a>GitHub创建</h2><ol>
<li>github：远程仓库，还有：code、码云</li>
<li>建立仓库步骤：<pre><code> (1). 新建远程仓库 （GitHub网站上新建，会产生一个https或者ssh）
 (2). 将https或ssh添加到本地仓库并重命名：
         git remote add 别名 https(ssh) --若不是一个仓库需要进行初始化
 (3). 推送本地仓库到GitHub：git push 链接别名 分支名
 
</code></pre>
</li>
<li>删除远程仓库链接：git remote rm 链接别名</li>
<li>查看远程仓库：git remote</li>
<li>删除远程地址：git remote remove 别名</li>
<li>查看远程仓库链接：git remote -v(详细信息)</li>
<li>查看所有分支：git branch -a</li>
<li>若A修改文档并推送到远程仓库，B也修改了此文档进行推送则不会成功，后推送的需要在A修改推送后再将远程仓库的先抓取下来，进行冲突合并后再推送</li>
<li>远程仓库抓取：git pull （分支名）</li>
<li>推送到远程仓库：git push （分支名）</li>
</ol>
<h2 id="创建GitHub博客"><a href="#创建GitHub博客" class="headerlink" title="创建GitHub博客"></a>创建GitHub博客</h2><pre><code>1. 安装jeklly :sudo gem install bundler jekyll
2. 端口输入：Jekyll 确认是否安装成功
3. 创建本地Jekyll文件：Jekyll new 文件名
4. 进入该文件（第一次需要初始化仓库）
5. 安装markdown 并编辑文件（命名与__plot中文档一致）--&gt; 博客内容
6. 将其推送到GitHub的（learn666-gif.github.io）仓库（需要自己在GitHub网站创建）中去
7. 进入博客：learn666-gif.github.io
</code></pre>
<h2 id="…or-create-a-new-repository-on-the-command-line"><a href="#…or-create-a-new-repository-on-the-command-line" class="headerlink" title="…or create a new repository on the command line"></a>…or create a new repository on the command line</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;# python_resources&quot; &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md   #可能不成功，使用 touch README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin git@github.com:learn666-gif&#x2F;python_resources.git</span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="…or-push-an-existing-repository-from-the-command-line"><a href="#…or-push-an-existing-repository-from-the-command-line" class="headerlink" title="…or push an existing repository from the command line"></a>…or push an existing repository from the command line</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:learn666-gif&#x2F;python_resources.git</span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>通用技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析02--spark错误分析</title>
    <url>/jwangcloud/3907582757/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/date.jpeg"></p>
<h2 id="spark错误分析"><a href="#spark错误分析" class="headerlink" title="spark错误分析"></a>spark错误分析</h2><span id="more"></span>


<p><a href="http://spark.apache.org/docs/2.4.4/">官方文档</a></p>
<p>错误1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1020104:sbin rimi$ .&#x2F;start-master.sh </span><br><span class="line">starting org.apache.spark.deploy.master.Master, logging to &#x2F;Users&#x2F;rimi&#x2F;Desktop&#x2F;spark-2.4.4-bin-hadoop2.7&#x2F;</span><br><span class="line">logs&#x2F;spark-rimi-org.apache.spark.deploy.master.Master-1-1020104.local.out</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>解决：本地ip未找到，添加</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#sudo vim &#x2F;etc&#x2F;hosts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">255.255.255.255 broadcasthost</span><br><span class="line">::1             localhost</span><br><span class="line">0.0.0.0 1020104.local   (这一个没有)</span><br></pre></td></tr></table></figure>

<p>错误2</p>
<blockquote>
<p>spark 与 jdk 不兼容  </p>
</blockquote>
<p>解决：</p>
<blockquote>
<p>下载saprk2.7 或者更加稳定版本  jdk下载1.8  8u231</p>
<p>重新配置jdk环境</p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>数据存储与处理01--hadoop</title>
    <url>/jwangcloud/1462761565/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/date.jpeg"></p>
<h2 id="hadoop"><a href="#hadoop" class="headerlink" title="hadoop"></a>hadoop</h2><span id="more"></span>

<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><h4 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h4><blockquote>
<p>jdk下载:<br>最好下载以前的稳定版本，此次使用的jdk版本为1.8</p>
<p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">下载地址</a></p>
</blockquote>
<blockquote>
<p>hadoop下载：下载稳定版本， 此次使用Hadoop版本为2.7.7</p>
<p><a href="https://hadoop.apache.org/releases.html">下载地址</a></p>
</blockquote>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#vim ~&#x2F;.bash_profile</span><br><span class="line"></span><br><span class="line">#Setting PATH for hadoop 2.7.7</span><br><span class="line">export HADOOP_HOME&#x3D;&#x2F;Users&#x2F;rimi&#x2F;Desktop&#x2F;hadoop-2.7.7</span><br><span class="line">export PATH&#x3D;$PATH:$HADOOP_HOME&#x2F;bin</span><br><span class="line">export PATH&#x3D;$PATH:$HADOOP_HOME&#x2F;sbin</span><br><span class="line"></span><br><span class="line">#Setting JAVA_HOME for jdk 1.8</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_231.jdk&#x2F;Contents&#x2F;Home</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>编辑保存完成后，执行命令： source .bash_profile </p>
<p>查看是否配置成功：echo $JAVA_HOME  /  echo $HADOOOP_HOME</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#修改hadoop-env.sh配置文件(可不用)</span><br><span class="line">#hadoop-2.7.7&#x2F;etc&#x2F;hadoop</span><br><span class="line">#vim hadoop-env.sh</span><br><span class="line"></span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_231.jdk&#x2F;Contents&#x2F;Home</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="hadoop伪分布式配置"><a href="#hadoop伪分布式配置" class="headerlink" title="hadoop伪分布式配置"></a>hadoop伪分布式配置</h3><ol>
<li>hadoop/etc/hadoop/core-site</li>
</ol>
<table>
<thead>
<tr>
<th align="center">No.</th>
<th align="center">参数名</th>
<th align="center">默认值</th>
<th align="center">参数解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">fs.defaultFS</td>
<td align="center">file:///</td>
<td align="center">文件系统主机和端口</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">io.file.buffer.size</td>
<td align="center">4096</td>
<td align="center">流文件的缓冲区大小</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">hadoop.tmp.dir</td>
<td align="center">/tmp/hadoop-${user.name }</td>
<td align="center">临时文件夹</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vim core-site.xml</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">       &lt;!--指定namenode的地址(必须)--&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">               &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt;</span><br><span class="line">               &lt;value&gt;hdfs:&#x2F;&#x2F;10.2.0.104&lt;&#x2F;value&gt;</span><br><span class="line">   &lt;&#x2F;property&gt;</span><br><span class="line">   &lt;!--用来指定使用hadoop时产生文件的存放目录--&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">            &lt;name&gt;hadoop.tmp.dir&lt;&#x2F;name&gt;</span><br><span class="line">            &lt;value&gt;file:&#x2F;data&#x2F;hadoop&#x2F;hadoop-2.6.0&#x2F;tmp&lt;&#x2F;value&gt; </span><br><span class="line">   &lt;&#x2F;property&gt;</span><br><span class="line">   	&lt;property&gt;</span><br><span class="line">   	   &lt;!--用来指定使用hadoop时的节点数（需要）--&gt;</span><br><span class="line">            &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;</span><br><span class="line">            &lt;value&gt;1&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    	&lt;!--用来设置检查点备份日志的最长时间--&gt;</span><br><span class="line">    	&lt;name&gt;fs.checkpoint.period&lt;&#x2F;name&gt; </span><br><span class="line">    	&lt;value&gt;3600&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ol start="2">
<li>hadoop/ect/hadoop/hdfs-site</li>
</ol>
<table>
<thead>
<tr>
<th align="center">No.</th>
<th align="center">参数名</th>
<th align="center">默认值</th>
<th align="center">参数解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">dfs.namenode.secondary.http-address</td>
<td align="center">0.0.0.0:50090</td>
<td align="center">定义HDFS对应的HTTP服务器地址和端口</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">dfs.namenode.name,dir</td>
<td align="center">file://${hadoop.tmp.dir}/dfs/name</td>
<td align="center">定义DFS的名称节点在本地文件系统的位置</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">dfs,datanode.data.dir</td>
<td align="center">file://${hadoop.tmp.dir}/dfs/data</td>
<td align="center">定义DFS数据节点存储数据块时存储在本地文件系统的位置</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">dfs.replication</td>
<td align="center">3</td>
<td align="center">缺省的块复制数量</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">dfs.webhdfs.enabled</td>
<td align="center">true</td>
<td align="center">是否通过http协议读取hdfs文件，如果选是，则集群安全性较差</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vim hdfs-site.xml</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">	&lt;!--指定hdfs保存数据的副本数量--&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">             &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;</span><br><span class="line">             &lt;value&gt;2&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">	&lt;!--指定hdfs中namenode的存储位置--&gt;</span><br><span class="line">				&lt;name&gt;dfs.namenode.name.dir&lt;&#x2F;name&gt;</span><br><span class="line">				&lt;value&gt;file:&#x2F;&#x2F;&#x2F;Users&#x2F;rimi&#x2F;Desktop&#x2F;bigdata&#x2F;namenode&lt;&#x2F;value&gt;</span><br><span class="line">	&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">	&lt;!--指定hdfs中datanode的存储位置--&gt;</span><br><span class="line">      		   &lt;name&gt;dfs.datanode.data.dir&lt;&#x2F;name&gt;</span><br><span class="line">      		   &lt;value&gt;file:&#x2F;&#x2F;&#x2F;Users&#x2F;rimi&#x2F;Desktop&#x2F;bigdata&#x2F;datanode&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ol start="3">
<li>重新格式化： hdfs namenode -format</li>
</ol>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>1.查看集群上所有文件：</p>
<blockquote>
<p>hdfs dfs -ls /</p>
</blockquote>
<p>2.分别启动namenode/datanode: </p>
<blockquote>
<p>hdfs –daemon start namenode / hdfs –daemon start datanode</p>
</blockquote>
<p>3.查看该集群此ip下的文件：</p>
<blockquote>
<p>hdfs dfs -ls hdfs://10.2.0.104/</p>
</blockquote>
<p>4.创建文件夹：</p>
<blockquote>
<p>hdfs dfs -mkdirs hdfs://10.2.0.104/text</p>
</blockquote>
<p>5.logs 中可以查看日志 查看错误</p>
<blockquote>
<p>cd hadoop-2.7.7/logs/</p>
</blockquote>
<p>6.hadoop 2.* 版本可以网页查看所有namenode datanode</p>
<blockquote>
<p>浏览器输入：10.2.0.104:50070  </p>
</blockquote>
<p>7.停止namenode/datanode</p>
<blockquote>
<p>hdfs stop namenode(datanode)</p>
</blockquote>
<p>8.对地址统一管理：</p>
<blockquote>
<p>hadoop/etc/hadoop/  </p>
<p>编辑workers: vim workers   注意：前面版本名字为slaves  </p>
</blockquote>
<p>9.停止和开始所有hadoop服务：</p>
<blockquote>
<p>sbin/</p>
<p>stop-dfs.sh  停止</p>
</blockquote>
<blockquote>
<p>start-dfs.sh 开始</p>
</blockquote>
<p>10.从集群下载文件</p>
<blockquote>
<p>hdfs dfs -get hdfs://10.0.0.252:9000/data/hadoop-2.7.7.tar.gz ./  下载</p>
</blockquote>
<p>11.实现域名重定向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#sudo vim &#x2F;etc&#x2F;hosts</span><br><span class="line"></span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">255.255.255.255 broadcasthost</span><br><span class="line">::1             localhost</span><br><span class="line">0.0.0.0 1020104.local  </span><br></pre></td></tr></table></figure>

<p>12.配置Hadoop的主要5个文件</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">配置文件名</th>
<th align="center">配置对象</th>
<th align="center">主要内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">hadoop-env.sh</td>
<td align="center">hadoop运行环境</td>
<td align="center">用来定义hadoop运行环境相关的配置信息</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">core-site.xml</td>
<td align="center">集群全局参数</td>
<td align="center">用于定义系统级别的参数，如HDFS URL 、Hadoop的临时目录等</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">hdfs-site.xml</td>
<td align="center">HDFS</td>
<td align="center">如名称节点和数据节点的存放位置、文件副本的个数、文件的读取权限等</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">mapred-site.xml</td>
<td align="center">Mapreduce参数</td>
<td align="center">包括JobHistory Server 和应用程序参数两部分，如reduce任务的默认个数、任务所能够使用内存的默认上下限等</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">yarn-site.xml</td>
<td align="center">集群资源管理系统参数</td>
<td align="center">配置ResourceManager ，nodeManager的通信端口，web监控端口等</td>
</tr>
</tbody></table>
<h3 id="分布式配置："><a href="#分布式配置：" class="headerlink" title="分布式配置："></a>分布式配置：</h3><h4 id="分配ip"><a href="#分配ip" class="headerlink" title="分配ip"></a>分配ip</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># etc&#x2F;hadoop&#x2F; </span><br><span class="line"># vim workers(或者slaves) </span><br><span class="line"></span><br><span class="line">10.2.0.104      1020104.local     namenode（存储的是文件属性）  datanode</span><br><span class="line">10.2.0.195      Mac-of-Jack.local  datanode （存储文件数据）</span><br><span class="line">10.2.0.166      rimideiMac-5.local  datanode （存储文件数据）</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="yarn-site-xml"><a href="#yarn-site-xml" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h4><ol>
<li>重要参数</li>
</ol>
<table>
<thead>
<tr>
<th align="center">No.</th>
<th align="center">参数名</th>
<th align="center">默认值</th>
<th align="center">参数解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">yarn.resourcemanager.address</td>
<td align="center">0.0.0.0:8032</td>
<td align="center">ResourceManager（以下简称RM） 提供客户端访问的地址。客户端通过该地址向RM提交应用程序，杀死应用程序等</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">yarn.resourcemanager.scheduler.address</td>
<td align="center">0.0.0.0:8030</td>
<td align="center">RM提供给ApplicationMaster的访问地址。ApplicationMaster同通过该地址向RM申请资源、释放资源等</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">yarn,resoucemanager.resource.resource-tracker.address</td>
<td align="center">0.0.0.0:8031</td>
<td align="center">RM提供NodeManager的地址。NodeManager通过该地址向RM汇报心跳，领取任务等</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">yarn.resourcemanager.admin.address</td>
<td align="center">0.0.0.0:8033</td>
<td align="center">RM提供管理员的访问地址。管理员通过该地址向RM发送管理命令等</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">yarn.resourcemanager.webapp.address</td>
<td align="center">0.0.0.0:8088</td>
<td align="center">RM对web服务提供地址。用户可通过该地址在浏览器中查看集群各类信息</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">yarn.nodemanager.aux-services</td>
<td align="center"></td>
<td align="center">通过该配置项，用户可以自定义一些服务，例如Map-Reduce的shuffle功能就是采用这种方式实现的，这样就可以在NodeManager上扩展自己的服务</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：不同版本配置可能不同</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#hadoop 3.1</span><br><span class="line">#etc&#x2F;hadoop</span><br><span class="line">#vim yarn-site.xml</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;yarn.scheduler.capacity.root.queues&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;a,b,c&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;description&gt;The queues at the this level (root is the root queue).</span><br><span class="line">  &lt;&#x2F;description&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;yarn.scheduler.capacity.root.a.queues&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;a1,a2&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;description&gt;The queues at the this level (root is the root queue).</span><br><span class="line">  &lt;&#x2F;description&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;yarn.scheduler.capacity.root.b.queues&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;b1,b2,b3&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;description&gt;The queues at the this level (root is the root queue).</span><br><span class="line">  &lt;&#x2F;description&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">#hadoop 2.7</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!-- Site specific YARN configuration properties --&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">  			&lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt;</span><br><span class="line">  			&lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt;</span><br><span class="line">	&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>mapred-site.xml  </li>
</ol>
<blockquote>
<p>注意hadoop 2.7 需要将 mapre-site.xml.template 重新命名为 mapred-site.xml </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#etc&#x2F;hadoop</span><br><span class="line">#mv mapre-site.xml.template mapred-site.xml </span><br><span class="line">#vim mapred-site.xml</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;&#x2F;value&gt;&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>mapred-site.xml 重要参数说明</li>
</ol>
<table>
<thead>
<tr>
<th align="center">No.</th>
<th align="center">参数名</th>
<th align="center">默认值</th>
<th align="center">参数解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">mapreduce.framework.name</td>
<td align="center">local</td>
<td align="center">取值local、classic或yarn其中之一，如果不是yarn，则不会使用yarn集群来实现资源的分配</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">mapreduce.jobhistory.address</td>
<td align="center">0.0.0.0:10020</td>
<td align="center">定义历史服务器的地址和端口，通过历史服务器查看已经运行完的Mapreduce作业记录</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">mapreduce.jobhistory.webapp.address</td>
<td align="center">0.0.0.0:19888</td>
<td align="center">定义历史服务器web应用访问的地址和端口</td>
</tr>
</tbody></table>
<ol start="4">
<li>启动资源管理器：</li>
</ol>
<blockquote>
<p>yarn –daemon start resourcemanager </p>
<p>hadoop 2.7版本：sbin/yarn-daemon.sh start resourcemanager</p>
</blockquote>
<h4 id="完整步骤（错误解决-127-99999）"><a href="#完整步骤（错误解决-127-99999）" class="headerlink" title="完整步骤（错误解决/127 99999）"></a>完整步骤（错误解决/127 99999）</h4><p>1.jdk环境变量  </p>
<p>2.Hadoop环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Setting PATH for Python 3.7</span><br><span class="line"># The original version is saved in .bash_profile.pysave</span><br><span class="line">PATH&#x3D;&quot;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.7&#x2F;bin:$&#123;PATH&#125;&quot;</span><br><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;bin:$PATH</span><br><span class="line">export PATH&#x3D;$PATH:Desktop&#x2F;bs4&#x2F;chrom&#x2F;chromedriver</span><br><span class="line"></span><br><span class="line">export #Setting PATH for hadoop 2.7.7</span><br><span class="line">export HADOOP_HOME&#x3D;&#x2F;Users&#x2F;rimi&#x2F;Desktop&#x2F;hadoop-2.7.7</span><br><span class="line">export PATH&#x3D;$PATH:$HADOOP_HOME&#x2F;bin</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk-12.jdk&#x2F;Contents&#x2F;Home</span><br></pre></td></tr></table></figure>

<p>3.停止所有：sbin/stop-all.sh</p>
<p>4.开始所有：sbin/start-all.sh</p>
<p>5.查看是否存在进程：jps 存在则杀死该进程  kill 6163</p>
<p>6.脚本启动：sbin/hadoop-daemon.sh –script hdfs start namenode(datanode)</p>
<p>7.查看是否启动：jps</p>
<p>8.开启resourcemanager:sbin/yarn-daemon.sh start resourcemanager(nodemanager) 重复7</p>
<p>9.hdfs dfs -mkdirs hdfs://10.2.0.104/text hdfs创建文件</p>
<p>10.推送数据到hdfs：hdfs dfs -put 本地路径 上传路径</p>
<p>11.hdfs dfs -ls hdfs://10.2.0.104/</p>
<p>12.执行某一个分析 </p>
<blockquote>
<p>hadoop jar $HADOOP_HOME/share/hadoop/tools/lib/hadoop-streaming-2.7.7.jar -input hdfs://10.2.0.104/mewas/data.txt -mapper ~/Desktop/mewas/map.py -reducer ~/Desktop/mevas/reduce.py  -output /data-output</p>
</blockquote>
<blockquote>
<p>出现错误： builtin-java classes where applicable </p>
<p>解释：文件必须是可执行的 并且数据在hdfs中存在(ls -l查看文件权限)</p>
<p>解决：本地检查map运行是否正确：运行： cat data.txt | python ./map.py </p>
<p>在.py中加入注释：#!/usr/bin/env python  表面这是一个python文件使用python编码解释器</p>
</blockquote>
<p>13.数据处理方法编写：map/reduce (详细请看 :  <a href="https://hadoop.apache.org/docs/stable/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html">MapReduce Tutorial</a>)</p>
<p>14.若运行过12则需要删除output再重新运行：</p>
<blockquote>
<p>hdfs dfs -rm -r /data-output</p>
<p>hadoop jar $HADOOP_HOME/share/hadoop/tools/lib/hadoop-streaming-2.7.7.jar -input hdfs://10.2.0.104/mewas/data.txt -mapper ~/Desktop/mewas/map.py -reducer ~/Desktop/mevas/reduce.py  -output /data-output</p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>数据存储</tag>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析01--spark</title>
    <url>/jwangcloud/648089816/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/date.jpeg"></p>
<h1 id="spark"><a href="#spark" class="headerlink" title="spark"></a>spark</h1><p><a href="http://spark.apache.org/docs/2.4.4/">官方文档</a></p>
<span id="more"></span>

<h1 id="什么是spark"><a href="#什么是spark" class="headerlink" title="什么是spark"></a>什么是spark</h1><p>Spark 是一个用来实现快速而通用的集群计算的平台。优点：</p>
<ul>
<li>极快的处理速度。spark是基于内存的计算框架，因此不需要对磁盘进行多次的读写。</li>
<li>适用于各种各样原先需要多种不同的分布式平台的场景，包括批处理、迭代算法、交互式查询、流处理。</li>
<li>拥有丰富的编程接口。支持python, java, scalar等语言。</li>
</ul>
<h2 id="spark结构图"><a href="#spark结构图" class="headerlink" title="spark结构图"></a>spark结构图</h2><pre>
 +-----------+     +----------+  +----------+  +----------+
 |           |     |          |  |          |  |          |  
 | spark SQL |     |  spark   |  |  MLIB    |  | GragH X  |
 |           |     | streaming|  |          |  |          |
 +-----------+     +----------+  +----------+  +----------+
 +--------------------------------------------------------+
 |                                                        |
 |            SPARK                  CORE                 |
 |                                                        |
 +--------------------------------------------------------+
 +-----------+     +--------------------+  +----------+
 |           |     |                    |  |          |
 | 独立调度器  |     |       YARN         |  |  MESOS   |
 |           |     |                    |  |          |
 +-----------+     +--------------------+  +----------+  
</pre>
<ol>
<li>spark core: 定义了rdd的接口，实现spark的基本功能例如：任务调度，内存管理，错误恢复，与存储系统交互等模块。</li>
<li>spark sql: 用于操作结构化数据的程序包。</li>
<li>spark streaming: 提供对实时数据流式计算的组件。</li>
<li>spark MLIB: 提供用于一组机器学习的库。</li>
<li>spark GraphX: 用于操作图的程序库。</li>
<li>群集管理器：用于让spark高效的在数千计的节点之间伸缩计算。</li>
</ol>
<h2 id="spark的用途"><a href="#spark的用途" class="headerlink" title="spark的用途"></a>spark的用途</h2><ul>
<li>数据科学任务（对科学家）</li>
<li>数据处理应用（对工程师）</li>
</ul>
<h1 id="spark安装与运行"><a href="#spark安装与运行" class="headerlink" title="spark安装与运行"></a>spark安装与运行</h1><h2 id="下载及安装"><a href="#下载及安装" class="headerlink" title="下载及安装"></a>下载及安装</h2><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><ul>
<li><p>配置JAVA</p>
<pre>
  #vim ~/.bash_profile or ~/.bashrc
     export JAVA_HOME=INSTALLATION_PATH
     export PATH=$PATH:$JAVA_HOME/bin     #可选
  #. ~/.bash_profile or ~/.bashrc
</pre></li>
<li><p>配置spark</p>
<pre>
  #vim ~/.bash_profile or ~/.bashrc
    export SPARK_HOME=SPARK_INSTALLATION_PATH
    export PATH=$PATH:$SPARK_HOME/bin:$SPARK_HOME/sbin     #可选
  #. ~/.bash_profile or ~/.bashrc
</pre></li>
<li><p>测试配置是否成功</p>
<pre>
   # PYSPARK_PYTHON=python3 pyspark
</pre>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2></li>
<li><p>启动master</p>
<pre>
#start-master.sh -h IP -p PORT
</pre></li>
<li><p>启动slave</p>
<pre>
#start-slave.sh spark://IP:PORT
</pre></li>
</ul>
<h2 id="打开shell"><a href="#打开shell" class="headerlink" title="打开shell"></a>打开shell</h2>  <pre>
 #pyspark --master spark://HOST:PORT or PYSPARK_DRIVER_PYTHON=ipython SPARK_DIST_CLASSPATH=$(hadoop classpath) pyspark --master spark://localhost:7077
 </pre>
<h2 id="提交独立应用"><a href="#提交独立应用" class="headerlink" title="提交独立应用"></a>提交独立应用</h2><p>#spark-submit test.py</p>
<h1 id="spark核心概念"><a href="#spark核心概念" class="headerlink" title="spark核心概念"></a>spark核心概念</h1><p> spark程序由一个驱动器（driver）与多个执行器（executor）组成。</p>
<ul>
<li>驱动器：包含了应用的main函数，并且定义了集群上的分布式数据集与对这些数据的相关操作。</li>
<li>执行器：用于执行操作的执行对象。</li>
</ul>
<h1 id="spark编程"><a href="#spark编程" class="headerlink" title="spark编程"></a>spark编程</h1><p>每一spark应用都应该包含一个sparkcontext对象。初始化过程如下：<br>from pyspark import SparkConf, SparkContext<br>conf = SparkConf().setMaster(“localhost:7077”).setAppName(“my app”)<br>sc = SparkContext(conf)</p>
<p>sc.stop()</p>
<h1 id="RDD编程"><a href="#RDD编程" class="headerlink" title="RDD编程"></a>RDD编程</h1><p>RDD称为分布式弹性数据集，在spark中对数据的操作不外乎就是创建rdd，转化rdd与调用rdd等。</p>
<h2 id="RDD基础"><a href="#RDD基础" class="headerlink" title="RDD基础"></a>RDD基础</h2><p>rdd就是spark中不可变的分布式对象集合，每个rdd都被分为多个分区，这些分区运行在集群中的不同节点上。</p>
<h3 id="rdd的创建"><a href="#rdd的创建" class="headerlink" title="rdd的创建"></a>rdd的创建</h3><ul>
<li>读取外部数据集。<pre>
    rdd = sc.textFile("file:///test.txt")
</pre></li>
<li>在驱动器程序里分发驱动器程序的对象集合。<pre>
    rdd = sc.parallelize((1,2,3,4,5,6,7,8,9))
<pre></pre></pre></li>
</ul>
<h3 id="rdd的操作"><a href="#rdd的操作" class="headerlink" title="rdd的操作"></a>rdd的操作</h3><ul>
<li>转化（transform)。生成新的rdd,转化操作为惰性操作，每一次转化不会真的发生除非被“行动操作”进行触发<pre>
filter,返回一个由通过传给filter的函数的元素组成的RDD
map，将函数用于RDD中的每个元素并返回新的RDD。
flatMap，将函数用于RDD中的每个元素并将返回的迭代器中的元素生成新的RDD
distinct，去重
union，生成一个包含两个RDD中所有元素的RDD
intersection，求两个RDD共同的元素的RDD
subtract，移除一个RDD中的内容
cartesian，求与另一个RDD的笛卡尔乘积
</pre></li>
<li>PairRDD转化操作<pre>
reduceByKey(func),合并相同键的值。
groupByKey()，对具有相同键的值进行分组。
combineByKey()，使用不同的返回类型合并具有相同的键。
mapValues(func)，对Pair RDD中的每个值应用一个函数而不改变键值。
flatMapValues(func)
keys()，返回一个包含键的RDD。
values()，返回一个包含值的RDD。
sortByKey()，返回一个根据键排序的RDD。
subtractByKey(),删除掉RDD中与其它RDD中键相同的元素。
join，对两个RDD进行内连接。
</pre></li>
<li>行动 (action)。执行转化操作并收集结果。<pre>
reduce,并行整合RDD中所有数据
aggregate，与reduce类似，但是通常返回不同类型的函数
collect,返回RDD中所有的元素
take，从RDD中返回num个元素
first，返回第一个元素
count，求元素个数
top，从RDD中返回最前面num个元素
foreach，对RDD中的每个元素使用给定的函数
</pre></li>
</ul>
<h2 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h2><p> 当数据集以键值的形式组织的时候，聚合具有相同键的元素进行一些统计是很常见的操作。下面几个方法用于常见的聚合：</p>
<pre>
fold
combine
reduce
reduceByKey
foldByKey
</pre>

<h1 id="数据的读取与保存"><a href="#数据的读取与保存" class="headerlink" title="数据的读取与保存"></a>数据的读取与保存</h1><h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><table>
<thead>
<tr>
<th>格式名称</th>
<th>结构化</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>文本文件</td>
<td>否</td>
<td>文本文件的每一行作为记录</td>
</tr>
<tr>
<td>json</td>
<td>半结构化数据</td>
<td>要求每行一条记录</td>
</tr>
<tr>
<td>csv</td>
<td>是</td>
<td>文本格式，在电子表格中使用</td>
</tr>
<tr>
<td>sequence file</td>
<td>是</td>
<td>一种hadoop中常见的文件格式</td>
</tr>
<tr>
<td>protocol buffer</td>
<td>是</td>
<td>快速，节约空间的语言格式</td>
</tr>
<tr>
<td>对象文件</td>
<td>是</td>
<td>用来将spark作业中的数据存储下来以让共享<br>的代码读取</td>
</tr>
</tbody></table>
<h2 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h2><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><pre>
input = sc.textFile("file:///myfile.txt") #读取本地文件
hdfs_file = sc.textFile("hdfs://192.168.34.45:9099/myfile.txt") #读取hdfs文本文件。
input = sc.wholeTextFiles("file:///20190101.logs") #返回一个pair RDD，键为文件名，值为文本见类容。
</pre>
<p><b style="color:red">注意:</b> 当传递的路径为一个文件夹路径时，则会读出所有的文件。</p>
<h3 id="保存文本文件"><a href="#保存文本文件" class="headerlink" title="保存文本文件"></a>保存文本文件</h3><pre>
result.saveAsTextFile(outputFile)
</pre>

<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="读取-1"><a href="#读取-1" class="headerlink" title="读取"></a>读取</h3><pre>
import json
data = input.map(lambda x: json.loads(x))
</pre>
<h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><pre>
result.map(lambda x: json.dumps(x)).saveAsTextFile(output)
</pre>

<h2 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h2><h3 id="读取-2"><a href="#读取-2" class="headerlink" title="读取"></a>读取</h3><pre>
def map_to_csv(line):
    input = StringIO.StringIO(line)     
    reader = csv.DictReader(input, 
            fieldnames= ["姓名", "年龄"])     
    return reader.next()

rdd = sc.textFile("file:///users.txt).map(map_to_csv)
</pre>

<h3 id="保存-1"><a href="#保存-1" class="headerlink" title="保存"></a>保存</h3><pre>
import csv
import StringIO

def map_records_to_csv(records):
    output = StringIO()
    csv_writer = csv.DictWriter(output, fieldnames=("姓名", "年龄"))
    for r in records:
        csv_writer.write_row(r)
    return [output.getValues()]

rdd.map(map_records_to_csv).saveAsTextFile(output_path)
</pre>

<h1 id="Spark-SQL结构化数据"><a href="#Spark-SQL结构化数据" class="headerlink" title="Spark SQL结构化数据"></a>Spark SQL结构化数据</h1><p>在各种情况下，我们把一条 SQL 查询给 Spark SQL，让它对一个数据源执行查询（选出一些字段或者对字段使用一些函数），然后得到由 Row 对象组成的 RDD，每个 Row 对象表示一条记录。在 Python 中，可以使用 row[column_number] 以及 row.column_name 来访问元素。</p>
<h2 id="JSON-1"><a href="#JSON-1" class="headerlink" title="JSON"></a>JSON</h2><pre>
from pyspark.sql.dataframe import DataFrame

sf = SparkConf().setMaster("spark://192.168.0.104:7077").setAppName("WordCount")
hiveCtx = SparkSession.builder.config(conf=sf).getOrCreate()
hiveCtx.sparkContext.setLogLevel("WARN")
json_file = hiveCtx.read.json("file:///media/psf/Home/Workspace/Rimi/P1901/lessons/spark/users.json")
# json_file = hiveCtx.createDataFrame([{"name":"john", "age":34}, {"name":"bob", "age": 45}])
df = json_file.select(["name", "age"])
df.show()
</pre>

<h3 id="使用sql查询表"><a href="#使用sql查询表" class="headerlink" title="使用sql查询表"></a>使用sql查询表</h3><p>json_file.createOrReplaceTempView(“user”) # 将读出的结构化数据创建一张临时表<br>users = hiveCtx.sql(“select name, age from user”) # 执行sql语句<br>users.show()</p>
<h3 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h3><p>users.write.save(“file:///users.json”, format=”json”)</p>
<h2 id="CSV-1"><a href="#CSV-1" class="headerlink" title="CSV"></a>CSV</h2><pre>
from pyspark.sql.dataframe import DataFrame

sf = SparkConf().setMaster("spark://192.168.0.104:7077").setAppName("WordCount")
hiveCtx = SparkSession.builder.config(conf=sf).getOrCreate()
hiveCtx.sparkContext.setLogLevel("WARN")
csv_file = hiveCtx.read.csv("file:///media/psf/Home/Workspace/Rimi/P1901/lessons/spark/users.csv", sep=",", header=True)
df = csv_file.select(["name", "age"])
df.show()
</pre>

<h3 id="保存文件-1"><a href="#保存文件-1" class="headerlink" title="保存文件"></a>保存文件</h3><p>users.write.save(“file:///users.csv”, format=”csv”)</p>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><pre>
table = hiveCtx.read.jdbc("jdbc:mysql://localhost/roc", "django_migrations", 
                          properties={ 'user' : 'root', 'password' : '123456' })
table.show()
</pre>

<h3 id="保存到数据库"><a href="#保存到数据库" class="headerlink" title="保存到数据库"></a>保存到数据库</h3><pre>
data.write.save(format="jdbc", url="jdbc:mysql://localhost/ggchat", dbtable="test2", user="root", password="123456")
</pre>

<h2 id="用户自定义函数（UDF）"><a href="#用户自定义函数（UDF）" class="headerlink" title="用户自定义函数（UDF）"></a>用户自定义函数（UDF）</h2><p>用户自定义函数，也叫 UDF，可以让我们使用 Python/Java/Scala 注册自定义函数，并在 SQL 中调用。这种方法很常用，通常用来给机构内的</p>
<ul>
<li>9-36：Python 版本耳朵字符串长度 UDF</li>
</ul>
<pre>

hiveCtx.registerFunction("strLenPython", lambda x: len(x), IntegerType()) 
lengthSchemaRDD = hiveCtx.sql("SELECT strLenPython('text') FROM tweets LIMIT 10")

</pre>

<h1 id="Spark配置与调优"><a href="#Spark配置与调优" class="headerlink" title="Spark配置与调优"></a>Spark配置与调优</h1><h2 id="使用SparkConf配置Spark"><a href="#使用SparkConf配置Spark" class="headerlink" title="使用SparkConf配置Spark"></a>使用SparkConf配置Spark</h2><pre>
sc = SparkConf()
sc.set("spark.app.name", "spark test")
sc.set("spark.master", "spark://localhost:7077")
sc.set("spark.ui.port", 4444)
</pre>

<h2 id="常用的选项"><a href="#常用的选项" class="headerlink" title="常用的选项"></a>常用的选项</h2><table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>spark.executor.memory</td>
<td>512m</td>
<td>为每个执行器进程分配的内存</td>
</tr>
<tr>
<td>spark.executor.cores</td>
<td>1</td>
<td>限制应用使用的核心数量</td>
</tr>
<tr>
<td>spark.cores.max</td>
<td>无</td>
<td>使用的核心总数</td>
</tr>
<tr>
<td>spark.speculation</td>
<td>false</td>
<td>是否开启任务预测</td>
</tr>
<tr>
<td>spark.[X].port</td>
<td>任意值</td>
<td>设置spark用到的端口</td>
</tr>
</tbody></table>
<h1 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h1><p>许多应用需要即时处理收到的数据，例如用来实时追踪页面访问统计的应用、训练机器学习模型的应用，还有自动检测异常的应用。Spark Streaming 是 Spark 为这些应用而设计的模型。它允许用户使用一套和批处理非常接近的 API 来编写流式计算应用，这样就可以大量重用批处理应用的技术甚至代码。</p>
<h2 id="Streaming例子"><a href="#Streaming例子" class="headerlink" title="Streaming例子"></a>Streaming例子</h2><pre>
from pyspark.streaming import StreamingContext
from pyspark import SparkConf,SparkContext
# 设置集群信息
sf = SparkConf().setMaster("spark://192.168.0.104:7077").setAppName("xxxxxx")
sc = SparkContext(conf=sf)
sc.setLogLevel("ERROR")
# 初始化streaming对象
s = StreamingContext(sc, 1)
# 设置检查点机制
s.checkpoint("file:///media/psf/Home/Workspace/Rimi/P1901/lessons/spark/checkpoints")
# 通过网络读取数据流形成dstream
dstream = s.socketTextStream("192.168.0.103", 7777)
# 设置滑动窗口
dstream = dstream.window(3)
# dstream转化操作
dstream = dstream.flatMap(lambda x: x.split()).map(lambda x: (x, 1)).groupByKey().mapValues(lambda x: len([w for w in x]))
dstream.pprint()
s.start()
s.awaitTermination()
</pre>

<h2 id="DStream"><a href="#DStream" class="headerlink" title="DStream"></a>DStream</h2><p>DStream被称为离散化流，和spark中的rdd类似。它会随着时间的推移而收到数据的队列。<br>在内部每个时间区间收到的数据都作为rdd存在，而dstream由这些rdd组成。</p>
<h3 id="DStream的输入源"><a href="#DStream的输入源" class="headerlink" title="DStream的输入源"></a>DStream的输入源</h3><ul>
<li>flume</li>
<li>kafka</li>
<li>hdfs</li>
<li>其它网络io</li>
</ul>
<h3 id="DStream的操作"><a href="#DStream的操作" class="headerlink" title="DStream的操作"></a>DStream的操作</h3><ul>
<li>转化</li>
<li>输出</li>
</ul>
<h2 id="架构与抽象"><a href="#架构与抽象" class="headerlink" title="架构与抽象"></a>架构与抽象</h2><p>使用“微批次”的架构，把流式计算当作一系列连续的小规模批处理来对待。Spark Streaming 从各种输入源中读取数据，并把数据分组为小的批次。新的批次按均匀的时间间隔创建出来。在每个时间区间开始的时候，一个新的批次就创建出来，在该区间内收到的数据都会被添加到这个批次中。在时间区间结束时，批次停止增长。时间区间的大小是由批次间隔这个参数决定的。批次间隔一般设在 500 毫秒到几秒之间，由应用开发者配置。每个输入批次都形成一个</p>
<pre>

        +---+--------------------------------+
------->| r |  +-----+ +-----+    +------+   |
        | c |  |     | |     | ...|      |   |   output
------->| e |  |     | |     |    |      |   | ---------->
        | v |  +-----+ +-----+    +------+   |
------->|   |    Spark Streaming             |
        +---+--------------------------------+

</pre>

<pre>
             +------+ +------+ +------+
DStream ---> | 0-1s | | 1-2s | | 2-3s | --->
             +------+ +------+ +------+
              RDD1    RDD2    RDD3
</pre>

<h2 id="转化操作"><a href="#转化操作" class="headerlink" title="转化操作"></a>转化操作</h2><h3 id="无状态转化"><a href="#无状态转化" class="headerlink" title="无状态转化"></a>无状态转化</h3><p>在无状态转化操作中，每个批次的处理不依赖于之前批次的数据。转化操作，例如 map() 、 filter() 、 reduceByKey() 等，都是无状态转化操作。</p>
<pre>
map: 对 DStream 中的每个元素应用给定函数，返回由各元素输出的元素组成的 DStream。
flatMap:
filter: 对 DStream 中的每个元素应用给定函数，返回由各元素输出的元素组成的 DStream。
repartition: 改变 DStream 的分区数。
reduceByKey: 将每个批次中键相同的记录归约。
groupByKey: 将每个批次中的记录根据键分组。
</pre>
<h3 id="有状态转化"><a href="#有状态转化" class="headerlink" title="有状态转化"></a>有状态转化</h3><p>相对地，有状态转化操作需要使用之前批次的数据或者是中间结果来计算当前批次的数据。有状态转化操作包括基于滑动窗口的转化操作和追踪状态变化的转化操作。</p>
<ul>
<li>设置窗口大小与滑动步长<pre>
...
stream.checkpoint("/checkpoint")
...
ds = stream.socketTextStream("192.168.0.103", 7777)
ds.window(3, 1) # 窗口大小与步长必须是时间间隔的整数倍。
</pre></li>
</ul>
<h2 id="输入源"><a href="#输入源" class="headerlink" title="输入源"></a>输入源</h2><ul>
<li><p>读取文件目录中的文本文件流</p>
 <pre>
 s = stream.textFileStream("logs")
 </pre></li>
<li><p>网络文本流</p>
<pre>
s = stream.socketTextStream("127.0.0.1", 7777)
</pre></li>
<li><p>其它流（flume, kafka etc）</p>
</li>
</ul>
<h3 id="数据源的合并"><a href="#数据源的合并" class="headerlink" title="数据源的合并"></a>数据源的合并</h3><p>如前文所述，可以使用类似 union() 这样的操作将多个 DStream 合并。通过这些操作符，可以把多个输入的 DStream 合并起来。有时，使用多个接收器对于提高聚合操作中的数据获取的吞吐量非常必要（如果只用一个接收器，可能会成为性能瓶颈）。另外，有时我们需要用不同的接收器来从不同的输入源中接收各种数据，然后使用</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>将dstream输出到数据库或文件系统之中，实现输出的api如下：</p>
<table>
<thead>
<tr>
<th>输出方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>print</td>
<td>将dstream数据输出到终端</td>
</tr>
<tr>
<td>saveAsTextFiles</td>
<td>将dstream保存到文本文本</td>
</tr>
<tr>
<td>saveAsObjectFiles</td>
<td>将dstream保存成对象文件</td>
</tr>
<tr>
<td>saveAsHadoopFiles</td>
<td>将dstream保存成hadoop文件</td>
</tr>
<tr>
<td>foreachRDD</td>
<td>迭代dstream，通过提供的回调函数处理传递的RDD</td>
</tr>
</tbody></table>
<h1 id="Spark大数据分析实例"><a href="#Spark大数据分析实例" class="headerlink" title="Spark大数据分析实例"></a>Spark大数据分析实例</h1><h2 id="购物篮分析"><a href="#购物篮分析" class="headerlink" title="购物篮分析"></a>购物篮分析</h2><p>购物篮分析(MarketBasketAnalysis,MBA)是一个流行的数据挖掘技术,市场营销和<br>电子商务专业人员经常用这个技术来揭示不同商品或商品组之间的相似度。数据挖掘的<br>一般目标是从庞大的数据集合中提取有趣的关联信息,例如数百万超市或信用卡销售交<br>易。购物篮分析可以帮助我们找出很可能会一起购买的商品,关联规则挖掘会发现一个<br>交易集中商品之间的相关性。然后市场营销人员可以使用这些关联规则在商店货架上或<br>在线将相关的商品搜放在相邻的位置,使顾客能购买更多的商品。为购物篮分析挖掘关<br>联规则时要找出频繁商品集,这是一个计算密集型问题,所以非常适合利用MapReduce<br>来解决。</p>
<p>在数据挖掘中，关联规则有两个度量标准：</p>
<ul>
<li>支持度。一个项集出现的频度，例如：Support({A,C}) = 2表示只在两个交易中同时出现</li>
<li>置信度。关联规则左件与右件共同出现的频繁程度。</li>
</ul>
<p>购物篮分析是用于回答以下问题：</p>
<ul>
<li>哪些商品会一起购买</li>
<li>每个购物篮有哪些商品</li>
<li>哪些商品应当降价</li>
<li>商品应当如何相邻摆放已实现最大利润</li>
</ul>
<h3 id="分析流程"><a href="#分析流程" class="headerlink" title="分析流程"></a>分析流程</h3><ol>
<li><p>给定交易清单：</p>
<pre><code> t1: crackers, icecream, coke, apple
 t2: chicken, pizza, coke, bread
 t3: baguette, soda, shampoo, crackers, pepsi, apple
 t4: baguette, cream, cheese, diapers, milk
 t5: crackers, coke, apple, baguette, soda
</code></pre>
</li>
<li><p>构建项集(1阶，2阶，3阶), 对于每次交易以两个组合。<br>例如：((crackers, icecream), 1), ((crackers, coke), 1), ….</p>
<pre><code>((chiken, pizza), 1), ((chiken, coke), 1), ((chiken, bread), 1), ((pizza, coke), 1), ...
((crackers, icecream, coke), 1), ((baguette, soda, apple), 2) ...
(crackers, 1), (icecream, 1), (coke, 1) ....
</code></pre>
</li>
<li><p>统计各个阶出现的频度<br>例如：((crackers, icecream), 1), ((coke, apple), 2), ((baguette, soda), 2) …</p>
<pre><code> (crackers, 2), (coke, 3) ....
</code></pre>
</li>
<li><p>生成所有子模式<br>例如： ((a, b, c), 2) =&gt;</p>
<pre><code>  ((a, b, c), (null, 2))
  ((a, b), ((a, b ,c), 2))
  ((a, c), ((a, b, c), 2))
  ((b, c), ((a, b, c), 2))
</code></pre>
</li>
<li><p>组合子模式(groupByKey)<br>例如：</p>
<pre><code> ([a,b],[(null,2),([a,b,d],1),([a,b,c],1)])
 ([a,b,d],[(null,1)])
 ([c],[(nu1l,3),([b,c],3),([a,c],1)])
 ([b,d],[([a,b,d],1),(null,1)])
 ([d],[([b,d],1),(null,1),([a,d],1)])
</code></pre>
</li>
<li><p>生成关联规则<br>例如：<br>[([a, b], [d], 0.5), ([a, b], [c], 0.5)]<br>[]<br>[([c], [b], 1), ([c], [a], 0.33333)]<br>….</p>
</li>
</ol>
<pre>

# 导出spark库
from pyspark import SparkContext, SparkConf
import re

# 组合算法
def combine(s, n):
    def _iterator(collector, s, i, c, n, data=None):
        if c >= n:
            collector.append(tuple(data))
            return

        for x in range(i, len(s)):
            data.append(s[x])
            _iterator(collector, s, x + 1, c + 1, n, data)
            data.pop()

    data_set = []
    chars = []
    _iterator(data_set, s, 0, 0, n, chars)
    return data_set

sparkConf = SparkConf()
sparkConf.set("spark.master", "spark://10.0.0.252:7077")
sparkConf.set("spark.app.name", "MBA")
sparkConf.set("spark.executor.memory", "512m")
sparkConf.set("spark.executor.cores", "2")

sparkContext = SparkContext.getOrCreate(sparkConf)
sparkContext.setLogLevel("ERROR")
rdd = sparkContext.textFile("file:///root/transaction.txt")


def parse_T(x):
    _, info = re.split(":\\s*", x)
    data = re.split("\\s*,\\s*", info)

    data_set = []

    for d in combine(data, 2) + combine(data, 3):
        data_set.append((d, 1))

    return data_set

# 按二阶三阶进行组合，分组并求出分组后的总和
rdd1 = rdd.flatMap(f=parse_T).groupByKey().mapValues(lambda v: sum(v))

def gen_sub_seq(x):
    key, value = x
    sub_data_set = [(key, (None, value))]
    keys = combine(key, len(key) - 1)
    for k in keys:
        sub_data_set.append((k, (key, value)))
    return sub_data_set

# 求子序列
rdd2 = rdd1.flatMap(f=gen_sub_seq).groupByKey().mapValues(lambda v: [i for i in v])

def not_list(src, dst):
    for x in dst:
        src.remove(x)
    return src


def do_result(x):
    key, value = x
    data_set = []
    total = 0
    for c in value:
        if c[0] == None:
            total = c[1]
        else:
            data_set.append(c)

    if not data_set:
        return data_set

    results = []
    for k, v in data_set:
        if total == 0:
            continue

        pp = float(v) / float(total)
        results.append((pp, (key, not_list(list(k), key))))

    return results

# 求关联性，并排序打印
rdd3 = rdd2.flatMap(f=do_result).sortByKey(ascending=False)
for x in rdd3.top(100):
    print(x)

sparkContext.stop()

</pre>

<h1 id="MLIB机器学习"><a href="#MLIB机器学习" class="headerlink" title="MLIB机器学习"></a>MLIB机器学习</h1><h2 id="机器学习分类"><a href="#机器学习分类" class="headerlink" title="机器学习分类"></a>机器学习分类</h2><ul>
<li>分类</li>
<li>回归</li>
<li>聚类</li>
</ul>
<h2 id="机器学习一般流程"><a href="#机器学习一般流程" class="headerlink" title="机器学习一般流程"></a>机器学习一般流程</h2><ul>
<li>使用字符串RDD表示消息</li>
<li>使用特征提取算法把文本数据转化为数值特征</li>
<li>对向量RDD调用分类算法，并返回模型</li>
<li>使用模型在测试数据集上测试</li>
<li>评估</li>
<li>部署</li>
</ul>
<h2 id="常用的机器学习算法"><a href="#常用的机器学习算法" class="headerlink" title="常用的机器学习算法"></a>常用的机器学习算法</h2><ul>
<li>分布式随机森林</li>
<li>K-means聚类算法</li>
<li>最小二乘发</li>
<li>支持向量机</li>
<li>等</li>
</ul>
<h2 id="spark机器学习"><a href="#spark机器学习" class="headerlink" title="spark机器学习"></a>spark机器学习</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>Vector</li>
</ul>
<p>既支持稠密向量也支持稀疏向量，前者表示向量的每一位都存储下来，后者则只存储非零位以节约空间。后面会简单讨论不同种类的向量。</p>
<ul>
<li>LabeledPoint</li>
</ul>
<p>用来表示带标签的数据点。它包含一个特征向量与一个标签（由一个浮点数表示)</p>
<ul>
<li>Rating</li>
</ul>
<p>用户对一个产品的评分，在 mllib.recommendation 包中，用于产品推荐。</p>
<ul>
<li>Model类</li>
</ul>
<p>每个 Model 都是训练算法的结果，一般有一个 predict() 方法可以用来对新的数据点或数据点组成的 RDD 应用该模型进行预测。</p>
<h3 id="分类与回归"><a href="#分类与回归" class="headerlink" title="分类与回归"></a>分类与回归</h3><p>分类与回归是监督式学习的两种主要形式。监督式学习指算法尝试使用有标签的训练数据（也就是已知结果的数据点）根据对象的特征预测结果。分类和回归的区别在于预测的变量的类型：在分类中，预测出的变量是离散的（也就是一个在有限集中的值，叫作类别）；比如，分类可能是将邮件分为垃圾邮件和非垃圾邮件，也有可能是文本所使用的语言。在回归中，预测出的变量是连续的（例如根据年龄和体重预测一个人的身高）。</p>
<ol>
<li>线性回归</li>
</ol>
<p>线性回归是回归中最常用的方法之一，是指用特征的线性组合来预测输出值。MLlib 也支 持 L1 和 L2 的正则的回归，通常称为 Lasso 和 ridge 回归。</p>
<pre>
from pyspark.mllib.regression import LabeledPoint 
from pyspark.mllib.regression import LinearRegressionWithSGD 
points = # (创建LabeledPoint组成的RDD) 
model = LinearRegressionWithSGD.train(points, iterations=200, intercept=True) 
print "weights: %s, intercept: %s" % (model.weights, model.intercept)
model.predict()
</pre>

<ol start="2">
<li>逻辑回归</li>
</ol>
<p>逻辑回归是一种二元分类方法，用来寻找一个分隔阴性和阳性示例的线性分割平面。逻辑回归是一种二元分类方法，用来寻找一个分隔阴性和阳性示例的线性分割平面。在MLlib中，它接收一组标签为0或1的LabeledPoint，返回可以预测新点的分类的 LogisticRegressionModel 对象。</p>
<ol start="3">
<li>支持向量机</li>
</ol>
<p>支持向量机（简称 SVM）算法是另一种使用线性分割平面的二元分类算法，同样只预期 0 或者 1 的标签。通过 SVMWithSGD 类，我们可以访问这种算法，它的参数与线性回归和逻辑回归的参数差不多。返回的 SVMModel 与 LogisticRegressionModel 一样使用阈值的方式进行预测。</p>
<ol start="4">
<li>朴素贝叶斯</li>
</ol>
<p>朴素贝叶斯（Naive Bayes）算法是一种多元分类算法，它使用基于特征的线性函数计算将一个点分到各类中的得分。这种算法通常用于使用 TF-IDF 特征的文本分类，以及其他一些应用。MLlib 实现了多项朴素贝叶斯算法，需要非负的频次（比如词频）作为输入特征。</p>
<ol start="5">
<li>决策树与随机森林</li>
</ol>
<p>决策树是一个灵活的模型，可以用来进行分类，也可以用来进行回归。决策树以节点树的形式表示，每个节点基于数据的特征作出一个二元决定（比如，这个人的年龄是否大于20 ？），而树的每个叶节点则包含一种预测结果（例如，这个人是不是会买一个产品？）。决策树的吸引力在于模型本身容易检查，而且决策树既支持分类的特征，也支持连续的特征。</p>
<h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><p>聚类算法是一种无监督学习任务，用于将对象分到具有高度相似性的聚类中。前面提到的监督式任务中的数据都是带标签的，而聚类可以用于无标签的数据。该算法主要用于数据探索（查看一个新数据集是什么样子）以及异常检测（识别与任意聚类都相距较远的点）。</p>
<ol>
<li>K-means</li>
</ol>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础01--计算机硬件</title>
    <url>/jwangcloud/1575270746/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/computer.jpeg"></p>
<h3 id="计算机硬件概述"><a href="#计算机硬件概述" class="headerlink" title="计算机硬件概述"></a>计算机硬件概述</h3><span id="more"></span>

<p>1.构成：内存、显卡、主板、硬盘、CPU</p>
<p>2.单位换算：1PB = 1024TB 1TB = 1024GB 1GB = 1024MB 1MB =             1024KB 1KB = 1024B 1B = 8b</p>
<p>3.软件与硬件：</p>
<pre><code>（1） 主板：属于集成其他硬件的基石 DDR4 DDR3等
（2） 显卡（GPU）:直接插在主板之上，用于图形处理 PCI-E插槽
（3） 内存：存储CPU所传输的信息（运算数据）与硬盘进行数据交换
（4） CPU：中央处理器，一个超大规模的集成电路、属于运算核心和控制核心
（5） 硬盘：存储内存中的传输信息，可以恢复（包含磁头、磁道、扇区、柱面）HDD SSD。
</code></pre>
<h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>1.python：编译与运行是同步进行，JAVA：先编译整体再运行，更稳定</p>
<p>2.编译器：将高级语言（python、Java c语言等）翻译成底层语言（机器汇编语言）</p>
<p>3.存储方式：机械硬盘：磁极确定01 固态硬盘：电信号（电压确定01）</p>
<p>4.数据传输方式：</p>
<pre><code>CPU --&gt;（写入） 内存 --&gt;（写入） 硬盘
    &lt;-- (读取)     &lt;-- （读取）
| -------    主板     ------|
</code></pre>
<p>5.SATA线：串行高级技术附件</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>python扩展知识02--IO编程</title>
    <url>/jwangcloud/3348220571/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/python01.jpeg"></p>
<h1 id="IO编程"><a href="#IO编程" class="headerlink" title="IO编程"></a>IO编程</h1><span id="more"></span>

<h3 id="1-IO"><a href="#1-IO" class="headerlink" title="1. IO"></a>1. IO</h3><p>IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。</p>
<blockquote>
<p>比如你打开浏览器，访问新浪首页，浏览器这个程序就需要通过网络IO获取新浪的网页。浏览器首先会发送数据给新浪服务器，告诉它我想要首页的HTML，这个动作是往外发数据，叫Output</p>
<p>随后新浪服务器把网页发过来，这个动作是从外面接收数据，叫Input。</p>
<p>通常，程序完成IO操作会有Input和Output两个数据流。当然也有只用一个的情况，比如，从磁盘读取文件到内存，就只有Input操作，反过来，把数据写到磁盘文件里，就只是一个Output操作。</p>
</blockquote>
<h3 id="2-stream"><a href="#2-stream" class="headerlink" title="2. stream"></a>2. stream</h3><p>IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。</p>
<blockquote>
<p>Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。</p>
<p>对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。</p>
</blockquote>
<p>由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法：</p>
<p><strong>1. 第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；</strong></p>
<p>2.另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。</p>
<h3 id="3-同步与异步区别"><a href="#3-同步与异步区别" class="headerlink" title="3. 同步与异步区别"></a>3. 同步与异步区别</h3><p>同步和异步的区别就在于是否等待IO执行的结果。</p>
<blockquote>
<p>好比你去麦当劳点餐，你说“来个汉堡”，服务员告诉你，对不起，汉堡要现做，需要等5分钟，于是你站在收银台前面等了5分钟，拿到汉堡再去逛商场，这是同步IO。</p>
</blockquote>
<blockquote>
<p>你说“来个汉堡”，服务员告诉你，汉堡需要等5分钟，你可以先去逛商场，等做好了，我们再通知你，这样你可以立刻去干别的事情（逛商场），这是异步IO。</p>
</blockquote>
<p>使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。</p>
<blockquote>
<p>总之，异步IO的复杂度远远高于同步IO。</p>
</blockquote>
<p>操作IO的能力都是由操作系统提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来方便使用，Python也不例外。我们后面会详细讨论Python的IO编程接口。</p>
<h1 id="同步IO"><a href="#同步IO" class="headerlink" title="同步IO"></a>同步IO</h1><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。</p>
<p>读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p>
<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><h4 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h4><ol>
<li><p>要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f &#x3D; open(&#39;&#x2F;Users&#x2F;michael&#x2F;test.txt&#39;, &#39;r&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>标示符’r’表示读，这样，我们就成功地打开了一个文件。</p>
</blockquote>
</li>
<li><p>如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f&#x3D;open(&#39;&#x2F;Users&#x2F;michael&#x2F;notfound.txt&#39;, &#39;r&#39;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">FileNotFoundError: [Errno 2] No such file or directory: &#39;&#x2F;Users&#x2F;michael&#x2F;notfound.txt&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">&#39;Hello, world!&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    f &#x3D; open(&#39;&#x2F;path&#x2F;to&#x2F;file&#39;, &#39;r&#39;)</span><br><span class="line">    print(f.read())</span><br><span class="line">finally:</span><br><span class="line">    if f:</span><br><span class="line">        f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&#39;&#x2F;path&#x2F;to&#x2F;file&#39;, &#39;r&#39;) as f:</span><br><span class="line">    print(f.read())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这和前面的try … finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。</p>
</blockquote>
</li>
<li><p>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p>
<blockquote>
<p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for line in f.readlines():</span><br><span class="line">    print(line.strip()) # 把末尾的&#39;\n&#39;删掉</span><br><span class="line">file-like Object</span><br></pre></td></tr></table></figure></li>
<li><p>像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。</p>
<blockquote>
<p>StringIO就是在内存中创建的file-like Object，常用作临时缓冲。</p>
</blockquote>
</li>
</ol>
<h4 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h4><ol>
<li><p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; open(&#39;&#x2F;Users&#x2F;michael&#x2F;test.jpg&#39;, &#39;rb&#39;)</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">b&#39;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&#39; # 十六进制表示的字节</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>字符编码<br>要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; open(&#39;&#x2F;Users&#x2F;michael&#x2F;gbk.txt&#39;, &#39;r&#39;, encoding&#x3D;&#39;gbk&#39;)</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">&#39;测试&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; open(&#39;&#x2F;Users&#x2F;michael&#x2F;gbk.txt&#39;, &#39;r&#39;, encoding&#x3D;&#39;gbk&#39;, errors&#x3D;&#39;ignore&#39;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><ol>
<li><p>写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; open(&#39;&#x2F;Users&#x2F;michael&#x2F;test.txt&#39;, &#39;w&#39;)</span><br><span class="line">&gt;&gt;&gt; f.write(&#39;Hello, world!&#39;)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。</p>
</blockquote>
<p> 所以，还是用with语句来得保险：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&#39;&#x2F;Users&#x2F;michael&#x2F;test.txt&#39;, &#39;w&#39;) as f:</span><br><span class="line">    f.write(&#39;Hello, world!&#39;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>要写入特定编码的文本文件，请给open()函数传入encoding参数，将字符串自动转换成指定编码。</p>
</blockquote>
</li>
</ol>
<ol start="2">
<li><p>以’w’模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以传入’a’以追加（append）模式写入。</p>
<blockquote>
<p>所有模式的定义及含义可以参考Python的<a href="https://docs.python.org/3/library/functions.html#open">官方文档</a>。</p>
</blockquote>
</li>
</ol>
<h2 id="StringIO和BytesIO"><a href="#StringIO和BytesIO" class="headerlink" title="StringIO和BytesIO"></a>StringIO和BytesIO</h2><h3 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>很多时候，数据读写不一定是文件，也可以在内存中读写。</p>
<p>StringIO顾名思义就是在内存中读写str。</p>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ol>
<li><p>要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from io import StringIO</span><br><span class="line">&gt;&gt;&gt; f &#x3D; StringIO()</span><br><span class="line">&gt;&gt;&gt; f.write(&#39;hello&#39;)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; f.write(&#39; &#39;)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; f.write(&#39;world!&#39;)</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; print(f.getvalue())</span><br><span class="line">hello world!</span><br><span class="line">getvalue()方法用于获得写入后的str。</span><br></pre></td></tr></table></figure></li>
<li><p>要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from io import StringIO</span><br><span class="line">&gt;&gt;&gt; f &#x3D; StringIO(&#39;Hello!\nHi!\nGoodbye!&#39;)</span><br><span class="line">&gt;&gt;&gt; while True:</span><br><span class="line">...     s &#x3D; f.readline()</span><br><span class="line">...     if s &#x3D;&#x3D; &#39;&#39;:</span><br><span class="line">...         break</span><br><span class="line">...     print(s.strip())</span><br><span class="line">...</span><br><span class="line">Hello!</span><br><span class="line">Hi!</span><br><span class="line">Goodbye!</span><br><span class="line">BytesIO</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。</p>
<blockquote>
<p>BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes：</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from io import BytesIO</span><br><span class="line">&gt;&gt;&gt; f &#x3D; BytesIO()</span><br><span class="line">&gt;&gt;&gt; f.write(&#39;中文&#39;.encode(&#39;utf-8&#39;))</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; print(f.getvalue())</span><br><span class="line">b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，写入的不是str，而是经过UTF-8编码的bytes。</p>
</blockquote>
</li>
</ol>
<ol start="4">
<li><p>和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from io import BytesIO</span><br><span class="line">&gt;&gt;&gt; f &#x3D; BytesIO(b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;)</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>代码</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from io import StringIO</span><br><span class="line"></span><br><span class="line"># write to StringIO:</span><br><span class="line">f &#x3D; StringIO()</span><br><span class="line">f.write(&#39;hello&#39;)</span><br><span class="line">f.write(&#39; &#39;)</span><br><span class="line">f.write(&#39;world!&#39;)</span><br><span class="line">print(f.getvalue())</span><br><span class="line"></span><br><span class="line"># read from StringIO:</span><br><span class="line">f &#x3D; StringIO(&#39;水面细风生，\n菱歌慢慢声。\n客亭临小市，\n灯火夜妆明。&#39;)</span><br><span class="line">while True:</span><br><span class="line">    s &#x3D; f.readline()</span><br><span class="line">    if s &#x3D;&#x3D; &#39;&#39;:</span><br><span class="line">        break</span><br><span class="line">    print(s.strip())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from io import BytesIO</span><br><span class="line"></span><br><span class="line"># write to BytesIO:</span><br><span class="line">f &#x3D; BytesIO()</span><br><span class="line">f.write(b&#39;hello&#39;)</span><br><span class="line">f.write(b&#39; &#39;)</span><br><span class="line">f.write(b&#39;world!&#39;)</span><br><span class="line">print(f.getvalue())</span><br><span class="line"></span><br><span class="line"># read from BytesIO:</span><br><span class="line">data &#x3D; &#39;人闲桂花落，夜静春山空。月出惊山鸟，时鸣春涧中。&#39;.encode(&#39;utf-8&#39;)</span><br><span class="line">f &#x3D; BytesIO(data)</span><br><span class="line">print(f.read())</span><br><span class="line">	</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>如果我们要操作文件、目录，可以在命令行下面输入操作系统提供的各种命令来完成。比如dir、cp等命令。</p>
<p>如果要在Python程序中执行这些目录和文件的操作怎么办？其实操作系统提供的命令只是简单地调用了操作系统提供的接口函数，Python内置的os模块也可以直接调用操作系统提供的接口函数。</p>
<h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><ol>
<li><p>打开Python交互式命令行，我们来看看如何使用os模块的基本功能：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.name # 操作系统类型</span><br><span class="line">&#39;posix&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果是posix，说明系统是Linux、Unix或Mac OS X，如果是nt，就是Windows系统。</p>
</blockquote>
</li>
<li><p>要获取详细的系统信息，可以调用uname()函数：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.uname()</span><br><span class="line">posix.uname_result(sysname&#x3D;&#39;Darwin&#39;, nodename&#x3D;&#39;MichaelMacPro.local&#39;, release&#x3D;&#39;14.3.0&#39;, </span><br><span class="line">version&#x3D;&#39;Darwin Kernel Version 14.3.0: Mon Mar 23 11:59:05 PDT 2015; </span><br><span class="line">root:xnu-2782.20.48~5&#x2F;RELEASE_X86_64&#39;, machine&#x3D;&#39;x86_64&#39;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意uname()函数在Windows上不提供，也就是说，os模块的某些函数是跟操作系统相关的。</p>
</blockquote>
</li>
<li><p>环境变量</p>
<p> 在操作系统中定义的环境变量，全部保存在os.environ这个变量中，可以直接查看：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.environ</span><br><span class="line">environ(&#123;&#39;VERSIONER_PYTHON_PREFER_32_BIT&#39;: &#39;no&#39;, &#39;TERM_PROGRAM_VERSION&#39;: &#39;326&#39;, &#39;LOGNAME&#39;: </span><br><span class="line">&#39;michael&#39;, &#39;USER&#39;: &#39;michael&#39;, &#39;PATH&#39;: &#39;&#x2F;usr&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:</span><br><span class="line">&#x2F;opt&#x2F;X11&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#39;, ...&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 要获取某个环境变量的值，可以调用os.environ.get(‘key’)：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.environ.get(&#39;PATH&#39;)</span><br><span class="line">&#39;&#x2F;usr&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;opt&#x2F;X11&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#39;</span><br><span class="line">&gt;&gt;&gt; os.environ.get(&#39;x&#39;, &#39;default&#39;)</span><br><span class="line">&#39;default&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="操作文件和目录-1"><a href="#操作文件和目录-1" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h3><ol>
<li><p>操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看当前目录的绝对路径:</span><br><span class="line">&gt;&gt;&gt; os.path.abspath(&#39;.&#39;)</span><br><span class="line">&#39;&#x2F;Users&#x2F;michael&#39;</span><br><span class="line"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span><br><span class="line">&gt;&gt;&gt; os.path.join(&#39;&#x2F;Users&#x2F;michael&#39;, &#39;testdir&#39;)</span><br><span class="line">&#39;&#x2F;Users&#x2F;michael&#x2F;testdir&#39;</span><br><span class="line"># 然后创建一个目录:</span><br><span class="line">&gt;&gt;&gt; os.mkdir(&#39;&#x2F;Users&#x2F;michael&#x2F;testdir&#39;)</span><br><span class="line"># 删掉一个目录:</span><br><span class="line">&gt;&gt;&gt; os.rmdir(&#39;&#x2F;Users&#x2F;michael&#x2F;testdir&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。在Linux/Unix/Mac下，os.path.join()返回这样的字符串：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">part-1&#x2F;part-2</span><br><span class="line">而Windows下会返回这样的字符串：</span><br><span class="line"></span><br><span class="line">part-1\part-2</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.split(&#39;&#x2F;Users&#x2F;michael&#x2F;testdir&#x2F;file.txt&#39;)</span><br><span class="line">(&#39;&#x2F;Users&#x2F;michael&#x2F;testdir&#39;, &#39;file.txt&#39;)</span><br><span class="line">os.path.splitext()可以直接让你得到文件扩展名，很多时候非常方便：</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; os.path.splitext(&#39;&#x2F;path&#x2F;to&#x2F;file.txt&#39;)</span><br><span class="line">(&#39;&#x2F;path&#x2F;to&#x2F;file&#39;, &#39;.txt&#39;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。</p>
</blockquote>
</li>
<li><p>文件操作使用下面的函数。假定当前目录下有一个test.txt文件：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 对文件重命名:</span><br><span class="line">&gt;&gt;&gt; os.rename(&#39;test.txt&#39;, &#39;test.py&#39;)</span><br><span class="line"># 删掉文件:</span><br><span class="line">&gt;&gt;&gt; os.remove(&#39;test.py&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是复制文件的函数居然在os模块中不存在！原因是复制文件并非由操作系统提供的系统调用。理论上讲，我们通过上一节的读写文件可以完成文件复制，只不过要多写很多代码。</p>
</blockquote>
<blockquote>
<p>幸运的是shutil模块提供了copyfile()的函数，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充。</p>
</blockquote>
</li>
<li><p>利用Python的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需要一行代码：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [x for x in os.listdir(&#39;.&#39;) if os.path.isdir(x)]</span><br><span class="line">[&#39;.lein&#39;, &#39;.local&#39;, &#39;.m2&#39;, &#39;.npm&#39;, &#39;.ssh&#39;, &#39;.Trash&#39;, &#39;.vim&#39;, &#39;Applications&#39;, &#39;Desktop&#39;, ...]</span><br><span class="line">要列出所有的.py文件，也只需一行代码：</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [x for x in os.listdir(&#39;.&#39;) if os.path.isfile(x) and os.path.splitext(x)[1]&#x3D;&#x3D;&#39;.py&#39;]</span><br><span class="line">[&#39;apis.py&#39;, &#39;config.py&#39;, &#39;models.py&#39;, &#39;pymonitor.py&#39;, &#39;test_db.py&#39;, &#39;urls.py&#39;, &#39;wsgiapp.py&#39;]</span><br><span class="line">是不是非常简洁？</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>小结</p>
</li>
</ol>
<p>Python的os模块封装了操作系统的目录和文件操作，要注意这些函数有的在os模块中，有的在os.path模块中。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from datetime import datetime</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">pwd &#x3D; os.path.abspath(&#39;.&#39;)</span><br><span class="line"></span><br><span class="line">print(&#39;      Size     Last Modified  Name&#39;)</span><br><span class="line">print(&#39;------------------------------------------------------------&#39;)</span><br><span class="line"></span><br><span class="line">for f in os.listdir(pwd):</span><br><span class="line">    fsize &#x3D; os.path.getsize(f)</span><br><span class="line">    mtime &#x3D; datetime.fromtimestamp(os.path.getmtime(f)).strftime(&#39;%Y-%m-%d %H:%M&#39;)</span><br><span class="line">    flag &#x3D; &#39;&#x2F;&#39; if os.path.isdir(f) else &#39;&#39;</span><br><span class="line">    print(&#39;%10d  %s  %s%s&#39; % (fsize, mtime, f, flag))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ol>
<li><p>在程序运行的过程中，所有的变量都是在内存中，比如，定义一个dict：</p>
<blockquote>
<p>d = dict(name=’Bob’, age=20, score=88)</p>
<p>可以随时修改变量，比如把name改成’Bill’，但是一旦程序结束，变量所占用的内存就被操作系统全部回收。如果没有把修改后的’Bill’存储到磁盘上，下次重新运行程序，变量又被初始化为’Bob’。</p>
</blockquote>
</li>
</ol>
<ol start="2">
<li><p>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</p>
</li>
<li><p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p>
</li>
<li><p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>
</li>
</ol>
<h3 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h3><h4 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h4><blockquote>
<p>Python提供了pickle模块来实现序列化。</p>
</blockquote>
<ol>
<li><p>首先，我们尝试把一个对象序列化并写入文件：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import pickle</span><br><span class="line">&gt;&gt;&gt; d &#x3D; dict(name&#x3D;&#39;Bob&#39;, age&#x3D;20, score&#x3D;88)</span><br><span class="line">&gt;&gt;&gt; pickle.dumps(d)</span><br><span class="line">b&#39;\x80\x03&#125;q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq</span><br><span class="line">\x03X\x03\x00\x00\x00Bobq\x04u.&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>pickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; open(&#39;dump.txt&#39;, &#39;wb&#39;)</span><br><span class="line">&gt;&gt;&gt; pickle.dump(d, f)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>看看写入的dump.txt文件，一堆乱七八糟的内容，这些都是Python保存的对象内部信息。</p>
</blockquote>
</li>
<li><p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用pickle.loads()方法反序列化出对象，也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象。我们打开另一个Python命令行来反序列化刚才保存的对象：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; open(&#39;dump.txt&#39;, &#39;rb&#39;)</span><br><span class="line">&gt;&gt;&gt; d &#x3D; pickle.load(f)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#39;age&#39;: 20, &#39;score&#39;: 88, &#39;name&#39;: &#39;Bob&#39;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个变量和原来的变量是完全不相干的对象，它们只是内容相同而已。</p>
</blockquote>
<blockquote>
<p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</p>
</blockquote>
</li>
</ol>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p>
<ol>
<li>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</li>
</ol>
<pre><code>|JSON类型|    Python类型
|:-:|:-:|
&#123;&#125;    |dict
[]    |list
&quot;string&quot;|    str
1234.56    |int或float
true/false    |True/False
null|    None
</code></pre>
<ol start="2">
<li><p>Python内置的json模块提供了非常完善的Python对象到JSON格式的转换。我们先看看如何把Python对象变成一个JSON：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import json</span><br><span class="line">&gt;&gt;&gt; d &#x3D; dict(name&#x3D;&#39;Bob&#39;, age&#x3D;20, score&#x3D;88)</span><br><span class="line">&gt;&gt;&gt; json.dumps(d)</span><br><span class="line">&#39;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>dumps()方法返回一个str，内容就是标准的JSON。类似的，dump()方法可以直接把JSON写入一个file-like Object。</p>
</blockquote>
</li>
<li><p>要把JSON反序列化为Python对象，用loads()或者对应的load()方法，前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; json_str &#x3D; &#39;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#39;</span><br><span class="line">&gt;&gt;&gt; json.loads(json_str)</span><br><span class="line">&#123;&#39;age&#39;: 20, &#39;score&#39;: 88, &#39;name&#39;: &#39;Bob&#39;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的str与JSON的字符串之间转换。</p>
</blockquote>
</li>
</ol>
<h4 id="JSON进阶"><a href="#JSON进阶" class="headerlink" title="JSON进阶"></a>JSON进阶</h4><ol>
<li>Python的dict对象可以直接序列化为JSON的{}，不过，很多时候，我们更喜欢用class表示对象，比如定义Student类，然后序列化： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name, age, score):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line">        self.score &#x3D; score</span><br><span class="line"></span><br><span class="line">s &#x3D; Student(&#39;Bob&#39;, 20, 88)</span><br><span class="line">print(json.dumps(s))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行代码，毫不留情地得到一个TypeError：</p>
</blockquote>
<blockquote>
<p>Traceback (most recent call last):</p>
<p>…</p>
<p>TypeError: &lt;__main__.Student object at 0x10603cc50&gt; is not JSON serializable</p>
</blockquote>
<blockquote>
<p>错误的原因是Student对象不是一个可序列化为JSON的对象。</p>
</blockquote>
</li>
</ol>
<ol start="2">
<li><p>dumps()方法的参数列表,除了第一个必须的obj参数外，dumps()方法还提供了一大堆的可选参数：</p>
<p> <a href="https://docs.python.org/3/library/json.html#json.dumps">https://docs.python.org/3/library/json.html#json.dumps</a></p>
</li>
</ol>
<p>这些可选参数就是让我们来定制JSON序列化。前面的代码之所以无法把Student类实例序列化为JSON，是因为默认情况下，dumps()方法不知道如何将Student实例变为一个JSON的{}对象。</p>
<p>可选参数default就是把任意一个对象变成一个可序列为JSON的对象，我们只需要为Student专门写一个转换函数，再把函数传进去即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def student2dict(std):</span><br><span class="line">    return &#123;</span><br><span class="line">        &#39;name&#39;: std.name,</span><br><span class="line">        &#39;age&#39;: std.age,</span><br><span class="line">        &#39;score&#39;: std.score</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样，Student实例首先被student2dict()函数转换成dict，然后再被顺利序列化为JSON：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(json.dumps(s, default&#x3D;student2dict))</span><br><span class="line">&#123;&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不过，下次如果遇到一个Teacher类的实例，照样无法序列化为JSON。我们可以偷个懒，把任意class的实例变为dict：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(json.dumps(s, default&#x3D;lambda obj: obj.__dict__))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为通常class的实例都有一个__dict__属性，它就是一个dict，用来存储实例变量。也有少数例外，比如定义了__slots__的class。</p>
<ol start="3">
<li>同样的道理，如果我们要把JSON反序列化为一个Student对象实例，loads()方法首先转换出一个dict对象，然后，我们传入的object_hook函数负责把dict转换为Student实例： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def dict2student(d):</span><br><span class="line">    return Student(d[&#39;name&#39;], d[&#39;age&#39;], d[&#39;score&#39;])</span><br><span class="line">运行结果如下：</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; json_str &#x3D; &#39;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#39;</span><br><span class="line">&gt;&gt;&gt; print(json.loads(json_str, object_hook&#x3D;dict2student))</span><br><span class="line">&lt;__main__.Student object at 0x10cd3c190&gt;</span><br><span class="line">打印出的是反序列化的Student实例对象。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li><p>Python语言特定的序列化模块是pickle，但如果要把序列化搞得更通用、更符合Web标准，就可以使用json模块。</p>
</li>
<li><p>json模块的dumps()和loads()函数是定义得非常好的接口的典范。当我们使用时，只需要传入一个必须的参数。但是，当默认的序列化或反序列机制不满足我们的要求时，我们又可以传入更多的参数来定制序列化或反序列化的规则，既做到了接口简单易用，又做到了充分的扩展性和灵活性。</p>
</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import pickle</span><br><span class="line"></span><br><span class="line">d &#x3D; dict(name&#x3D;&#39;Bob&#39;, age&#x3D;20, score&#x3D;88)</span><br><span class="line">data &#x3D; pickle.dumps(d)</span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line">reborn &#x3D; pickle.loads(data)</span><br><span class="line">print(reborn)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">d &#x3D; dict(name&#x3D;&#39;Bob&#39;, age&#x3D;20, score&#x3D;88)</span><br><span class="line">data &#x3D; json.dumps(d)</span><br><span class="line">print(&#39;JSON Data is a str:&#39;, data)</span><br><span class="line">reborn &#x3D; json.loads(data)</span><br><span class="line">print(reborn)</span><br><span class="line"></span><br><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, age, score):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line">        self.score &#x3D; score</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &#39;Student object (%s, %s, %s)&#39; % (self.name, self.age, self.score)</span><br><span class="line"></span><br><span class="line">s &#x3D; Student(&#39;Bob&#39;, 20, 88)</span><br><span class="line">std_data &#x3D; json.dumps(s, default&#x3D;lambda obj: obj.__dict__)</span><br><span class="line">print(&#39;Dump Student:&#39;, std_data)</span><br><span class="line">rebuild &#x3D; json.loads(std_data, object_hook&#x3D;lambda d: Student(d[&#39;name&#39;], d[&#39;age&#39;], d[&#39;score&#39;]))</span><br><span class="line">print(rebuild)</span><br></pre></td></tr></table></figure>
</code></pre>
<p>#异步IO</p>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ol>
<li><p>CPU的速度远远快于磁盘、网络等IO。在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。</p>
<blockquote>
<p>在IO操作的过程中，当前线程被挂起，而其他需要CPU执行的代码就无法被当前线程执行了。</p>
</blockquote>
<blockquote>
<p>因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用多线程或者多进程来并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。</p>
</blockquote>
</li>
<li><p>多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。</p>
<p> 由于我们要解决的问题是CPU高速执行能力和IO设备的龟速严重不匹配，多线程和多进程只是解决这一问题的一种方法。</p>
<p> 另一种解决IO问题的方法是异步IO。当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。</p>
</li>
<li><p>如果按普通顺序写出的代码实际上是没法完成异步IO的：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do_some_code()</span><br><span class="line">f &#x3D; open(&#39;&#x2F;path&#x2F;to&#x2F;file&#39;, &#39;r&#39;)</span><br><span class="line">r &#x3D; f.read() # &lt;&#x3D;&#x3D; 线程停在此处等待IO操作结果</span><br><span class="line"># IO操作完成后线程才能继续执行:</span><br><span class="line">do_some_code(r)</span><br><span class="line">所以，同步IO模型的代码是无法实现异步IO模型的。</span><br></pre></td></tr></table></figure></li>
<li><p>异步IO模型需要一个消息循环，在消息循环中，主线程不断地重复“读取消息-处理消息”这一过程：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loop &#x3D; get_event_loop()</span><br><span class="line">while True:</span><br><span class="line">    event &#x3D; loop.get_event()</span><br><span class="line">    process_event(event)</span><br></pre></td></tr></table></figure></li>
<li><p>消息模型其实早在应用在桌面应用程序中了。一个GUI程序的主线程就负责不停地读取消息并处理消息。所有的键盘、鼠标等消息都被发送到GUI程序的消息队列中，然后由GUI程序的主线程处理。</p>
</li>
<li><p>由于GUI线程处理键盘、鼠标等消息的速度非常快，所以用户感觉不到延迟。某些时候，GUI线程在一个消息处理的过程中遇到问题导致一次消息处理时间过长，此时，用户会感觉到整个GUI程序停止响应了，敲键盘、点鼠标都没有反应。这种情况说明在消息模型中，处理一个消息必须非常迅速，否则，主线程将无法及时处理消息队列中的其他消息，导致程序看上去停止响应。</p>
</li>
<li><p>消息模型是如何解决同步IO必须等待IO操作这一问题的呢？当遇到IO操作时，代码只负责发出IO请求，不等待IO结果，然后直接结束本轮消息处理，进入下一轮消息处理过程。当IO操作完成后，将收到一条“IO完成”的消息，处理该消息时就可以直接获取IO操作结果。</p>
</li>
<li><p>在“发出IO请求”到收到“IO完成”的这段时间里，同步IO模型下，主线程只能挂起，但异步IO模型下，主线程并没有休息，而是在消息循环中继续处理其他消息。这样，在异步IO模型下，一个线程就可以同时处理多个IO请求，并且没有切换线程的操作。对于大多数IO密集型的应用程序，使用异步IO将大大提升系统的多任务处理能力。</p>
</li>
</ol>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><ol>
<li><p>协程，又称微线程，纤程。英文名Coroutine。</p>
</li>
<li><p>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。</p>
<blockquote>
<p>所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。</p>
</blockquote>
<blockquote>
<p>子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p>
</blockquote>
<blockquote>
<p>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
</blockquote>
</li>
</ol>
<ol start="3">
<li><p>注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。比如子程序A、B：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def A():</span><br><span class="line">   	print(&#39;1&#39;)</span><br><span class="line">   	print(&#39;2&#39;)</span><br><span class="line">   	print(&#39;3&#39;)</span><br><span class="line"></span><br><span class="line">def B():</span><br><span class="line">   	print(&#39;x&#39;)</span><br><span class="line">   	print(&#39;y&#39;)</span><br><span class="line">   	print(&#39;z&#39;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是：</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line">3</span><br><span class="line">z</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是在A中是没有调用B的，所以协程的调用比函数调用理解起来要难一些。</p>
</blockquote>
<blockquote>
<p>看起来A、B的执行有点像多线程，但协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</p>
</blockquote>
</li>
</ol>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol>
<li><p>最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
</li>
<li><p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<blockquote>
<p>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p>
</blockquote>
</li>
</ol>
<h3 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h3><ol>
<li><p>Python对协程的支持是通过generator实现的。</p>
<blockquote>
<p>在generator中，我们不但可以通过for循环来迭代，还可以不断调用next()函数获取由yield语句返回的下一个值。</p>
</blockquote>
</li>
<li><p>Python的yield不但可以返回一个值，它还可以接收调用者发出的参数。</p>
<blockquote>
<p>来看例子：</p>
</blockquote>
<blockquote>
<p>传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。</p>
</blockquote>
<blockquote>
<p>如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def consumer():</span><br><span class="line">    r &#x3D; &#39;&#39;</span><br><span class="line">    while True:</span><br><span class="line">        n &#x3D; yield r</span><br><span class="line">        if not n:</span><br><span class="line">            return</span><br><span class="line">        print(&#39;[CONSUMER] Consuming %s...&#39; % n)</span><br><span class="line">        r &#x3D; &#39;200 OK&#39;</span><br><span class="line"></span><br><span class="line">def produce(c):</span><br><span class="line">    c.send(None)</span><br><span class="line">    n &#x3D; 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        n &#x3D; n + 1</span><br><span class="line">        print(&#39;[PRODUCER] Producing %s...&#39; % n)</span><br><span class="line">        r &#x3D; c.send(n)</span><br><span class="line">        print(&#39;[PRODUCER] Consumer return: %s&#39; % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line">c &#x3D; consumer()</span><br><span class="line">produce(c)</span><br><span class="line">执行结果：</span><br><span class="line"></span><br><span class="line">[PRODUCER] Producing 1...</span><br><span class="line">[CONSUMER] Consuming 1...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 2...</span><br><span class="line">[CONSUMER] Consuming 2...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 3...</span><br><span class="line">[CONSUMER] Consuming 3...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 4...</span><br><span class="line">[CONSUMER] Consuming 4...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 5...</span><br><span class="line">[CONSUMER] Consuming 5...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意到consumer函数是一个generator，把一个consumer传入produce后：</p>
<blockquote>
<ol>
<li>首先调用c.send(None)启动生成器；</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>然后，一旦生产了东西，通过c.send(n)切换到consumer执行；</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>consumer通过yield拿到消息，处理，又通过yield把结果传回；</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>produce拿到consumer处理的结果，继续生产下一条消息；</li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li>produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</li>
</ol>
</blockquote>
<blockquote>
<p>整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p>
</blockquote>
</li>
</ol>
<p><s>协程的特点：“子程序就是协程的一种特例。”</s></p>
<h2 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>asyncio是Python 3.4版本引入的标准库，直接内置了对异步IO的支持。</p>
<p>asyncio的编程模型就是一个消息循环。我们从asyncio模块中直接获取一个EventLoop的引用，然后把需要执行的协程扔到EventLoop中执行，就实现了异步IO。</p>
<h3 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h3><ol>
<li>用asyncio实现Hello world代码如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">@asyncio.coroutine</span><br><span class="line">def hello():</span><br><span class="line">    print(&quot;Hello world!&quot;)</span><br><span class="line">    # 异步调用asyncio.sleep(1):</span><br><span class="line">    r &#x3D; yield from asyncio.sleep(1)</span><br><span class="line">    print(&quot;Hello again!&quot;)</span><br><span class="line"></span><br><span class="line"># 获取EventLoop:</span><br><span class="line">loop &#x3D; asyncio.get_event_loop()</span><br><span class="line"># 执行coroutine</span><br><span class="line">loop.run_until_complete(hello())</span><br><span class="line">loop.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>@asyncio.coroutine把一个generator标记为coroutine类型，然后，我们就把这个coroutine扔到EventLoop中执行。</p>
</blockquote>
<p>hello()会首先打印出Hello world!，然后，yield from语法可以让我们方便地调用另一个generator。</p>
<p>由于asyncio.sleep()也是一个coroutine，所以线程不会等待asyncio.sleep()，而是直接中断并执行下一个消息循环。当asyncio.sleep()返回时，线程就可以从yield from拿到返回值（此处是None），然后接着执行下一行语句。</p>
<p>把asyncio.sleep(1)看成是一个耗时1秒的IO操作，在此期间，主线程并未等待，而是去执行EventLoop中其他可以执行的coroutine了，因此可以实现并发执行。</p>
<ol start="2">
<li>我们用Task封装两个coroutine试试：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">@asyncio.coroutine</span><br><span class="line">def hello():</span><br><span class="line">    print(&#39;Hello world! (%s)&#39; % threading.currentThread())</span><br><span class="line">    yield from asyncio.sleep(1)</span><br><span class="line">    print(&#39;Hello again! (%s)&#39; % threading.currentThread())</span><br><span class="line"></span><br><span class="line">loop &#x3D; asyncio.get_event_loop()</span><br><span class="line">tasks &#x3D; [hello(), hello()]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br><span class="line">观察执行过程：</span><br><span class="line"></span><br><span class="line">Hello world! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)</span><br><span class="line">Hello world! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)</span><br><span class="line">(暂停约1秒)</span><br><span class="line">Hello again! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)</span><br><span class="line">Hello again! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)</span><br><span class="line">由打印的当前线程名称可以看出，两个coroutine是由同一个线程并发执行的。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果把asyncio.sleep()换成真正的IO操作，则多个coroutine就可以由一个线程并发执行。</p>
</blockquote>
<ol start="3">
<li>我们用asyncio的异步网络连接来获取sina、sohu和163的网站首页：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">@asyncio.coroutine</span><br><span class="line">def wget(host):</span><br><span class="line">    print(&#39;wget %s...&#39; % host)</span><br><span class="line">    connect &#x3D; asyncio.open_connection(host, 80)</span><br><span class="line">    reader, writer &#x3D; yield from connect</span><br><span class="line">    header &#x3D; &#39;GET &#x2F; HTTP&#x2F;1.0\r\nHost: %s\r\n\r\n&#39; % host</span><br><span class="line">    writer.write(header.encode(&#39;utf-8&#39;))</span><br><span class="line">    yield from writer.drain()</span><br><span class="line">    while True:</span><br><span class="line">        line &#x3D; yield from reader.readline()</span><br><span class="line">        if line &#x3D;&#x3D; b&#39;\r\n&#39;:</span><br><span class="line">            break</span><br><span class="line">        print(&#39;%s header &gt; %s&#39; % (host, line.decode(&#39;utf-8&#39;).rstrip()))</span><br><span class="line">    # Ignore the body, close the socket</span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line">loop &#x3D; asyncio.get_event_loop()</span><br><span class="line">tasks &#x3D; [wget(host) for host in [&#39;www.sina.com.cn&#39;, &#39;www.sohu.com&#39;, &#39;www.163.com&#39;]]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br><span class="line">执行结果如下：</span><br><span class="line"></span><br><span class="line">wget www.sohu.com...</span><br><span class="line">wget www.sina.com.cn...</span><br><span class="line">wget www.163.com...</span><br><span class="line">(等待一段时间)</span><br><span class="line">(打印出sohu的header)</span><br><span class="line">www.sohu.com header &gt; HTTP&#x2F;1.1 200 OK</span><br><span class="line">www.sohu.com header &gt; Content-Type: text&#x2F;html</span><br><span class="line">...</span><br><span class="line">(打印出sina的header)</span><br><span class="line">www.sina.com.cn header &gt; HTTP&#x2F;1.1 200 OK</span><br><span class="line">www.sina.com.cn header &gt; Date: Wed, 20 May 2015 04:56:33 GMT</span><br><span class="line">...</span><br><span class="line">(打印出163的header)</span><br><span class="line">www.163.com header &gt; HTTP&#x2F;1.0 302 Moved Temporarily</span><br><span class="line">www.163.com header &gt; Server: Cdn Cache Server V2.0</span><br><span class="line">...</span><br><span class="line">可见3个连接由一个线程通过coroutine并发完成。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ol>
<li><p>asyncio提供了完善的异步IO支持；</p>
</li>
<li><p>异步操作需要在coroutine中通过yield from完成；</p>
</li>
<li><p>多个coroutine可以封装成一组Task然后并发执行。</p>
</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import threading</span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">@asyncio.coroutine</span><br><span class="line">def hello():</span><br><span class="line">    print(&#39;Hello world! (%s)&#39; % threading.currentThread())</span><br><span class="line">    yield from asyncio.sleep(1)</span><br><span class="line">    print(&#39;Hello again! (%s)&#39; % threading.currentThread())</span><br><span class="line"></span><br><span class="line">loop &#x3D; asyncio.get_event_loop()</span><br><span class="line">tasks &#x3D; [hello(), hello()]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">@asyncio.coroutine</span><br><span class="line">def wget(host):</span><br><span class="line">    print(&#39;wget %s...&#39; % host)</span><br><span class="line">    connect &#x3D; asyncio.open_connection(host, 80)</span><br><span class="line">    reader, writer &#x3D; yield from connect</span><br><span class="line">    header &#x3D; &#39;GET &#x2F; HTTP&#x2F;1.0\r\nHost: %s\r\n\r\n&#39; % host</span><br><span class="line">    writer.write(header.encode(&#39;utf-8&#39;))</span><br><span class="line">    yield from writer.drain()</span><br><span class="line">    while True:</span><br><span class="line">        line &#x3D; yield from reader.readline()</span><br><span class="line">        if line &#x3D;&#x3D; b&#39;\r\n&#39;:</span><br><span class="line">            break</span><br><span class="line">        print(&#39;%s header &gt; %s&#39; % (host, line.decode(&#39;utf-8&#39;).rstrip()))</span><br><span class="line">    # Ignore the body, close the socket</span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line">loop &#x3D; asyncio.get_event_loop()</span><br><span class="line">tasks &#x3D; [wget(host) for host in [&#39;www.sina.com.cn&#39;, &#39;www.sohu.com&#39;, &#39;www.163.com&#39;]]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><ol>
<li><p>用asyncio提供的@asyncio.coroutine可以把一个generator标记为coroutine类型，然后在coroutine内部用yield from调用另一个coroutine实现异步操作。</p>
</li>
<li><p>为了简化并更好地标识异步IO，从Python 3.5开始引入了新的语法async和await，可以让coroutine的代码更简洁易读。</p>
</li>
<li><p>注意，async和await是针对coroutine的新语法，要使用新的语法，只需要做两步简单的替换：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">把@asyncio.coroutine替换为async；</span><br><span class="line">把yield from替换为await。</span><br><span class="line">让我们对比一下上一节的代码：</span><br><span class="line"></span><br><span class="line">@asyncio.coroutine</span><br><span class="line">def hello():</span><br><span class="line">    print(&quot;Hello world!&quot;)</span><br><span class="line">    r &#x3D; yield from asyncio.sleep(1)</span><br><span class="line">    print(&quot;Hello again!&quot;)</span><br><span class="line">用新语法重新编写如下：</span><br><span class="line"></span><br><span class="line">async def hello():</span><br><span class="line">    print(&quot;Hello world!&quot;)</span><br><span class="line">    r &#x3D; await asyncio.sleep(1)</span><br><span class="line">    print(&quot;Hello again!&quot;)</span><br><span class="line">剩下的代码保持不变。</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Python从3.5版本开始为asyncio提供了async和await的新语法；</p>
<p>注意新语法只能用在Python 3.5以及后续版本，如果使用3.4版本，则仍需使用上一节的方案。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import threading</span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def hello():</span><br><span class="line">    print(&#39;Hello world! (%s)&#39; % threading.currentThread())</span><br><span class="line">    await asyncio.sleep(1)</span><br><span class="line">    print(&#39;Hello again! (%s)&#39; % threading.currentThread())</span><br><span class="line"></span><br><span class="line">loop &#x3D; asyncio.get_event_loop()</span><br><span class="line">tasks &#x3D; [hello(), hello()]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import threading</span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def hello():</span><br><span class="line">    print(&#39;Hello world! (%s)&#39; % threading.currentThread())</span><br><span class="line">    await asyncio.sleep(1)</span><br><span class="line">    print(&#39;Hello again! (%s)&#39; % threading.currentThread())</span><br><span class="line"></span><br><span class="line">loop &#x3D; asyncio.get_event_loop()</span><br><span class="line">tasks &#x3D; [hello(), hello()]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><ol>
<li><p>asyncio可以实现单线程并发IO操作。如果仅用在客户端，发挥的威力不大。如果把asyncio用在服务器端，例如Web服务器，由于HTTP连接就是IO操作，因此可以用单线程+coroutine实现多用户的高并发支持。</p>
</li>
<li><p>asyncio实现了TCP、UDP、SSL等协议，aiohttp则是基于asyncio实现的HTTP框架。</p>
</li>
</ol>
<h3 id="操作-4"><a href="#操作-4" class="headerlink" title="操作"></a>操作</h3><ol>
<li><p>安装aiohttp：</p>
<pre><code> pip install aiohttp
</code></pre>
</li>
<li><p>然后编写一个HTTP服务器，分别处理以下URL：</p>
<pre><code> / - 首页返回b&#39;&lt;h1&gt;Index&lt;/h1&gt;&#39;；

 /hello/&#123;name&#125; - 根据URL参数返回文本hello, %s!。
</code></pre>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">代码如下：</span><br><span class="line"></span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">from aiohttp import web</span><br><span class="line"></span><br><span class="line">async def index(request):</span><br><span class="line">    await asyncio.sleep(0.5)</span><br><span class="line">    return web.Response(body&#x3D;b&#39;&lt;h1&gt;Index&lt;&#x2F;h1&gt;&#39;)</span><br><span class="line"></span><br><span class="line">async def hello(request):</span><br><span class="line">    await asyncio.sleep(0.5)</span><br><span class="line">    text &#x3D; &#39;&lt;h1&gt;hello, %s!&lt;&#x2F;h1&gt;&#39; % request.match_info[&#39;name&#39;]</span><br><span class="line">    return web.Response(body&#x3D;text.encode(&#39;utf-8&#39;))</span><br><span class="line"></span><br><span class="line">async def init(loop):</span><br><span class="line">    app &#x3D; web.Application(loop&#x3D;loop)</span><br><span class="line">    app.router.add_route(&#39;GET&#39;, &#39;&#x2F;&#39;, index)</span><br><span class="line">    app.router.add_route(&#39;GET&#39;, &#39;&#x2F;hello&#x2F;&#123;name&#125;&#39;, hello)</span><br><span class="line">    srv &#x3D; await loop.create_server(app.make_handler(), &#39;127.0.0.1&#39;, 8000)</span><br><span class="line">    print(&#39;Server started at http:&#x2F;&#x2F;127.0.0.1:8000...&#39;)</span><br><span class="line">    return srv</span><br><span class="line"></span><br><span class="line">loop &#x3D; asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(init(loop))</span><br><span class="line">loop.run_forever()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意aiohttp的初始化函数init()也是一个coroutine，loop.create_server()则利用asyncio创建TCP服务。</p>
</blockquote>
</li>
</ol>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">__author__ &#x3D; &#39;Michael Liao&#39;</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">async web application.</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">from aiohttp import web</span><br><span class="line"></span><br><span class="line">async def index(request):</span><br><span class="line">    await asyncio.sleep(0.5)</span><br><span class="line">    return web.Response(body&#x3D;b&#39;&lt;h1&gt;Index&lt;&#x2F;h1&gt;&#39;)</span><br><span class="line"></span><br><span class="line">async def hello(request):</span><br><span class="line">    await asyncio.sleep(0.5)</span><br><span class="line">    text &#x3D; &#39;&lt;h1&gt;hello, %s!&lt;&#x2F;h1&gt;&#39; % request.match_info[&#39;name&#39;]</span><br><span class="line">    return web.Response(body&#x3D;text.encode(&#39;utf-8&#39;))</span><br><span class="line"></span><br><span class="line">async def init(loop):</span><br><span class="line">    app &#x3D; web.Application(loop&#x3D;loop)</span><br><span class="line">    app.router.add_route(&#39;GET&#39;, &#39;&#x2F;&#39;, index)</span><br><span class="line">    app.router.add_route(&#39;GET&#39;, &#39;&#x2F;hello&#x2F;&#123;name&#125;&#39;, hello)</span><br><span class="line">    srv &#x3D; await loop.create_server(app.make_handler(), &#39;127.0.0.1&#39;, 8000)</span><br><span class="line">    print(&#39;Server started at http:&#x2F;&#x2F;127.0.0.1:8000...&#39;)</span><br><span class="line">    return srv</span><br><span class="line"></span><br><span class="line">loop &#x3D; asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(init(loop))</span><br><span class="line">loop.run_forever()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python扩展</category>
      </categories>
      <tags>
        <tag>pythonIO编程</tag>
      </tags>
  </entry>
  <entry>
    <title>python扩展知识01--设计模式</title>
    <url>/jwangcloud/1761882267/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/python01.jpeg"></p>
<h3 id="python与设计模式"><a href="#python与设计模式" class="headerlink" title="python与设计模式"></a>python与设计模式</h3><span id="more"></span>

<h4 id="1-定义："><a href="#1-定义：" class="headerlink" title="1.定义："></a>1.定义：</h4><blockquote>
<p>设计模式是面对各种问题进行提炼和抽象而形成的解决方案。这些设计方案是前人不断试验，考虑了封装性、复用性、效率、可修改、可移植等各种因素的高度总结。它不限于一种特定的语言，它是一种解决问题的思想和方法。</p>
</blockquote>
<h4 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h4><p>设计模式可以分为三个大类：创建类设计模式、结构类设计模式、行为类设计模式。</p>
<p>创建类设计模式可以分为</p>
<blockquote>
<p>单例模式、工厂模式、抽象工厂模式、原型模式、建造者模式；</p>
</blockquote>
<p>结构类设计模式可以分为</p>
<blockquote>
<p>装饰器模式、适配器模式、门面模式、组合模式、享元模式、桥梁模式；</p>
</blockquote>
<p>行为类设计模式可以细分为</p>
<blockquote>
<p>策略模式、责任链模式、命令模式、中介者模式、模板模式、迭代器模式、访问者模式、观察者模式、解释器模式、备忘录模式、状态模式。</p>
</blockquote>
<h4 id="3-设计模式与软件框架"><a href="#3-设计模式与软件框架" class="headerlink" title="3.设计模式与软件框架"></a>3.设计模式与软件框架</h4><p>设计模式和软件框架在软件设计中是两个不同的研究领域：</p>
<blockquote>
<p>A、设计模式如前边的定义所讲，它指的是针对一类问题的解决方法，一个设计模式可应用于不同的框架和被不同的语言所实现；而框架则是一个应用的体系结构，是一种或多种设计模式和代码的混合体；</p>
</blockquote>
<blockquote>
<p>B、设计模式相较于框架更容易移植，并且可以用各种语言实现，而软件框架则受限于领域大环境。虽然设计模式和软件框架有很多不同，但在某些方面他们二者是统一的，即重视软件复用，提高开发效率。</p>
</blockquote>
<h4 id="4-软件架构和设计模式"><a href="#4-软件架构和设计模式" class="headerlink" title="4.软件架构和设计模式"></a>4.软件架构和设计模式</h4><p>软件架构可以由不同的框架和不同的设计模式，再加上特定的构件组合来实现；</p>
<p>框架可以根据设计模式结合特定编程语言和环境来实现。</p>
<p>设计模式就是解决单一问题的设计思路和解决方法。</p>
<h3 id="python与设计模式–单例模式"><a href="#python与设计模式–单例模式" class="headerlink" title="python与设计模式–单例模式"></a>python与设计模式–单例模式</h3><h4 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h4><blockquote>
<p>单例模式是所有设计模式中比较简单的一类，其定义如下：Ensure a class has only one instance, and provide a global point of access to it.（保证某一个类只有一个实例，而且在全局只有一个访问点）</p>
</blockquote>
<h4 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h4><ol>
<li>模块：</li>
</ol>
<blockquote>
<p>Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc<br>文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singleton(object):</span><br><span class="line">    def foo(self):</span><br><span class="line">        pass</span><br><span class="line">singleton &#x3D; Singleton()</span><br><span class="line"></span><br><span class="line">from a import singleton</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>装饰器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def Singleton(cls):</span><br><span class="line">    _instance &#x3D; &#123;&#125;</span><br><span class="line">    def _singleton(*args, **kargs):</span><br><span class="line">        if cls not in _instance:</span><br><span class="line">            _instance[cls] &#x3D; cls(*args, **kargs)</span><br><span class="line">        return _instance[cls]</span><br><span class="line">    return _singleton</span><br><span class="line"></span><br><span class="line">@Singleton</span><br><span class="line">class A(object):</span><br><span class="line">    a &#x3D; 1</span><br><span class="line">    def __init__(self, x&#x3D;0):</span><br><span class="line">        self.x &#x3D; x</span><br><span class="line"></span><br><span class="line">a1 &#x3D; A(2)</span><br><span class="line">a2 &#x3D; A(3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>类(多线程)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">import threading</span><br><span class="line">class Singleton(object):</span><br><span class="line">    _instance_lock &#x3D; threading.Lock()</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def instance(cls, *args, **kwargs):</span><br><span class="line">        if not hasattr(Singleton, &quot;_instance&quot;):</span><br><span class="line">            with Singleton._instance_lock:</span><br><span class="line">                if not hasattr(Singleton, &quot;_instance&quot;):</span><br><span class="line">                    Singleton._instance &#x3D; Singleton(*args, **kwargs)</span><br><span class="line">        return Singleton._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task(arg):</span><br><span class="line">    obj &#x3D; Singleton.instance()</span><br><span class="line">    print(obj)</span><br><span class="line">for i in range(10):</span><br><span class="line">    t &#x3D; threading.Thread(target&#x3D;task,args&#x3D;[i,])</span><br><span class="line">    t.start()</span><br><span class="line">time.sleep(20)</span><br><span class="line">obj &#x3D; Singleton.instance()</span><br><span class="line">print(obj)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>基于__new__方法</li>
</ol>
<blockquote>
<p>实例化一个对象时，是先执行了类的__new__方法，实例化对象；然后再执行类的__init__方法，对这个对象进行初始化，所有我们可以基于这个，实现单例模式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">class Singleton(object):</span><br><span class="line">    _instance_lock &#x3D; threading.Lock()</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        if not hasattr(Singleton, &quot;_instance&quot;):</span><br><span class="line">            with Singleton._instance_lock:</span><br><span class="line">                if not hasattr(Singleton, &quot;_instance&quot;):</span><br><span class="line">                    Singleton._instance &#x3D; object.__new__(cls)  </span><br><span class="line">        return Singleton._instance</span><br><span class="line"></span><br><span class="line">obj1 &#x3D; Singleton()</span><br><span class="line">obj2 &#x3D; Singleton()</span><br><span class="line">print(obj1,obj2)</span><br><span class="line"></span><br><span class="line">def task(arg):</span><br><span class="line">    obj &#x3D; Singleton()</span><br><span class="line">    print(obj)</span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    t &#x3D; threading.Thread(target&#x3D;task,args&#x3D;[i,])</span><br><span class="line">    t.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>元类metaclass</li>
</ol>
<blockquote>
<p>1.类由type创建，创建类时，type的__init__方法自动执行，类()<br>  执行type的 __call__方法(类的__new__方法,类的__init__方法)</p>
</blockquote>
<blockquote>
<p>2.对象由类创建，创建对象时，类的__init__方法自动执行，对象()执行类的 <strong>call</strong> 方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">class SingletonType(type):</span><br><span class="line">    _instance_lock &#x3D; threading.Lock()</span><br><span class="line">    def __call__(cls, *args, **kwargs):</span><br><span class="line">        if not hasattr(cls, &quot;_instance&quot;):</span><br><span class="line">            with SingletonType._instance_lock:</span><br><span class="line">                if not hasattr(cls, &quot;_instance&quot;):</span><br><span class="line">                    cls._instance &#x3D; super(SingletonType,cls).__call__(*args, **kwargs)</span><br><span class="line">        return cls._instance</span><br><span class="line"></span><br><span class="line">class Foo(metaclass&#x3D;SingletonType):</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj1 &#x3D; Foo(&#39;name&#39;)</span><br><span class="line">obj2 &#x3D; Foo(&#39;name&#39;)</span><br><span class="line">print(obj1,obj2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-单例模式的优点："><a href="#3-单例模式的优点：" class="headerlink" title="3.单例模式的优点："></a>3.单例模式的优点：</h4><p>1、由于单例模式要求在全局内只有一个实例，因而可以节省比较多的内存空间；</p>
<p>2、全局只有一个接入点，可以更好地进行数据同步控制，避免多重占用；</p>
<p>3、单例可长驻内存，减少系统开销。</p>
<p>单例模式的应用举例：</p>
<pre><code>1、生成全局惟一的序列号；
2、访问全局复用的惟一资源，如磁盘、总线等；
3、单个对象占用的资源过多，如数据库等；
4、系统全局统一管理，如Windows下的Task Manager；
5、网站计数器。
</code></pre>
<h3 id="python设计模式–工厂模式"><a href="#python设计模式–工厂模式" class="headerlink" title="python设计模式–工厂模式"></a>python设计模式–工厂模式</h3><blockquote>
<p>通过一个指定的“工厂”获得需要的“产品”，在设计模式中主要用于抽象对象的创建过程，让用户可以指定自己想要的对象而不必关心对象的实例化过程。这样做的好处是用户只需通过固定的接口而不是直接去调用类的实例化方法来获得一个对象的实例，隐藏了实例创建过程的复杂度，解耦了生产实例和使用实例的代码，降低了维护的复杂性。</p>
</blockquote>
<h4 id="1-简单工厂"><a href="#1-简单工厂" class="headerlink" title="1.简单工厂"></a>1.简单工厂</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;utf-8</span><br><span class="line">class Mercedes(object):</span><br><span class="line">    &quot;&quot;&quot;梅赛德斯</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &quot;Mercedes-Benz&quot;</span><br><span class="line"></span><br><span class="line">class BMW(object):</span><br><span class="line">    &quot;&quot;&quot;宝马</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &quot;BMW&quot;</span><br><span class="line">        </span><br><span class="line">假设我们有两个“产品”分别是Mercedes和BMW的汽车，如果没有“工厂”来生产它们，</span><br><span class="line">我们就要在代码中自己进行实例化，如：</span><br><span class="line"></span><br><span class="line">mercedes &#x3D; Mercedes()</span><br><span class="line">bmw &#x3D; BMW()</span><br><span class="line">但现实中，你可能会面对很多汽车产品，而且每个产品的构造参数还不一样，这样在创</span><br><span class="line">建实例时会遇到麻烦。这时就可以构造一个“简单工厂”把所有汽车实例化的过程封装在里面。</span><br><span class="line"></span><br><span class="line">class SimpleCarFactory(object):</span><br><span class="line">    &quot;&quot;&quot;简单工厂</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    @staticmethod</span><br><span class="line">    def product_car(name):</span><br><span class="line">        if name &#x3D;&#x3D; &#39;mb&#39;:</span><br><span class="line">            return Mercedes()</span><br><span class="line">        elif name &#x3D;&#x3D; &#39;bmw&#39;:</span><br><span class="line">            return BMW()</span><br><span class="line">SimpleCarFactory类后，就可以通过向固定的接口传入参数获得想要的对象实例</span><br><span class="line"></span><br><span class="line">c1 &#x3D; SimpleCarFactory.product_car(&#39;mb&#39;)</span><br><span class="line">c2 &#x3D; SimpleCarFactory.product_car(&#39;bmw&#39;)</span><br></pre></td></tr></table></figure>

<h4 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2.工厂方法"></a>2.工厂方法</h4><blockquote>
<p>如果我们要新增一个“产品”，例如Audi的汽车，我们除了新增一个Audi类外还要修改SimpleCarFactory内的product_car方法。这样就违背了软件设计中的开闭原则[1]，即在扩展新的类时，尽量不要修改原有代码。所以我们在简单工厂的基础上把SimpleCarFactory抽象成不同的工厂，每个工厂对应生成自己的产品，这就是工厂方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;utf-8</span><br><span class="line">import abc</span><br><span class="line"></span><br><span class="line">class AbstractFactory(object):</span><br><span class="line">    &quot;&quot;&quot;抽象工厂</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    __metaclass__ &#x3D; abc.ABCMeta</span><br><span class="line"></span><br><span class="line">    @abc.abstractmethod</span><br><span class="line">    def product_car(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class MercedesFactory(AbstractFactory):</span><br><span class="line">    &quot;&quot;&quot;梅赛德斯工厂</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def product_car(self):</span><br><span class="line">        return Mercedes()</span><br><span class="line"></span><br><span class="line">class BMWFactory(AbstractFactory):</span><br><span class="line">    &quot;&quot;&quot;宝马工厂</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def product_car(self):</span><br><span class="line">        return BMW()</span><br><span class="line">我们把工厂抽象出来用abc模块[2]实现了一个抽象的基类AbstractFactory，</span><br><span class="line">这样就可以通过特定的工厂来获得特定的产品实例了：</span><br><span class="line"></span><br><span class="line">c1 &#x3D; MercedesFactory().product_car()</span><br><span class="line">c2 &#x3D; BMWFactory().product_car()</span><br><span class="line"></span><br><span class="line">每个工厂负责生产自己的产品也避免了我们在新增产品时需要修改工厂的代码，</span><br><span class="line">而只要增加相应的工厂即可。如新增一个Audi产品，只需新增一个Audi类和AudiFactory类。</span><br></pre></td></tr></table></figure>

<h4 id="3-抽象工厂"><a href="#3-抽象工厂" class="headerlink" title="3.抽象工厂"></a>3.抽象工厂</h4><blockquote>
<p>如果我们要生产很多产品，就会发现我们同样需要写很多对应的工厂类。比如如果MercedesFactory和BMWFactory不仅生产小汽车，还要生产SUV，那我们用工厂方法就要再多构造两个生产SUV的工厂类。所以为了解决这个问题，我们就要再更进一步的抽象工厂类，让一个工厂可以生产同一类的多个产品，这就是抽象工厂</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import abc</span><br><span class="line"></span><br><span class="line"># 两种小汽车</span><br><span class="line">class Mercedes_C63(object):</span><br><span class="line">    &quot;&quot;&quot;梅赛德斯 C63</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &quot;Mercedes-Benz: C63&quot;</span><br><span class="line"></span><br><span class="line">class BMW_M3(object):</span><br><span class="line">    &quot;&quot;&quot;宝马 M3</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &quot;BMW: M3&quot;</span><br><span class="line"></span><br><span class="line">#　两种SUV</span><br><span class="line">class Mercedes_G63(object):</span><br><span class="line">    &quot;&quot;&quot;梅赛德斯 G63</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &quot;Mercedes-Benz: G63&quot;</span><br><span class="line"></span><br><span class="line">class BMW_X5(object):</span><br><span class="line">    &quot;&quot;&quot;宝马 X5</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &quot;BMW: X5&quot;</span><br><span class="line"></span><br><span class="line">class AbstractFactory(object):</span><br><span class="line">    &quot;&quot;&quot;抽象工厂</span><br><span class="line">    可以生产小汽车外，还可以生产SUV</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    __metaclass__ &#x3D; abc.ABCMeta</span><br><span class="line"></span><br><span class="line">    @abc.abstractmethod</span><br><span class="line">    def product_car(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abc.abstractmethod</span><br><span class="line">    def product_suv(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class MercedesFactory(AbstractFactory):</span><br><span class="line">    &quot;&quot;&quot;梅赛德斯工厂</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def product_car(self):</span><br><span class="line">        return Mercedes_C63()</span><br><span class="line"></span><br><span class="line">    def product_suv(self):</span><br><span class="line">        return Mercedes_G63()</span><br><span class="line"></span><br><span class="line">class BMWFactory(AbstractFactory):</span><br><span class="line">    &quot;&quot;&quot;宝马工厂</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def product_car(self):</span><br><span class="line">        return BMW_M3()</span><br><span class="line"></span><br><span class="line">    def product_suv(self):</span><br><span class="line">        return BMW_X5()</span><br><span class="line"></span><br><span class="line">让基类AbstractFactory同时可以生产汽车和SUV，然后令MercedesFactory和BMWFactory</span><br><span class="line">继承AbstractFactory并重写product_car和product_suv方法即可。</span><br><span class="line"></span><br><span class="line">c1 &#x3D; MercedesFactory().product_car()</span><br><span class="line">s1 &#x3D; MercedesFactory().product_suv()</span><br><span class="line">print(c1, s1)</span><br><span class="line">s2 &#x3D; BMWFactory().product_suv()</span><br><span class="line">c2 &#x3D; BMWFactory().product_car()</span><br><span class="line">print(c2, s2)</span><br></pre></td></tr></table></figure>


<h4 id="4-抽象工厂模式与工厂方法模式区别"><a href="#4-抽象工厂模式与工厂方法模式区别" class="headerlink" title="4.抽象工厂模式与工厂方法模式区别"></a>4.抽象工厂模式与工厂方法模式区别</h4><ol>
<li>抽象工厂中的一个工厂对象可以负责多个不同产品对象的创建 ，这样比工厂方法模式更为简单、有效率。</li>
</ol>
<p>工厂模式、抽象工厂模式的优点：</p>
<blockquote>
<p>1、工厂模式巨有非常好的封装性，代码结构清晰；在抽象工厂模式中，其结构还可以随着需要进行更深或者更浅的抽象层级调整，非常灵活；</p>
</blockquote>
<blockquote>
<p>2、屏蔽产品类，使产品的被使用业务场景和产品的功能细节可以分而开发进行，是比较典型的解耦框架。</p>
</blockquote>
<ol start="2">
<li>工厂模式、抽象工厂模式的使用场景： 1、当系统实例要求比较灵活和可扩展时，可以考虑工厂模式或者抽象工厂模式实现。比如，<pre><code> 在通信系统中，高层通信协议会很多样化，同时，上层协议依赖于下层协议，
 那么就可以对应建立对应层级的抽象工厂，根据不同的“产品需求”去生产定制的实例。
</code></pre>
</li>
</ol>
<h3 id="python与设计模式–建造者模式"><a href="#python与设计模式–建造者模式" class="headerlink" title="python与设计模式–建造者模式"></a>python与设计模式–建造者模式</h3><blockquote>
<p>建造者模式的定义如下：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<blockquote>
<p>在建造者模式中，还可以加一个Director类，用以安排已有模块的构造步骤。对于在建造者中有比较严格的顺序要求时，该类会有比较大的用处。</p>
</blockquote>
<h4 id="快餐例："><a href="#快餐例：" class="headerlink" title="快餐例："></a>快餐例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主餐</span><br><span class="line">class Burger():</span><br><span class="line">    name&#x3D;&quot;&quot;</span><br><span class="line">    price&#x3D;0.0</span><br><span class="line">    def getPrice(self):</span><br><span class="line">        return self.price</span><br><span class="line">    def setPrice(self,price):</span><br><span class="line">        self.price&#x3D;price</span><br><span class="line">    def getName(self):</span><br><span class="line">        return self.name</span><br><span class="line">class cheeseBurger(Burger):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name&#x3D;&quot;cheese burger&quot;</span><br><span class="line">        self.price&#x3D;10.0</span><br><span class="line">class spicyChickenBurger(Burger):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name&#x3D;&quot;spicy chicken burger&quot;</span><br><span class="line">        self.price&#x3D;15.0</span><br><span class="line">小食</span><br><span class="line">class Snack():</span><br><span class="line">    name &#x3D; &quot;&quot;</span><br><span class="line">    price &#x3D; 0.0</span><br><span class="line">    type &#x3D; &quot;SNACK&quot;</span><br><span class="line">    def getPrice(self):</span><br><span class="line">        return self.price</span><br><span class="line">    def setPrice(self, price):</span><br><span class="line">        self.price &#x3D; price</span><br><span class="line">    def getName(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class chips(Snack):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name &#x3D; &quot;chips&quot;</span><br><span class="line">        self.price &#x3D; 6.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class chickenWings(Snack):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name &#x3D; &quot;chicken wings&quot;</span><br><span class="line">        self.price &#x3D; 12.0</span><br><span class="line">饮料</span><br><span class="line">class Beverage():</span><br><span class="line">    name &#x3D; &quot;&quot;</span><br><span class="line">    price &#x3D; 0.0</span><br><span class="line">    type &#x3D; &quot;BEVERAGE&quot;</span><br><span class="line">    def getPrice(self):</span><br><span class="line">        return self.price</span><br><span class="line">    def setPrice(self, price):</span><br><span class="line">        self.price &#x3D; price</span><br><span class="line">    def getName(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class coke(Beverage):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name &#x3D; &quot;coke&quot;</span><br><span class="line">        self.price &#x3D; 4.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class milk(Beverage):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name &#x3D; &quot;milk&quot;</span><br><span class="line">        self.price &#x3D; 5.0</span><br><span class="line"></span><br><span class="line">一个订单类。假设，一个订单，包括一份主食，一份小食，一种饮料。（省去一些异常判断）</span><br><span class="line"></span><br><span class="line">class order():</span><br><span class="line">    burger&#x3D;&quot;&quot;</span><br><span class="line">    snack&#x3D;&quot;&quot;</span><br><span class="line">    beverage&#x3D;&quot;&quot;</span><br><span class="line">    def __init__(self,orderBuilder):</span><br><span class="line">        self.burger&#x3D;orderBuilder.bBurger</span><br><span class="line">        self.snack&#x3D;orderBuilder.bSnack</span><br><span class="line">        self.beverage&#x3D;orderBuilder.bBeverage</span><br><span class="line">    def show(self):</span><br><span class="line">        print &quot;Burger:%s&quot;%self.burger.getName()</span><br><span class="line">        print &quot;Snack:%s&quot;%self.snack.getName()</span><br><span class="line">        print &quot;Beverage:%s&quot;%self.beverage.getName()</span><br><span class="line"></span><br><span class="line">orderBuilder就是建造者模式中所谓的“建造者”了</span><br><span class="line"></span><br><span class="line">class orderBuilder():</span><br><span class="line">    bBurger&#x3D;&quot;&quot;</span><br><span class="line">    bSnack&#x3D;&quot;&quot;</span><br><span class="line">    bBeverage&#x3D;&quot;&quot;</span><br><span class="line">    def addBurger(self,xBurger):</span><br><span class="line">        self.bBurger&#x3D;xBurger</span><br><span class="line">    def addSnack(self,xSnack):</span><br><span class="line">        self.bSnack&#x3D;xSnack</span><br><span class="line">    def addBeverage(self,xBeverage):</span><br><span class="line">        self.bBeverage&#x3D;xBeverage</span><br><span class="line">    def build(self):</span><br><span class="line">        return order(self)</span><br><span class="line">        </span><br><span class="line">订单生成</span><br><span class="line"></span><br><span class="line">if  __name__&#x3D;&#x3D;&quot;__main__&quot;:</span><br><span class="line">    order_builder&#x3D;orderBuilder()</span><br><span class="line">    order_builder.addBurger(spicyChickenBurger())</span><br><span class="line">    order_builder.addSnack(chips())</span><br><span class="line">    order_builder.addBeverage(milk())</span><br><span class="line">    order_1&#x3D;order_builder.build()</span><br><span class="line">    order_1.show()</span><br><span class="line">    </span><br><span class="line">构造步骤</span><br><span class="line"></span><br><span class="line">class orderDirector():</span><br><span class="line">    order_builder&#x3D;&quot;&quot;</span><br><span class="line">    def __init__(self,order_builder):</span><br><span class="line">        self.order_builder&#x3D;order_builder</span><br><span class="line">    def createOrder(self,burger,snack,beverage):</span><br><span class="line">        self.order_builder.addBurger(burger)</span><br><span class="line">        self.order_builder.addSnack(snack)</span><br><span class="line">        self.order_builder.addBeverage(beverage)</span><br><span class="line">        return self.order_builder.build()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-优缺："><a href="#3-优缺：" class="headerlink" title="3.优缺："></a>3.优缺：</h4><pre><code>1、封装性好，用户可以不知道对象的内部构造和细节，就可以直接建造对象；
2、系统扩展容易；
3、建造者模式易于使用，非常灵活。在构造性的场景中很容易实现“流水线”；
4、便于控制细节。
</code></pre>
<p>使用场景：</p>
<blockquote>
<p>1、 目标对象由组件构成的场景中，很适合建造者模式。例如，在一款赛车游戏中，车辆生成时，需要根据级别、环境等，选择轮胎、悬挂、骨架等部件，构造一辆“赛车”；</p>
</blockquote>
<blockquote>
<p>2、 在具体的场景中，对象内部接口需要根据不同的参数而调用顺序有所不同时，可以使用建造者模式。例如：一个植物养殖器系统，对于某些不同的植物，浇水、施加肥料的顺序要求可能会不同，因而可以在Director中维护一个类似于队列的结构，在实例化时作为参数代入到具体建造者中。</p>
</blockquote>
<p>缺点：</p>
<pre><code>1、“加工工艺”对用户不透明。（封装的两面性）
</code></pre>
<h3 id="python设计模式–原型模式"><a href="#python设计模式–原型模式" class="headerlink" title="python设计模式–原型模式"></a>python设计模式–原型模式</h3><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>原型模式定义如下：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。<br>需要注意一点的是，进行clone操作后，新对象的构造函数没有被二次执行，新对象的内容是从内存里直接拷贝的。</p>
<blockquote>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
</blockquote>
<p><img data-src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/56e6c262b1510b59beba7552f07522ae.png" alt="原型模式"></p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><blockquote>
<p>从简历原型，生成新的简历</p>
<p>简历类Resume提供的Clone()方法其实并不是真正的Clone，只是为已存在对象增加了一次引用。</p>
<p>Python为对象提供的copy模块中的copy方法和deepcopy方法已经实现了原型模式，但由于例子的层次较浅，二者看不出区别。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import copy</span><br><span class="line">class WorkExp:</span><br><span class="line">    place&#x3D;&quot;&quot;</span><br><span class="line">    year&#x3D;0</span><br><span class="line"></span><br><span class="line">class Resume:</span><br><span class="line">    name &#x3D; &#39;&#39;</span><br><span class="line">    age &#x3D; 0</span><br><span class="line">    def __init__(self,n):</span><br><span class="line">        self.name &#x3D; n</span><br><span class="line">    def SetAge(self,a):</span><br><span class="line">        self.age &#x3D; a</span><br><span class="line">    def SetWorkExp(self,p,y):</span><br><span class="line">        self.place &#x3D; p</span><br><span class="line">        self.year &#x3D; y</span><br><span class="line">    def Display(self):</span><br><span class="line">        print self.age</span><br><span class="line">        print self.place</span><br><span class="line">        print self.year</span><br><span class="line">    def Clone(self):</span><br><span class="line">    #实际不是“克隆”，只是返回了自身</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    a &#x3D; Resume(&quot;a&quot;)</span><br><span class="line">    b &#x3D; a.Clone()</span><br><span class="line">    c &#x3D; copy.copy(a)</span><br><span class="line">    d &#x3D; copy.deepcopy(a)</span><br><span class="line">    a.SetAge(7)</span><br><span class="line">    b.SetAge(12)</span><br><span class="line">    c.SetAge(15)</span><br><span class="line">    d.SetAge(18)</span><br><span class="line">    a.SetWorkExp(&quot;PrimarySchool&quot;,1996)</span><br><span class="line">    b.SetWorkExp(&quot;MidSchool&quot;,2001)</span><br><span class="line">    c.SetWorkExp(&quot;HighSchool&quot;,2004)</span><br><span class="line">    d.SetWorkExp(&quot;University&quot;,2007)</span><br><span class="line">    a.Display()</span><br><span class="line">    b.Display()</span><br><span class="line">    c.Display()</span><br><span class="line">    d.Display()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="原型模式的优缺点和使用场景"><a href="#原型模式的优缺点和使用场景" class="headerlink" title="原型模式的优缺点和使用场景"></a>原型模式的优缺点和使用场景</h4><ol>
<li><p>优点：</p>
<pre><code> 1、性能极佳，直接拷贝比在内存里直接新建实例节省不少的资源；
 2、简化对象创建，同时避免了构造函数的约束，不受构造函数的限制直接复制对象，是优
 点，也有隐患，这一点还是需要多留意一些。
</code></pre>
</li>
<li><p>使用场景：</p>
<pre><code> 1、对象在修改过后，需要复制多份的场景。如本例和其它一些涉及到复制、粘贴的场景；
 2、需要优化资源的情况。如，需要在内存中创建非常多的实例，可以通过原型模式来减少
     资源消耗。此时，原型模式与工厂
     模式配合起来，不管在逻辑上还是结构上，都会达到不错的效果；
 3、某些重复性的复杂工作不需要多次进行。如对于一个设备的访问权限，多个对象不用各
     申请一遍权限，由一个设备申请后，通过原型模式将权限交给可信赖的对象，
     既可以提升效率，又可以节约资源。
</code></pre>
</li>
<li><p>原型模式的缺点</p>
<pre><code> 1、深拷贝和浅拷贝的使用需要事先考虑周到；
 2、某些编程语言中，拷贝会影响到静态变量和静态函数的使用。
 
 
</code></pre>
</li>
</ol>
<h3 id="Python与设计模式–代理模式"><a href="#Python与设计模式–代理模式" class="headerlink" title="Python与设计模式–代理模式"></a>Python与设计模式–代理模式</h3><p>代理模式是一种使用频率非常高的模式，在多个著名的开源软件和当前多个著名的互联网产品后台程序中都有所应用。下面我们用一个抽象化的简单例子，来说明代理模式。</p>
<blockquote>
<p>首先，构造一个网络服务器：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#该服务器接受如下格式数据，addr代表地址，content代表接收的信息内容</span><br><span class="line">info_struct&#x3D;dict()</span><br><span class="line">info_struct[&quot;addr&quot;]&#x3D;10000</span><br><span class="line">info_struct[&quot;content&quot;]&#x3D;&quot;&quot;</span><br><span class="line">class Server:</span><br><span class="line">    content&#x3D;&quot;&quot;</span><br><span class="line">    def recv(self,info):</span><br><span class="line">        pass</span><br><span class="line">    def send(self,info):</span><br><span class="line">        pass</span><br><span class="line">    def show(self):</span><br><span class="line">        pass</span><br><span class="line">class infoServer(Server):</span><br><span class="line">    def recv(self,info):</span><br><span class="line">        self.content&#x3D;info</span><br><span class="line">        return &quot;recv OK!&quot;</span><br><span class="line">    def send(self,info):</span><br><span class="line">        pass</span><br><span class="line">    def show(self):</span><br><span class="line">        print &quot;SHOW:%s&quot;%self.content</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>infoServer有接收和发送的功能，发送功能由于暂时用不到，保留。</p>
<p>另外新加一个接口show，用来展示服务器接收的内容。</p>
<p>接收的数据格式必须如info_struct所示，服务器仅接受info_struct的content字段。</p>
<p>那么，如何给这个服务器设置一个白名单，使得只有白名单里的地址可以访问服务器呢？</p>
<p>修改Server结构是个方法，但这显然不符合软件设计原则中的单一职责原则。</p>
<blockquote>
<p>在此基础之上，使用代理，是个不错的方法。代理配置如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class serverProxy:</span><br><span class="line">    pass</span><br><span class="line">class infoServerProxy(serverProxy):</span><br><span class="line">    server&#x3D;&quot;&quot;</span><br><span class="line">    def __init__(self,server):</span><br><span class="line">        self.server&#x3D;server</span><br><span class="line">    def recv(self,info):</span><br><span class="line">        return self.server.recv(info)</span><br><span class="line">    def show(self):</span><br><span class="line">        self.server.show()</span><br><span class="line"></span><br><span class="line">class whiteInfoServerProxy(infoServerProxy):</span><br><span class="line">    white_list&#x3D;[]</span><br><span class="line">    def recv(self,info):</span><br><span class="line">        try:</span><br><span class="line">            assert type(info)&#x3D;&#x3D;dict</span><br><span class="line">        except:</span><br><span class="line">            return &quot;info structure is not correct&quot;</span><br><span class="line">        addr&#x3D;info.get(&quot;addr&quot;,0)</span><br><span class="line">        if not addr in self.white_list:</span><br><span class="line">            return &quot;Your address is not in the white list.&quot;</span><br><span class="line">        else:</span><br><span class="line">            content&#x3D;info.get(&quot;content&quot;,&quot;&quot;)</span><br><span class="line">            return self.server.recv(content)</span><br><span class="line">    def addWhite(self,addr):</span><br><span class="line">        self.white_list.append(addr)</span><br><span class="line">    def rmvWhite(self,addr):</span><br><span class="line">        self.white_list.remove(addr)</span><br><span class="line">    def clearWhite(self):</span><br><span class="line">        self.white_list&#x3D;[]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代理中有一个server字段，控制代理的服务器对象，infoServerProxy充当Server的直接接口代理，而whiteInfoServerProxy直接继承了infoServerProxy对象，同时加入了white_list和对白名单的操作。</p>
<blockquote>
<p>这样，在场景中通过对白名单代理的访问，就可以实现服务器的白名单访问了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if  __name__&#x3D;&#x3D;&quot;__main__&quot;:</span><br><span class="line">    info_struct &#x3D; dict()</span><br><span class="line">    info_struct[&quot;addr&quot;] &#x3D; 10010</span><br><span class="line">    info_struct[&quot;content&quot;] &#x3D; &quot;Hello World!&quot;</span><br><span class="line">    info_server &#x3D; infoServer()</span><br><span class="line">    info_server_proxy &#x3D; whiteInfoServerProxy(info_server)</span><br><span class="line">    print info_server_proxy.recv(info_struct)</span><br><span class="line">    info_server_proxy.show()</span><br><span class="line">    info_server_proxy.addWhite(10010)</span><br><span class="line">    print info_server_proxy.recv(info_struct)</span><br><span class="line">    info_server_proxy.show()</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>代理模式定义如下：为某对象提供一个代理，以控制对此对象的访问和控制。代理模式在使用过程中，应尽量对抽象主题类进行代理，而尽量不要对加过修饰和方法的子类代理。</p>
<pre><code>为其他对象提供一种代理以控制对这个对象的访问。
</code></pre>
<blockquote>
<p>如上例中，如果有一个xServer继承了Server，并新加了方法xMethod，xServer的代理应以Server为主题进行设计，而尽量不要以xServer为主题，以xServer为主题的代理可以从ServerProxy继承并添加对应的方法.</p>
</blockquote>
<p><img data-src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/651b419d706989c57083ad35e71d1029.png" alt="代理模式"></p>
<blockquote>
<p>在JAVA中，讲到代理模式，不得不会提到动态代理。动态代理是实现AOP（面向切面编程）的重要实现手段。而在Python中，很少会提到动态代理，而AOP则会以另一种模式实现：装饰模式。有关AOP的相关内容，我们会在装饰模式这一节中进行说明。</p>
</blockquote>
<h4 id="代理模式的优缺点和应用场景"><a href="#代理模式的优缺点和应用场景" class="headerlink" title="代理模式的优缺点和应用场景"></a>代理模式的优缺点和应用场景</h4><ol>
<li><p>优点:</p>
<pre><code> 1、职责清晰：非常符合单一职责原则，主题对象实现真实业务逻辑，而非本职责
     的事务，交由代理完成；
 2、扩展性强：面对主题对象可能会有的改变，代理模式在不改变对外接口的情况
     下，可以实现最大程度的扩展；
 3、保证主题对象的处理逻辑：代理可以通过检查参数的方式，保证主题对象的处
 理逻辑输入在理想范围内。
</code></pre>
</li>
<li><p>应用场景：</p>
<pre><code> 1、针对某特定对象进行功能和增强性扩展。如IP防火墙、远程访问代理等技术的应用；
 2、对主题对象进行保护。如大流量代理，安全代理等；
 3、减轻主题对象负载。如权限代理等。
</code></pre>
</li>
<li><p>代理模式的缺点</p>
<pre><code> 1、可能会降低整体业务的处理效率和速度。
 
</code></pre>
</li>
</ol>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>同模式特点描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Interface :</span><br><span class="line">    def Request(self):</span><br><span class="line">    return 0</span><br><span class="line"></span><br><span class="line">class RealSubject(Interface): </span><br><span class="line">    def Request(self):</span><br><span class="line">        print &quot;Real request.&quot;</span><br><span class="line"></span><br><span class="line">class Proxy(Interface):</span><br><span class="line">    def Request(self):</span><br><span class="line">        self.real &#x3D; RealSubject()</span><br><span class="line">        self.real.Request()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    p &#x3D; Proxy()</span><br><span class="line">    p.Request()</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="python与设计模式–装饰器模式"><a href="#python与设计模式–装饰器模式" class="headerlink" title="python与设计模式–装饰器模式"></a>python与设计模式–装饰器模式</h3><h4 id="快餐点餐系统（3）"><a href="#快餐点餐系统（3）" class="headerlink" title="快餐点餐系统（3）"></a>快餐点餐系统（3）</h4><blockquote>
<p>又提到了那个快餐点餐系统，不过今天我们只以其中的一个类作为主角：饮料类。首先，回忆下饮料类：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Beverage():</span><br><span class="line">    name &#x3D; &quot;&quot;</span><br><span class="line">    price &#x3D; 0.0</span><br><span class="line">    type &#x3D; &quot;BEVERAGE&quot;</span><br><span class="line">    def getPrice(self):</span><br><span class="line">        return self.price</span><br><span class="line">    def setPrice(self, price):</span><br><span class="line">        self.price &#x3D; price</span><br><span class="line">    def getName(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class coke(Beverage):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name &#x3D; &quot;coke&quot;</span><br><span class="line">        self.price &#x3D; 4.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class milk(Beverage):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name &#x3D; &quot;milk&quot;</span><br><span class="line">        self.price &#x3D; 5.0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除了基本配置，快餐店卖可乐时，可以选择加冰，如果加冰的话，要在原价上加0.3元；卖牛奶时，可以选择加糖，如果加糖的话，要原价上加0.5元。怎么解决这样的问题？可以选择装饰器模式来解决这一类的问题。首先，定义装饰器类：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class drinkDecorator():</span><br><span class="line">    def getName(self):</span><br><span class="line">        pass</span><br><span class="line">    def getPrice(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class iceDecorator(drinkDecorator):</span><br><span class="line">    def __init__(self,beverage):</span><br><span class="line">        self.beverage&#x3D;beverage</span><br><span class="line">    def getName(self):</span><br><span class="line">        return self.beverage.getName()+&quot; +ice&quot;</span><br><span class="line">    def getPrice(self):</span><br><span class="line">        return self.beverage.getPrice()+0.3</span><br><span class="line">    </span><br><span class="line">class sugarDecorator(drinkDecorator):</span><br><span class="line">    def __init__(self,beverage):</span><br><span class="line">        self.beverage&#x3D;beverage</span><br><span class="line">    def getName(self):</span><br><span class="line">        return self.beverage.getName()+&quot; +sugar&quot;</span><br><span class="line">    def getPrice(self):</span><br><span class="line">        return self.beverage.getPrice()+0.5</span><br></pre></td></tr></table></figure>

<blockquote>
<p>构建好装饰器后，在具体的业务场景中，就可以与饮料类进行关联。以可乐+冰为例，示例业务场景如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if  __name__&#x3D;&#x3D;&quot;__main__&quot;:</span><br><span class="line">    coke_cola&#x3D;coke()</span><br><span class="line">    print &quot;Name:%s&quot;%coke_cola.getName()</span><br><span class="line">    print &quot;Price:%s&quot;%coke_cola.getPrice()</span><br><span class="line">    ice_coke&#x3D;iceDecorator(coke_cola)</span><br><span class="line">    print &quot;Name:%s&quot; % ice_coke.getName()</span><br><span class="line">    print &quot;Price:%s&quot; % ice_coke.getPrice()</span><br><span class="line">    </span><br><span class="line">打印结果如下：</span><br><span class="line">Name:coke</span><br><span class="line">Price:4.0</span><br><span class="line">Name:coke +ice</span><br><span class="line">Price:4.3</span><br></pre></td></tr></table></figure>

<h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><p>装饰器模式定义如下：动态地给一个对象添加一些额外的职责。在增加功能方面，装饰器模式比生成子类更为灵活。</p>
<p><img data-src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6c8cc57b36c5772c0bc489221c648819.png" alt="装饰器模式"></p>
<p>装饰器模式和上一节说到的代理模式非常相似，可以认为，装饰器模式就是代理模式的一个特殊应用，两者的共同点是都具有相同的接口，不同点是侧重对主题类的过程的控制，而装饰模式则侧重对类功能的加强或减弱。</p>
<blockquote>
<p>动态地为对象增加额外的职责</p>
</blockquote>
<p>上一次说到，JAVA中的动态代理模式，是实现AOP的重要手段。而在Python中，AOP通过装饰器模式实现更为简洁和方便。</p>
<p>先来解释一下什么是AOP。AOP即Aspect Oriented Programming，中文翻译为面向切面的编程，它的含义可以解释为：如果几个或更多个逻辑过程中（这类逻辑过程可能位于不同的对象，不同的接口当中），有重复的操作行为，就可以将这些行为提取出来（即形成切面），进行统一管理和维护。举例子说，系统中需要在各个地方打印日志，就可以将打印日志这一操作提取出来，作为切面进行统一维护。</p>
<p>从编程思想的关系来看，可以认为AOP和OOP（面向对象的编程）是并列关系，二者是可以替换的，也可以结合起来用。</p>
<blockquote>
<p>实际上，在Python语言中，是天然支持装饰器的，如下例：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def log(func):</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print &#39;call %s():&#39; % func.__name__</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@log</span><br><span class="line">def now():</span><br><span class="line">    print &#39;2016-12-04&#39;</span><br><span class="line">if  __name__&#x3D;&#x3D;&quot;__main__&quot;:</span><br><span class="line">    now()</span><br><span class="line">打印如下：</span><br><span class="line">call now():</span><br><span class="line">2016-12-04</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>log接口就是装饰器的定义，而Python的@语法部分则直接支持装饰器的使用。<br>如果要在快餐点餐系统中打印日志，该如何进行AOP改造呢？可以借助类的静态方法或者类方法来实现：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LogManager:</span><br><span class="line">    @staticmethod</span><br><span class="line">    def log(func):</span><br><span class="line">        def wrapper(*args):</span><br><span class="line">            print &quot;Visit Func %s&quot;%func.__name__</span><br><span class="line">            return func(*args)</span><br><span class="line">        return wrapper</span><br><span class="line">在需要打印日志的地方直接@LogManager.log，即可打印出访问的日志信息。</span><br><span class="line">如，在beverage类的函数前加上@LogManager.log，场景类保持不变，则打印结果如下：</span><br><span class="line">Visit Func getName</span><br><span class="line">Name:coke</span><br><span class="line">Visit Func getPrice</span><br><span class="line">Price:4.0</span><br><span class="line">Visit Func getName</span><br><span class="line">Name:coke +ice</span><br><span class="line">Visit Func getPrice</span><br><span class="line">Price:4.3</span><br></pre></td></tr></table></figure>
<h4 id="装饰器模式的优点和应用场景"><a href="#装饰器模式的优点和应用场景" class="headerlink" title="装饰器模式的优点和应用场景"></a>装饰器模式的优点和应用场景</h4><ol>
<li><p>优点：</p>
<pre><code> 1、装饰器模式是继承方式的一个替代方案，可以轻量级的扩展被装饰对象的功能；
 2、Python的装饰器模式是实现AOP的一种方式，便于相同操作位于不同调用位置
     的统一管理。
</code></pre>
</li>
<li><p>应用场景：</p>
<pre><code> 1、需要扩展、增强或者减弱一个类的功能，如本例。
</code></pre>
</li>
<li><p>装饰器模式的缺点</p>
<pre><code>  1、多层装饰器的调试和维护有比较大的困难。
</code></pre>
</li>
</ol>
<h4 id="举例：展示一个人一件一件穿衣服的过程。"><a href="#举例：展示一个人一件一件穿衣服的过程。" class="headerlink" title="举例：展示一个人一件一件穿衣服的过程。"></a>举例：展示一个人一件一件穿衣服的过程。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self,tname):</span><br><span class="line">        self.name &#x3D; tname</span><br><span class="line">    def Show(self):</span><br><span class="line">       print &quot;dressed %s&quot; %(self.name)</span><br><span class="line"></span><br><span class="line">class Finery(Person):</span><br><span class="line">    componet &#x3D; None</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">    def Decorate(self,ct):</span><br><span class="line">        self.componet &#x3D; ct</span><br><span class="line">    def Show(self):</span><br><span class="line">    if(self.componet!&#x3D;None):</span><br><span class="line">        self.componet.Show()</span><br><span class="line"></span><br><span class="line">class TShirts(Finery):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">    def Show(self):</span><br><span class="line">        print &quot;Big T-shirt &quot;</span><br><span class="line">        self.componet.Show()</span><br><span class="line"></span><br><span class="line">class BigTrouser(Finery):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">    def Show(self):</span><br><span class="line">        print &quot;Big Trouser &quot;</span><br><span class="line">        self.componet.Show()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    p &#x3D; Person(&quot;somebody&quot;)</span><br><span class="line">    bt &#x3D; BigTrouser()</span><br><span class="line">    ts &#x3D; TShirts()</span><br><span class="line">    bt.Decorate(p)</span><br><span class="line">    ts.Decorate(bt)</span><br><span class="line">    ts.Show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>python扩展</category>
      </categories>
      <tags>
        <tag>python设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础大全12--正则表达式</title>
    <url>/jwangcloud/1992162868/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/python01.jpeg"></p>
<h4 id="参考地址：正则表达式运用"><a href="#参考地址：正则表达式运用" class="headerlink" title="参考地址：正则表达式运用"></a>参考地址：<a href="https://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html">正则表达式运用</a></h4><span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基础函数运用：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line">pattern &#x3D; re.compile(r&#39;\d+&#39;)</span><br><span class="line">print(pattern.split(&#39;one1two2three&#39;)) </span><br><span class="line">#以此分隔并返回分开后的形式</span><br><span class="line">print(pattern.match(&#39;0one1two2three&#39;))  </span><br><span class="line">#返回一个对象</span><br><span class="line">print(pattern.findall(&#39;one111two211three&#39;)) </span><br><span class="line">#返回所有能匹配的对象</span><br><span class="line">print(pattern.finditer(&#39;one1two2three&#39;))   </span><br><span class="line">#返回为迭代器</span><br><span class="line">pattern1 &#x3D; re.compile(r&#39;(\d\w+) (\d\w+)&#39;)  </span><br><span class="line">#相互交换位置</span><br><span class="line">print(pattern1.sub(r&#39;\2 \1&#39;,&#39;1one 2two&#39;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="正则表达式：邮箱等规则字符串可用-re函数"><a href="#正则表达式：邮箱等规则字符串可用-re函数" class="headerlink" title="正则表达式：邮箱等规则字符串可用   re函数"></a>正则表达式：邮箱等规则字符串可用   re函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">模糊查询：判断主题是字符串</span><br><span class="line">特殊字符：</span><br><span class="line">\d:数字（一个数字（开始为数字则正确））</span><br><span class="line">\D:非数字</span><br><span class="line">\w:单词字符</span><br><span class="line">\W:非单词字符</span><br><span class="line">\s:空白字符</span><br><span class="line">[1-9]: 1到9数字</span><br><span class="line">[a-z|A-Z]:</span><br><span class="line"></span><br><span class="line">转义符：\</span><br><span class="line">\\d:\d</span><br><span class="line">\.:.</span><br><span class="line">.:任意字符</span><br><span class="line"></span><br><span class="line">|：左右满足任何一个即可</span><br><span class="line"></span><br><span class="line">正则表达式的数量：</span><br><span class="line">*:0个或多个</span><br><span class="line">+：1个或多个</span><br><span class="line">？：0个或1个  贪婪模式下:取消贪婪模式</span><br><span class="line">注意：+ ？ * 匹配的是前一个字符</span><br><span class="line">贪婪模式：*?  +?  ??  &#123;1,4&#125;?</span><br><span class="line">^:以xxx开头</span><br><span class="line">$:以XXX结尾</span><br><span class="line">\A:相当于：^\w</span><br><span class="line">\Z:相当于:\w$</span><br><span class="line">&#123;0,5&#125;：格式重复次数0到5次</span><br><span class="line">r:转译符，r&#39;  &#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="re函数"><a href="#re函数" class="headerlink" title="re函数"></a>re函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">match:尽量不匹配，找到一个马上返回</span><br><span class="line">search：</span><br><span class="line">findall:尽量匹配</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># pa &#x3D; &#39;\d&#39;   #规则 ---&gt;正则表达式</span><br><span class="line"># str1 &#x3D; &#39;qaqsqdq12313&#39;</span><br><span class="line">#</span><br><span class="line"># x &#x3D; re.findall(pa,str1)</span><br><span class="line"># print(x)</span><br><span class="line"></span><br><span class="line"># def is_num(string1):</span><br><span class="line">#     pattern &#x3D; &#39;\w+@\w+\.com&#39;</span><br><span class="line">#     x &#x3D; re.findall(pattern,string1)</span><br><span class="line">#     print(x)</span><br><span class="line">#     return x</span><br><span class="line">#</span><br><span class="line"># while True:</span><br><span class="line">#     str1 &#x3D; input(&#39;输入邮箱： &#39;)</span><br><span class="line">#     res &#x3D; is_num(str1)</span><br><span class="line">#     if len(res) &#x3D;&#x3D; 0:</span><br><span class="line">#         print(&#39;xxxx&#39;)</span><br><span class="line">#     else:</span><br><span class="line">#         print(&#39;oooooo&#39;)</span><br><span class="line">#         break</span><br><span class="line"></span><br><span class="line"># def is_num(string1):</span><br><span class="line">#     pattern &#x3D; r&quot;^((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.)&#123;3&#125;(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])$&quot;</span><br><span class="line">#     # pattern &#x3D; r&#39;1\d\d|25[0-5]|2[0-4]\d&#39;</span><br><span class="line">#     x &#x3D; re.findall(pattern, string1)</span><br><span class="line">#     print(x)</span><br><span class="line">#     return x</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># while True:</span><br><span class="line">#     str1 &#x3D; input(&#39;输入号码： &#39;)</span><br><span class="line">#     res &#x3D; is_num(str1)</span><br><span class="line">#     if len(res) !&#x3D; 1:</span><br><span class="line">#         print(&#39;xxxx&#39;)</span><br><span class="line">#     else:</span><br><span class="line">#         print(&#39;oooooo&#39;)</span><br><span class="line">#         break</span><br><span class="line"># content &#x3D; &#39;Hello 12345 World&#39;</span><br><span class="line"># result &#x3D; re.match(&#39;^Hello\s(\d+)\sWorld&#39;, content)</span><br><span class="line"># print(result.group())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">贪婪模式</span><br><span class="line"># content &#x3D; &#39;http:&#x2F;&#x2F;weibo.com&#x2F;comment&#x2F;kEraCNdsfgkdsfgjkldsjkl&#39;</span><br><span class="line"># result1 &#x3D; re.match(&#39;http.*?comment&#x2F;(.*?)&#39;, content)</span><br><span class="line"># result2 &#x3D; re.match(&#39;http.*?comment&#x2F;(.*)&#39;, content)</span><br><span class="line"># print(&#39;result1&#39;, result1.group(1))  # 结果 result1</span><br><span class="line"># print(&#39;result2&#39;, result2.group(1))  # 结果 result2 kEraCN</span><br><span class="line"></span><br><span class="line"># content &#x3D; &#39;Hello 1234567 World_This is a Regex Demo&#39;</span><br><span class="line"># result &#x3D; re.match(&#39;^He.*?(\d+).*Demo$&#39;, content)</span><br><span class="line"># print(result.group(1))  # 结果</span><br><span class="line"># result &#x3D; re.match(&#39;^He.*(\d+).*Demo$&#39;, content)</span><br><span class="line"># print(result.group(1))  # 结果 7</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python正则</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础大全10--异常类、手写list</title>
    <url>/jwangcloud/3400028629/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/python01.jpeg"></p>
<h3 id="异常类-：报告错误-–-gt-中断-运行"><a href="#异常类-：报告错误-–-gt-中断-运行" class="headerlink" title="异常类 ：报告错误 –&gt; 中断 运行"></a>异常类 ：报告错误 –&gt; 中断 运行</h3><span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#只会监听特殊类型的错误</span><br><span class="line">try:</span><br><span class="line">    xx &#x3D; [qxaas]</span><br><span class="line">#监听与 NameError 相关的错误，监听所有报错只需要监听其父类（Exception）即可    </span><br><span class="line">except NameError:      </span><br><span class="line">    print(&#39;cuo  wu&#39;)</span><br><span class="line"></span><br><span class="line"># class TestError(Exception):  #exception属于报错的父类，继承即可</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自定义报错"><a href="#自定义报错" class="headerlink" title="自定义报错"></a>自定义报错</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TestError(Exception):  #自定义一个报错</span><br><span class="line">    pass</span><br><span class="line">def rujiao(age):</span><br><span class="line">    if age &lt; 30:</span><br><span class="line">        print(age)</span><br><span class="line">    else:</span><br><span class="line">        raise TestError(&#39;xiajibaluanxie&#39;)  #报错目标 ：中止程序，并输出错误提示</span><br><span class="line"># try:                #出现报错并继续运行后面的代码</span><br><span class="line">#     rujiao(333)</span><br><span class="line"># except TestError:</span><br><span class="line">#     print(&quot;xxx&quot;)   #若输入pass 则会直接跳过并不会报错</span><br><span class="line">#</span><br><span class="line"># print(&#39;xxxxxxxxxx&#39;)</span><br><span class="line">l &#x3D; [1,2,3,4]</span><br><span class="line">try:                #出现报错并继续运行后面的代码</span><br><span class="line">    l[7]             #出现错误则直接报错，不会执行下面的语句快</span><br><span class="line">    rujiao(60)</span><br><span class="line">#打印错误提示 (as后接错误提示)   可以重复抓取不同的错误，显示抓取的只有一种</span><br><span class="line">except TestError as errortype:  </span><br><span class="line">    print(errortype)</span><br><span class="line">except IndexError:</span><br><span class="line">    print(&quot;下标错误&quot;)</span><br><span class="line">except AttributeError:</span><br><span class="line">    print(&#39;无法赋值&#39;)</span><br><span class="line">else:  #上述若未发现错误，就执行else中语句</span><br><span class="line">    print(&#39;++++++++&#39;)</span><br><span class="line">finally:  #若上述未出现错误或中断：至少会执行该命令</span><br><span class="line">    print(&#39;-------&#39;)</span><br><span class="line"></span><br><span class="line">print(&#39;xxxxxxxxxx&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="编写列表类，实现列表的基础方法"><a href="#编写列表类，实现列表的基础方法" class="headerlink" title="编写列表类，实现列表的基础方法"></a>编写列表类，实现列表的基础方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self, v, n):</span><br><span class="line">        self.value &#x3D; v</span><br><span class="line">        self.next &#x3D; n</span><br><span class="line"></span><br><span class="line">class MyList:</span><br><span class="line">    def __init__(self, *args):</span><br><span class="line">        self.first_node &#x3D; Node(None, None)</span><br><span class="line">        self.length &#x3D; 1</span><br><span class="line">        for i in args:</span><br><span class="line">            self.append(i)</span><br><span class="line">        self.listxx &#x3D; args</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        return self.length - 1</span><br><span class="line"></span><br><span class="line">    def append(self, v):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        给列表添加一个新的元素</span><br><span class="line">        :param v:</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        node &#x3D; self.find_last_node()</span><br><span class="line">        node.next &#x3D; Node(v, None)</span><br><span class="line">        self.length +&#x3D; 1</span><br><span class="line"></span><br><span class="line">    def find_last_node(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        找到最后一个元素</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        node &#x3D; self.first_node</span><br><span class="line">        if node is None:</span><br><span class="line">            return None</span><br><span class="line">        while True:</span><br><span class="line">            if node.next is None:</span><br><span class="line">                break</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line">        return node</span><br><span class="line"></span><br><span class="line">    def pop(self, index&#x3D;-1):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        把列表最后一个元素删除</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if self.length &lt;&#x3D; 1:</span><br><span class="line">            return False</span><br><span class="line">        if index &#x3D;&#x3D; -1:</span><br><span class="line">            index &#x3D; self.length - 2</span><br><span class="line">        n &#x3D; self.get(index)</span><br><span class="line">        next &#x3D; n.next  # 要删除元素的最后一个元素</span><br><span class="line">        pre &#x3D; self.get(index - 1)  # 要删除元素前面一个元素</span><br><span class="line">        pre.next &#x3D; next</span><br><span class="line">        self.length -&#x3D; 1</span><br><span class="line"></span><br><span class="line">    def get(self, index):</span><br><span class="line">        index +&#x3D; 1</span><br><span class="line">        if index &gt;&#x3D; self.length:</span><br><span class="line">            return False</span><br><span class="line">        counter &#x3D; 0</span><br><span class="line">        node &#x3D; self.first_node</span><br><span class="line">        if counter &#x3D;&#x3D; index:</span><br><span class="line">            return node</span><br><span class="line">        while counter !&#x3D; index:</span><br><span class="line">            counter +&#x3D; 1</span><br><span class="line">            # 找到下一个元素</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line">        return node.value</span><br><span class="line"></span><br><span class="line">    def clear(self):</span><br><span class="line">        self.first_node.next &#x3D; None</span><br><span class="line">        self.length &#x3D; 1</span><br><span class="line"></span><br><span class="line">    def count(self, value):</span><br><span class="line">        counter &#x3D; 0</span><br><span class="line">        node &#x3D; self.first_node.next</span><br><span class="line">        while True:</span><br><span class="line">            if node is not None:</span><br><span class="line">                if node.value &#x3D;&#x3D; value:</span><br><span class="line">                    counter +&#x3D; 1</span><br><span class="line">                node &#x3D; node.next</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        return counter</span><br><span class="line"></span><br><span class="line">    def remove(self,value):</span><br><span class="line">        pre_node &#x3D; self.first_node</span><br><span class="line">        current_node &#x3D; pre_node.next</span><br><span class="line">        while True:</span><br><span class="line">            if current_node is None:</span><br><span class="line">                raise ValueError(&quot;&#123;&#125; not in &#123;&#125;&quot;.format(value,self.__class__.__name__))</span><br><span class="line">            if current_node.value &#x3D;&#x3D; value:</span><br><span class="line">                pre_node.next &#x3D; current_node.next</span><br><span class="line">                return</span><br><span class="line">            pre_node &#x3D; pre_node.next</span><br><span class="line">            current_node &#x3D; current_node.next</span><br><span class="line"></span><br><span class="line">    def index(self, value):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        找出value所在的第一个节点</span><br><span class="line">        :param value:</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        counter &#x3D; 0</span><br><span class="line">        node &#x3D; self.first_node.next</span><br><span class="line">        while True:</span><br><span class="line">            if node is not None:</span><br><span class="line">                if node.value &#x3D;&#x3D; value:</span><br><span class="line">                    return counter</span><br><span class="line">                else:</span><br><span class="line">                    counter +&#x3D; 1</span><br><span class="line">                    node &#x3D; node.next</span><br><span class="line">            else:</span><br><span class="line">                raise ValueError(&quot;&#123;&#125; is not in list&quot;.format(value))</span><br><span class="line"></span><br><span class="line">    def insert(self, index, value):</span><br><span class="line">        counter &#x3D; 0</span><br><span class="line">        pre_node &#x3D; self.first_node</span><br><span class="line">        while True:</span><br><span class="line">            if pre_node is None:</span><br><span class="line">                self.append(value)</span><br><span class="line">                break</span><br><span class="line">            if counter &#x3D;&#x3D; index:</span><br><span class="line">                next_node &#x3D; pre_node.next</span><br><span class="line">                new_node &#x3D; Node(value, None)</span><br><span class="line">                pre_node.next &#x3D; new_node</span><br><span class="line">                new_node.next &#x3D; next_node</span><br><span class="line">                self.length +&#x3D; 1</span><br><span class="line">                break</span><br><span class="line">            else:</span><br><span class="line">                counter +&#x3D; 1</span><br><span class="line">                pre_node &#x3D; pre_node.next</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        string &#x3D; &quot;[&quot;</span><br><span class="line">        node &#x3D; self.first_node.next</span><br><span class="line">        if node is not None:</span><br><span class="line">            v &#x3D; node.value</span><br><span class="line">            string +&#x3D; str(v)</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line">            while node is not None:</span><br><span class="line">                string +&#x3D; &quot;, &quot; + str(node.value)</span><br><span class="line">                node &#x3D; node.next</span><br><span class="line">        string +&#x3D; &quot;]&quot;</span><br><span class="line"></span><br><span class="line">        return string</span><br><span class="line"></span><br><span class="line">    def reverse(self):</span><br><span class="line">        counter &#x3D; 0</span><br><span class="line">        while self.length-2 &gt; counter:</span><br><span class="line">            node &#x3D; self.first_node.next</span><br><span class="line">            if node is None:</span><br><span class="line">                return</span><br><span class="line">            self.insert(self.length-1-counter,node.value)</span><br><span class="line">            counter +&#x3D; 1</span><br><span class="line">            self.pop(0)</span><br><span class="line">    # timsort</span><br><span class="line">    # &lt;__main__.MyListV2 object at 0x103aa1bd0&gt;</span><br><span class="line">    # def __str__(self):</span><br><span class="line">    #     global __name__</span><br><span class="line">    #     string &#x3D; &quot;&lt;&quot;</span><br><span class="line">    #     string +&#x3D; __name__</span><br><span class="line">    #     string +&#x3D; &quot;.MyList&quot;</span><br><span class="line">    #     string +&#x3D; &#39;  object at &#123;0:x&#125;&#39;.format(id(self))</span><br><span class="line">    #     string +&#x3D; &quot;&gt;&quot;</span><br><span class="line">    #     return string</span><br><span class="line">    def __getitem__(self, item):</span><br><span class="line">        if item &#x3D;&#x3D; -1:</span><br><span class="line">            item &#x3D; self.length - 2</span><br><span class="line">        node &#x3D; self.get(item)</span><br><span class="line">        return node.value</span><br><span class="line"></span><br><span class="line">    def __delitem__(self, *args, **kwargs):  # real signature unknown</span><br><span class="line">        &quot;&quot;&quot; Delete self[key]. &quot;&quot;&quot;</span><br><span class="line">        self.pop(args[0])</span><br><span class="line"></span><br><span class="line">    def __gt__(self, other):  #other表示另一个对象，self表示本次的对象   __gt__(&gt;)  __at__(&lt;)</span><br><span class="line">        if self.length &gt; other.length:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line">    def __add__(self, other):</span><br><span class="line"></span><br><span class="line">        len1 &#x3D; len(self)</span><br><span class="line">        len2 &#x3D; len(other)</span><br><span class="line">        l3 &#x3D; MyList()</span><br><span class="line">        for i in range(len1):</span><br><span class="line">            l3.append(self.get(i))</span><br><span class="line"></span><br><span class="line">        for j in range(len2):</span><br><span class="line">            l3.append(other.get(j))</span><br><span class="line"></span><br><span class="line">        return l3</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line">l1 &#x3D; MyList(1,2,3,4,5,6)</span><br><span class="line">print(l1.get(2))</span><br><span class="line">l2 &#x3D; MyList(1,2,3,4)</span><br><span class="line">print(l1+l2)</span><br><span class="line"></span><br><span class="line"># l.reverse()</span><br><span class="line"># #l1.remove(77)</span><br><span class="line"># # l.insert(10,77)</span><br><span class="line"># # l.clear()</span><br><span class="line"># #</span><br><span class="line"># # l &#x3D; [9,2,9,4,9,2,7,8,9]</span><br><span class="line"># # print(l.index(9))</span><br><span class="line"># # print(l1.index(9))</span><br><span class="line">#</span><br><span class="line"># # print(l1)</span><br><span class="line"># print(l)</span><br><span class="line"># print(len(l))</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># class MyListV2(MyList):</span><br><span class="line">#     def sort(self):</span><br><span class="line">#         pass</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># class MyListV3(MyListV2):</span><br><span class="line">#     def reverse(self):</span><br><span class="line">#         pass</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># l &#x3D; MyListV2(6, 7, 8, 9, 10)</span><br><span class="line">#</span><br><span class="line"># l.append(9)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python异常类</tag>
        <tag>python手写list</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础大全11--面相对象</title>
    <url>/jwangcloud/1278160075/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/python01.jpeg"></p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">面向对象：先有类（抽象）才有对象（具体）</span><br><span class="line">class:</span><br><span class="line">可继承  class Mylist(list):  括号里为其它的对象等   ：可多继承，层层继承，本次继承拥有被继承以及上面所有</span><br><span class="line">继承父类的init时，需要使用supper().__init__()</span><br><span class="line">可重写：可以在继承的类中重写其中的方法或功能（多态）</span><br><span class="line">可扩展：继承中可以增加新的方法或功能</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line">#类的申明方式</span><br><span class="line">class Car:  #在这个下面可以有无数函数  命名：首字母必须大写</span><br><span class="line"></span><br><span class="line">    def __init__(self):        </span><br><span class="line">    #面向对象中的所有东西可共享（通过self挂载，再通过self调用，只用于类）init中为确定的功能</span><br><span class="line">        self.coloer &#x3D; &#39;red&#39;</span><br><span class="line">        self.ppai &#x3D; &#39;jili&#39;</span><br><span class="line">        self.kuandu &#x3D; 1900</span><br><span class="line">        print(&#39;对象初始化&#39;)</span><br><span class="line">        self.x &#x3D; random.randint(0,100)</span><br><span class="line"></span><br><span class="line">    def test(self):</span><br><span class="line">        print(self.coloer)</span><br><span class="line">        self.laba()</span><br><span class="line">        return self.ppai</span><br><span class="line"></span><br><span class="line">    def laba(self):</span><br><span class="line">        self.changd &#x3D; 8000</span><br><span class="line"></span><br><span class="line">    def de_self(self):</span><br><span class="line">        print(self.x)     #挂载在self上，每次调用地址不同</span><br><span class="line">        print(id(self.x))</span><br><span class="line">        xx &#x3D; random.randint(0,100)  #依附于class上，相当于函数变量，每次调用地址相同</span><br><span class="line">        print(xx)</span><br><span class="line">        print(id(xx))</span><br><span class="line"></span><br><span class="line">    def de1_self(self):</span><br><span class="line">        self.de_self()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># car1 &#x3D; Car()         </span><br><span class="line">类的实例化(对象) 会直接调用类中的__init__（初始化）函数 (魔法函数都以__名称__为命名格式)初始化</span><br><span class="line"># car2 &#x3D; Car()         </span><br><span class="line">可实例化多次</span><br><span class="line"># # print(car1.test())   </span><br><span class="line">调用功能函数</span><br><span class="line"># # print(car1.coloer)    </span><br><span class="line">调用self的属性</span><br><span class="line"># car1.laba()             </span><br><span class="line">属于类里除__init__函数之外的self需要先运行其类中对应的函数，才能挂载在self上，对象才能继续调用</span><br><span class="line"># print(car1.changdu)</span><br></pre></td></tr></table></figure>


<h3 id="self"><a href="#self" class="headerlink" title="self"></a>self</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self：相当于挂载器，可以将类中的各个属性通过其挂载，再使用，属于对象，可以在类中互相传递</span><br><span class="line">每个self都有一个独立的空间</span><br><span class="line"></span><br><span class="line">car1 &#x3D; Car()</span><br><span class="line">car1.de_self()</span><br><span class="line">car1.de1_self()</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line"># import random</span><br><span class="line"># class Student:</span><br><span class="line">#     def __init__(self):</span><br><span class="line">#         self.cla_num &#x3D; random.randint(1,5)</span><br><span class="line">#         self.cla_stunum &#x3D; random.randint(1,50)</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line">#     def cla_girls(self):</span><br><span class="line">#         stunum &#x3D; self.cla_stunum</span><br><span class="line">#         self.girls &#x3D; random.randint(1,stunum)</span><br><span class="line">#         print(&quot;女生人数：%d&quot;%self.girls)</span><br><span class="line">#</span><br><span class="line">#     def cla_boysnum(self):</span><br><span class="line">#         cla_boyssnum &#x3D; self.cla_stunum - self.girls</span><br><span class="line">#         print(&quot;男生人数：%d&quot;%cla_boyssnum)</span><br><span class="line"># student1 &#x3D; Student</span><br><span class="line"># student1.cla_girls()</span><br><span class="line"># student1.cla_boysnum()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Room:</span><br><span class="line">    def __init__(self,name_num):  #初始化时，可以加入参数</span><br><span class="line">        self.__password &#x3D; 111   #在前面+__后 该属性变成私有，只能在内部调用</span><br><span class="line">        self.__card &#x3D; 111111</span><br><span class="line">        self.n &#x3D; name_num</span><br><span class="line"></span><br><span class="line">    def card_get(self):      #可以通过函数传出，但可以修改成其它值</span><br><span class="line">        return self.__card &#x2F; 2</span><br><span class="line"></span><br><span class="line">    def get_password(self):</span><br><span class="line">        return &#39;12365&#39;</span><br><span class="line"></span><br><span class="line">xx &#x3D; Room(&#39;aaaa&#39;)  #参数值传入并初始化</span><br><span class="line"></span><br><span class="line">print(xx.card_get())</span><br><span class="line">print(xx.get_password())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#每一个类中都存在默认函数：如__str__(魔法函数，会自动调用)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="内置函数调用装饰器"><a href="#内置函数调用装饰器" class="headerlink" title="内置函数调用装饰器"></a>内置函数调用装饰器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person:</span><br><span class="line"></span><br><span class="line">    def __init__(self,name,age,id):</span><br><span class="line">        self.__age &#x3D; age       #私有属性：进行运行时无法查看（被保护）,可隐藏真实数据</span><br><span class="line">        self.__name &#x3D; name</span><br><span class="line">        self.id &#x3D; id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def age(self):</span><br><span class="line">        return self.__age&#x2F;&#x2F;2</span><br><span class="line"></span><br><span class="line">    def set_age(self,age):  #判断输入的参数是否符合规则，符合就修改该参数</span><br><span class="line">        if age &lt; 50:</span><br><span class="line">            self.__age &#x3D; age</span><br><span class="line">        else:</span><br><span class="line">            self.__age &#x3D; 50</span><br><span class="line"></span><br><span class="line">        return self.__age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @property  # 可以直接使用函数名调用的内置装饰器</span><br><span class="line">    def name(self):</span><br><span class="line">        return self.__name</span><br><span class="line"></span><br><span class="line">    def id_c(self):</span><br><span class="line">        print(self.id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p &#x3D; Person(&#39;xxx&#39;,50,12)</span><br><span class="line"></span><br><span class="line">print(p.age())  #只能通过函数调用该属性，并且函数能改原数据</span><br><span class="line"></span><br><span class="line">print(p.name)   #不需要加（）即可调用该函数</span><br><span class="line"></span><br><span class="line">p.id &#x3D; 14    #可修改类中的参数。</span><br><span class="line">p.id_c()</span><br><span class="line"></span><br><span class="line">p.set_age(30)   #判断参数规则并修改该参数</span><br><span class="line">print(p.age())</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="slots"><a href="#slots" class="headerlink" title="slots"></a><strong>slots</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class DataBaset:</span><br><span class="line">    #在设置属性时会直接调用，控制其对象只能存在的属性</span><br><span class="line">    __slots__ &#x3D; (&#39;__password&#39;,&#39;__database_name&#39;,&#39;__name&#39;)</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__name &#x3D; &#39;&#39;</span><br><span class="line">        self.__password &#x3D; &#39;&#39;</span><br><span class="line">        self.__database_name &#x3D; &#39;&#39;</span><br><span class="line"></span><br><span class="line">    def name(self):</span><br><span class="line">        return self.__name</span><br><span class="line">    @property   #将函数变成属性  若有相关联的setting则需要对setting中的语句再执行该变量</span><br><span class="line">    def password(self):</span><br><span class="line">        return &quot;&#123;&#125;&quot;.format(&#39;*&#39; * len(self.__password))</span><br><span class="line"></span><br><span class="line">    def set_name(self,name):</span><br><span class="line">        iswasp &#x3D; True</span><br><span class="line">        while iswasp &#x3D;&#x3D; True:</span><br><span class="line">            if type(len(name)) &#x3D;&#x3D; str:</span><br><span class="line">                print(&quot;非字符串&quot;)</span><br><span class="line">                iswasp &#x3D; False</span><br><span class="line">            elif len(name) &lt; 6:</span><br><span class="line">                print(&#39;账户名错误&#39;)</span><br><span class="line">                iswasp &#x3D; False</span><br><span class="line">            elif 48 &lt;&#x3D; ord(name[0])&lt;&#x3D; 57:</span><br><span class="line">                print(&quot;首字母为数字&quot;)</span><br><span class="line">                iswasp &#x3D; False</span><br><span class="line">            else:</span><br><span class="line">                self.__name &#x3D; name</span><br><span class="line">                break</span><br><span class="line">    @password.setter   #在变成属性的函数赋值时会调用此setting函数</span><br><span class="line">    def password(self,password):</span><br><span class="line">        if type(password) !&#x3D; str:</span><br><span class="line">            print(&#39;错误&#39;)</span><br><span class="line">            return</span><br><span class="line">        if len(password) &lt; 8:</span><br><span class="line">            print(&#39;长度不够&#39;)</span><br><span class="line">            return</span><br><span class="line">        self.__password &#x3D; password</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql &#x3D; DataBaset()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mysql.name &#x3D; &#39;aaaaaa&#39;  #未修改类中的任何，只是单纯定义（直接在类中设置控制函数就可）</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">在使用property后 如果需要直接使用赋值语法修改被保护的，可在相关判断条件下使用  </span><br><span class="line">@判断名(需要与函数名一样).setter</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">mysql.password &#x3D; &#39;aaa&#39;</span><br><span class="line">print(mysql.password)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础大全09--模块操作</title>
    <url>/jwangcloud/1559717923/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/python01.jpeg"></p>
<h3 id="模块的引用与创建"><a href="#模块的引用与创建" class="headerlink" title="模块的引用与创建"></a>模块的引用与创建</h3><span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test1.py</span><br><span class="line"></span><br><span class="line">小技巧，程序自动识别当前执行的python文件名   __file__</span><br><span class="line"></span><br><span class="line">def a_test():</span><br><span class="line">    return &#39;a.py&#39;</span><br><span class="line">def test():     #return 为空 调用会多一个返回值空，以及执行该函数打印出aaaa</span><br><span class="line">    print(&quot;aaaaa&quot;)</span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:   #该命令下的不会被引用执行</span><br><span class="line">    print(&quot;不可被引用的命令test1&quot;)</span><br><span class="line">print(&#39;可以被调用的test1&#39;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test2.py</span><br><span class="line">from module.test1 import a_test,test  #引用来自module包下test1.py中的a_test函数，</span><br><span class="line">module包必须含有_init_.py文件</span><br><span class="line"></span><br><span class="line">def b_test():</span><br><span class="line">    return &#39;b.py&#39;</span><br><span class="line"></span><br><span class="line">print(a_test())   #输出test1中的a_test函数运行结果</span><br><span class="line">print(test())</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test3.py</span><br><span class="line"></span><br><span class="line">import module.test1    #引用目标文件名 -- 会先执行import下的文件</span><br><span class="line">import module.a_test</span><br><span class="line">print(module.test1.a_test())  #直接调用该文件下的为a_test的函数，并打印输出  </span><br><span class="line">若有其它文件调用该文件下函数，会执行该文件下的命令，解决方案见test1.py</span><br><span class="line">print(module.test1.test())    #会先执行module下test1中的所有，</span><br><span class="line">再执行函数test若无return会返回空</span><br><span class="line">print(module.a_test.get_path())  #调用的执行目标文件所在路径，</span><br><span class="line">而不是该命令所在文件的路径</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="引用内置库"><a href="#引用内置库" class="headerlink" title="引用内置库"></a>引用内置库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os    #引进os模块，详见a_test.py</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">time.sleep(2) #程序暂停2秒</span><br><span class="line">time.time()#时间戳</span><br><span class="line">datetime.time() #运行时间</span><br><span class="line"></span><br><span class="line">import random</span><br><span class="line">random.randint(0,10)  #伪随机</span><br><span class="line">random.random()  #随机浮点数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="引用第三方库"><a href="#引用第三方库" class="headerlink" title="引用第三方库"></a>引用第三方库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装外部库：pycharm -- preferences -- project interpreter -- + -- &#39;选择库&#39; -- install</span><br><span class="line">相当于执行了：pip3 install requests(浏览网页)</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">r &#x3D; requests.get(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;)</span><br><span class="line">print(r.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="建立自己的库：在需要的文件夹下建立一个-init-py文件-或者系统自动生成，该文件夹会成为一个库"><a href="#建立自己的库：在需要的文件夹下建立一个-init-py文件-或者系统自动生成，该文件夹会成为一个库" class="headerlink" title="建立自己的库：在需要的文件夹下建立一个__init__.py文件,或者系统自动生成，该文件夹会成为一个库"></a>建立自己的库：在需要的文件夹下建立一个__init__.py文件,或者系统自动生成，该文件夹会成为一个库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from module import test1</span><br><span class="line">test1.test()</span><br></pre></td></tr></table></figure>

<h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r w a --&gt;读 写（会覆盖文件中的内容） 追加写（末尾添加）读写文件性能会很低，因为文件存在磁盘，需要转到CPU运行</span><br><span class="line"></span><br><span class="line"> w &#x3D; open(&#39;open.txt&#39;,&#39;r&#39;)  #每次都只能操作一个方法</span><br><span class="line"> w.write(&#39;测试写&#39;)</span><br><span class="line"> w.close()          #文件操作后需要关闭，文件描述符有关</span><br><span class="line"></span><br><span class="line">r.readlines():一行一行读</span><br><span class="line"></span><br><span class="line"> r &#x3D; open(&#39;open.txt&#39;,&#39;r&#39;)  #读取文档中所有内容（字节读取）</span><br><span class="line"> read_txt &#x3D; &#39;&#39;</span><br><span class="line"> while True:</span><br><span class="line">     x &#x3D; r.read(1)      #一个字节一个字节读取</span><br><span class="line">     if len(x) &#x3D;&#x3D; 0:</span><br><span class="line">         break</span><br><span class="line">     read_txt +&#x3D; x</span><br><span class="line"> r.close()</span><br><span class="line"> print(read_txt)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> r &#x3D; open(&#39;open.txt&#39;,&#39;r&#39;)  #读取文档中的所有内容（行读取）</span><br><span class="line"> read_txt &#x3D; &#39;&#39;</span><br><span class="line"> while True:</span><br><span class="line">     x &#x3D; r.readlines()</span><br><span class="line">     if len(x) &#x3D;&#x3D; 0:</span><br><span class="line">         break</span><br><span class="line">     print(x)</span><br><span class="line"> r.close()</span><br><span class="line"></span><br><span class="line">#无需关闭文件的方法：</span><br><span class="line"> with open(&#39;open.txt&#39;,&#39;r&#39;) as r:  #在其中的文件操作代码运行后会自动关掉</span><br><span class="line">     read_txt &#x3D; &#39;&#39;</span><br><span class="line">     while True:</span><br><span class="line">         x &#x3D; r.readlines()</span><br><span class="line">         if len(x) &#x3D;&#x3D; 0:</span><br><span class="line">             break</span><br><span class="line">         print(x)</span><br><span class="line">         </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python模块操作</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础大全08--文件操作</title>
    <url>/jwangcloud/2633756156/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/python01.jpeg"></p>
<h3 id="os-shtuil模块常用命令"><a href="#os-shtuil模块常用命令" class="headerlink" title="os/shtuil模块常用命令"></a>os/shtuil模块常用命令</h3><span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">os模块</span><br><span class="line">path函数os模块中的abspath:找出当前运行函数的绝对路径</span><br><span class="line">os.mkdir:不能递归创建目录</span><br><span class="line">os.path.join:相当于&quot;+&#x2F;&quot;，如果是windos则是&quot;\+&quot;</span><br><span class="line">os.makedirs: 可递归创建文件</span><br><span class="line">os.path.abspath:显示同层文件的绝对路径</span><br><span class="line">os.path.dirname:显示同层文件上层目录</span><br><span class="line">os.rmdir:删除空文件</span><br><span class="line">shutil模块</span><br><span class="line">shutil rmtree:强制删除文件</span><br><span class="line">shutil move:移动文件</span><br><span class="line">shutil copy:</span><br><span class="line">shutil copytree:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="文件路径的查找"><a href="#文件路径的查找" class="headerlink" title="文件路径的查找"></a>文件路径的查找</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import shutil #更高级一点的库</span><br><span class="line"></span><br><span class="line"> def get_path():</span><br><span class="line">     xx &#x3D; os.path.abspath(__file__)  #__file__相当于当前所在文件名</span><br><span class="line">     return xx</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一直找上层路径直到项目路径</span><br><span class="line"> c_path &#x3D; os.path.abspath(__file__)</span><br><span class="line"> module_path &#x3D; os.path.dirname(c_path)</span><br><span class="line"> pycode_path &#x3D; os.path.dirname(module_path)</span><br><span class="line"> print(os.path.dirname(pycode_path))</span><br><span class="line"></span><br><span class="line">相当于下面代码</span><br><span class="line"> BASE_DIR &#x3D; os.path.dirname(os.path.dirname(__file__))</span><br><span class="line"> print(BASE_DIR)</span><br><span class="line"> os.mkdir(BASE_DIR+&#39;&#x2F;b_test&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="创建或删除文件-文件夹"><a href="#创建或删除文件-文件夹" class="headerlink" title="创建或删除文件/文件夹"></a>创建或删除文件/文件夹</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> xx &#x3D; os.path.join(BASE_DIR,&#39;text1&#39;,&#39;text2&#39;) #在BASE_DIR的路径下创建text1并在该文件下再创建text2</span><br><span class="line"> os.mkdir(xx)   #不能递归创建</span><br><span class="line"> os.makedirs(xx) #可递归创建文件</span><br><span class="line"> os.makedirs(xx,exist_ok&#x3D;True)  #若有该文件名存在则不会再报错</span><br><span class="line"></span><br><span class="line"> os.rmdir(os.path.join(BASE_DIR,&#39;b_test&#39;))  #只能删除空目录</span><br><span class="line"></span><br><span class="line">shutil.rmtree(os.path.join(BASE_DIR,&#39;text1&#39;)) #使用shutil库函数删除文件夹(包括非空文件夹)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="文件-文件夹的移动，以及文件夹遍历"><a href="#文件-文件夹的移动，以及文件夹遍历" class="headerlink" title="文件/文件夹的移动，以及文件夹遍历"></a>文件/文件夹的移动，以及文件夹遍历</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将位于BASE_PATH路径下的a_text移动到b_text下</span><br><span class="line"></span><br><span class="line"> os.mkdir(os.path.join(BASE_DIR,&#39;a_text&#39;))</span><br><span class="line"> os.mkdir(os.path.join(BASE_DIR,&#39;b_text&#39;))</span><br><span class="line"> shutil.move(os.path.join(BASE_DIR,&#39;a_text&#39;),os.path.join(BASE_DIR,&#39;b_text&#39;))  </span><br><span class="line"> </span><br><span class="line">拷贝文件到一个新文件中  操作的是文件</span><br><span class="line"> shutil.copy(&#39;test1.py&#39;,&#39;test4.py&#39;) </span><br><span class="line">拷贝文件夹到新文件夹中，操作的是文件夹   	</span><br><span class="line"> shutil.copytree(os.path.join(BASE_DIR,&#39;module&#39;),os.path.join(BASE_DIR,&#39;module2&#39;)) </span><br><span class="line"> </span><br><span class="line">遍历文件夹</span><br><span class="line"> yy &#x3D; os.listdir(BASE_DIR+&#39;&#x2F;module&#39;)  </span><br><span class="line"> print(yy)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="遍历文件夹"><a href="#遍历文件夹" class="headerlink" title="遍历文件夹"></a>遍历文件夹</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import shutil</span><br><span class="line"></span><br><span class="line">#深度遍历文件夹</span><br><span class="line">def deep_first(dir):  </span><br><span class="line">    dir_lists &#x3D; os.listdir(dir)</span><br><span class="line">    if len(dir_lists) &#x3D;&#x3D; 0:</span><br><span class="line">        return</span><br><span class="line">    for d in dir_lists:</span><br><span class="line">        print(d)</span><br><span class="line">        deep_first(os.path.join(dir,d))</span><br><span class="line">deep_first(&#39;test&#39;)</span><br><span class="line"></span><br><span class="line">#广度遍历文件夹</span><br><span class="line">def brand_first(dir):   </span><br><span class="line">    buckets &#x3D; []</span><br><span class="line">    buckets.append(dir)</span><br><span class="line"></span><br><span class="line">    while len(buckets) &gt; 0:</span><br><span class="line">        tmp &#x3D; buckets.pop(0)</span><br><span class="line">        print(tmp)</span><br><span class="line">        files &#x3D; os.listdir(tmp)    #listdir中容易乱序，需要排序</span><br><span class="line">        files.sort()</span><br><span class="line">        for i in files:</span><br><span class="line">            buckets.append(os.path.join(tmp,i))</span><br><span class="line"></span><br><span class="line">brand_first(&#39;test&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础大全07--集合</title>
    <url>/jwangcloud/1297570316/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/python01.jpeg"></p>
<h4 id="字典-键值对-key-value"><a href="#字典-键值对-key-value" class="headerlink" title="字典: 键值对 key - value"></a>字典: 键值对 key - value</h4><span id="more"></span>

<p>1.申明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict1 &#x3D; &#123;&#39;a&#39;:1,&#39;b&#39;:2,&#39;c&#39;:3&#125;   #其中的每一个键值对都与下标无关，即与位置无关</span><br><span class="line">dict2 &#x3D; &#123;&#39;b&#39;:2,&#39;a&#39;:1,&#39;c&#39;:3&#125;</span><br><span class="line">print(dict1)</span><br><span class="line">print(dict1[&#39;a&#39;])</span><br></pre></td></tr></table></figure>

<p>2.dict内置方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict3 &#x3D; &#123;&#39;b&#39;:2,&#39;a&#39;:1,&#39;c&#39;:3,&#39;d&#39;:dict1&#125;</span><br><span class="line">print(dict3.keys())        #打印所有的键</span><br><span class="line"></span><br><span class="line">print(list(dict3.keys()))</span><br><span class="line"></span><br><span class="line">print(list(dict3.values())) #打印所有的值</span><br><span class="line"></span><br><span class="line">print(list(dict3.items()))  #打印所有的键和值</span><br><span class="line"></span><br><span class="line">print(dict3.get(&#39;a&#39;,&#39;aa&#39;))  #判断其是否存在该键值,有则返回对应的值，（键，值）</span><br><span class="line"></span><br><span class="line">print(dict3.setdefault(&#39;hello&#39;,&#39;w&#39;)) #不存在该键值则更新字典，将其加入</span><br><span class="line">print(dict3)</span><br><span class="line"></span><br><span class="line">dict4 &#x3D; &#123;&#39;f&#39;:134&#125;</span><br><span class="line">dict4.update(dict2)    #把dict2中的键值对更新到dict4中</span><br><span class="line">print(dict4)</span><br><span class="line"></span><br><span class="line">dict1.pop(&#39;a&#39;)         #将dict1中的键&#39;a&#39;对应的键值对删除</span><br><span class="line">print(dict1)</span><br><span class="line">del dict1[&#39;b&#39;]         #删除该键值对</span><br><span class="line">print(dict1)</span><br><span class="line"></span><br><span class="line">dict11 &#x3D; dict.fromkeys(dict1)  #新建一个与dict1有相同键的字典，其值为none</span><br><span class="line">print(dict11)</span><br><span class="line"></span><br><span class="line">#键值对添加修改</span><br><span class="line">dict2[&#39;world&#39;] &#x3D; &#39;e&#39;    #无则添加该键值</span><br><span class="line">print(dict2)</span><br><span class="line">dict2[&#39;c&#39;] &#x3D; &#39;f&#39;    #有则修改该键对应的值</span><br><span class="line">print(dict2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.优化斐波拉契</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict1 &#x3D; &#123;&#125;</span><br><span class="line">def fib(n):</span><br><span class="line">    if n &#x3D;&#x3D; 1 or n &#x3D;&#x3D; 2:</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        if dict1.get(n-1,&#39;&#39;):</span><br><span class="line">            x1 &#x3D; dict1.get(n-1)</span><br><span class="line">        else:</span><br><span class="line">            x1 &#x3D; fib(n-1)</span><br><span class="line">            dict1[n-1] &#x3D; x1</span><br><span class="line">        if dict1.get(n-2,&#39;&#39;):</span><br><span class="line">            x2 &#x3D; dict1.get(n-2)</span><br><span class="line">        else:</span><br><span class="line">            x2 &#x3D; fib(n-2)</span><br><span class="line">            dict1[n-2] &#x3D; x2</span><br><span class="line">        return x1 + x2</span><br><span class="line">print(fib(5))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="tuple-元祖-不可修改的列表"><a href="#tuple-元祖-不可修改的列表" class="headerlink" title="tuple:元祖  不可修改的列表"></a>tuple:元祖  不可修改的列表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可拆包</span><br><span class="line">不可变 （针对某些元素）</span><br><span class="line">用于轻量级数据中</span><br><span class="line"></span><br><span class="line"> tup1 &#x3D; (&#39;asdf&#39;,&#39;s&#39;)</span><br><span class="line"> tup4 &#x3D; (&#39;d&#39;,) #但元素加，</span><br><span class="line"> tup2,tup3 &#x3D; (&#39;aa&#39;,&#39;bb&#39;)  #可以拆包</span><br><span class="line"> print(tup3)</span><br><span class="line"> print(tup2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1.tuple取值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,下标取值</span><br><span class="line">2。拆包</span><br><span class="line"></span><br><span class="line">d &#x3D; &#123;&#39;a&#39;:1,&#39;b&#39;:2,&#39;c&#39;:3&#125;</span><br><span class="line">for tup1,tup2 in d.items():     #若不需要tup1则可以写成 _ , tup2</span><br><span class="line">    print(tup2)</span><br><span class="line">for _,v in d.items():</span><br><span class="line">    print(v)</span><br><span class="line">l2 &#x3D; [(k,v) for k,v in d.items()] #变成列表</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="set-集合"><a href="#set-集合" class="headerlink" title="set:集合"></a>set:集合</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">元素不重合</span><br><span class="line">可做集合运算 &amp;（交集） |（并集） -（差集）</span><br><span class="line"></span><br><span class="line">s &#x3D; set(&#39;2235462346&#39;)</span><br><span class="line">s1 &#x3D; (&#123;1,2,3,3,4,5,2,3,4&#125;)    #自动去掉重复的元素，不能嵌套list,dict.</span><br><span class="line">#里面的元素必须是可hash的</span><br><span class="line">print(s)</span><br><span class="line">print(s1)</span><br><span class="line">list1 &#x3D; [1,2,3,4,5,2,3,4,2,2]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> a &#x3D; [1,2,3,4,5]</span><br><span class="line"> b &#x3D; a[:]       #此时b重新指向另一个地址 但如果其中内嵌容器，则只会对数值改变，容器仍指向原地址</span><br><span class="line"></span><br><span class="line"> l1 &#x3D; [1,[22,33],(11,22,[33,44])]</span><br><span class="line"></span><br><span class="line"> l2 &#x3D; list(l1)     #新的列表创建。但内嵌列表和元祖的指向地址未改变</span><br><span class="line"></span><br><span class="line"> l3 &#x3D; l1[:]        #新列表创建，内嵌容器仍指向原地址</span><br><span class="line"> print(l1 &#x3D;&#x3D; l2)</span><br><span class="line"> print(l1 is l2)</span><br><span class="line"></span><br><span class="line"> l1[1].append(1111111)</span><br><span class="line"> l1[2][2].append(2333)  #改变的为元祖中的内嵌列表，其仍可进行添加</span><br><span class="line"></span><br><span class="line"> l1[0] &#x3D; 9          #改变的是列表中的数值，其L1发生改变，对L2和L3无影响</span><br><span class="line"></span><br><span class="line"> print(l1)</span><br><span class="line"> print(l2)</span><br><span class="line"> print(l3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l1 &#x3D; [2,[44,55],(44,55,[3,1])]</span><br><span class="line">l2 &#x3D; list(l1)</span><br><span class="line">l1.append(100)</span><br><span class="line">l1[1].remove(44)</span><br><span class="line">l2[1] +&#x3D; [11,22]</span><br><span class="line">l2[2] +&#x3D; (2,3)     #生成新的tuple但其内嵌的列表地址未改变，相当于浅复制</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python集合</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础大全06--排序算法</title>
    <url>/jwangcloud/193083354/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/python01.jpeg"></p>
<h3 id="资料博客："><a href="#资料博客：" class="headerlink" title="资料博客："></a>资料博客：</h3><p><a href="https://www.jianshu.com/p/47170b1ced23">十大金典排序</a></p>
<span id="more"></span>

<h4 id="1-鸡尾酒排序-左右同时进行冒泡排序"><a href="#1-鸡尾酒排序-左右同时进行冒泡排序" class="headerlink" title="1. 鸡尾酒排序 左右同时进行冒泡排序"></a>1. 鸡尾酒排序 左右同时进行冒泡排序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def cocktaisort(list2):</span><br><span class="line">    left &#x3D; 0</span><br><span class="line">    right &#x3D; len(list2) - 1</span><br><span class="line">    while left &lt; right:</span><br><span class="line">        for i in range(left, right, 1):</span><br><span class="line">            if(list2[i] &gt; list2[i + 1]):</span><br><span class="line">                temp1 &#x3D; list2[i+1]</span><br><span class="line">                list2[i+1] &#x3D; list2[i]          #交换python可以直接使用：list2[i],list2[i+1] &#x3D; list2[i+1], list2[i]</span><br><span class="line">                list2[i] &#x3D; temp1</span><br><span class="line">        right -&#x3D; 1</span><br><span class="line">        for i in range(right,left,-1):</span><br><span class="line">            if(list2[i] &lt; list2[i - 1]):</span><br><span class="line">                temp1 &#x3D; list2[i]</span><br><span class="line">                list2[i] &#x3D; list2[i -1]</span><br><span class="line">                list2[i - 1] &#x3D; temp1</span><br><span class="line">        left+&#x3D;1</span><br><span class="line">        return list2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-冒泡排序-顺序比较-两两比较，依次后移-性能较低"><a href="#2-冒泡排序-顺序比较-两两比较，依次后移-性能较低" class="headerlink" title="2. 冒泡排序  顺序比较  两两比较，依次后移        性能较低"></a>2. 冒泡排序  顺序比较  两两比较，依次后移        性能较低</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def sort(list1):</span><br><span class="line">    num &#x3D; len(list1)</span><br><span class="line">    if num &#x3D;&#x3D; 0:</span><br><span class="line">        return list1</span><br><span class="line">    for i in range(0,num,1):</span><br><span class="line">        iswap &#x3D; False</span><br><span class="line">        for j in range(0,num - 1 - i,1):</span><br><span class="line">            if list1[j + 1] &lt; list1[j]:</span><br><span class="line">                temp &#x3D; list1[j + 1]</span><br><span class="line">                list1[j + 1] &#x3D; list1[j]</span><br><span class="line">                list1[j] &#x3D; temp</span><br><span class="line">                iswap &#x3D; True</span><br><span class="line">        if (not iswap):</span><br><span class="line">            break</span><br><span class="line">    return  list1</span><br></pre></td></tr></table></figure>

<h4 id="3-简化冒泡排序"><a href="#3-简化冒泡排序" class="headerlink" title="3. 简化冒泡排序"></a>3. 简化冒泡排序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def sort_bubble(list1):</span><br><span class="line">    for i in range(len(list1)):</span><br><span class="line">        j &#x3D; 0</span><br><span class="line">        while j &lt; (len(list1) - 1 - i):</span><br><span class="line">            if list1[j] &gt; list1[j + 1]:</span><br><span class="line">                temp &#x3D; list1[j]</span><br><span class="line">                list1[j] &#x3D; list1[j+1]</span><br><span class="line">                list1[j+1] &#x3D; temp</span><br><span class="line">            j +&#x3D; 1</span><br><span class="line">    return list1</span><br></pre></td></tr></table></figure>

<h4 id="4-简单选择排序"><a href="#4-简单选择排序" class="headerlink" title="4. 简单选择排序"></a>4. 简单选择排序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def simpesort(list1):</span><br><span class="line">    num &#x3D; len(list1)</span><br><span class="line">    if num &#x3D;&#x3D; 0:</span><br><span class="line">        return list1</span><br><span class="line">    for i in range(0,num):</span><br><span class="line">        min &#x3D; i                       #最小值下标</span><br><span class="line">        for j in range(i,num):         #i开始后推</span><br><span class="line">            if list1[j] &lt; list1[min]:   # 最小值与该值比较，符合则交换下标</span><br><span class="line">                min &#x3D; j</span><br><span class="line">        temp &#x3D; list1[min]              #下标对应值交换</span><br><span class="line">        list1[min] &#x3D; list1[i]</span><br><span class="line">        list1[i] &#x3D; temp</span><br><span class="line">    return list1</span><br></pre></td></tr></table></figure>

<h4 id="5-直接插入排序-取出i-1的元素-与前面排好序的元素从后向前比较，小于等于则将i-1元素插入到该位置（有一定序的时候效率最高）"><a href="#5-直接插入排序-取出i-1的元素-与前面排好序的元素从后向前比较，小于等于则将i-1元素插入到该位置（有一定序的时候效率最高）" class="headerlink" title="5. 直接插入排序:取出i + 1的元素 与前面排好序的元素从后向前比较，小于等于则将i+1元素插入到该位置（有一定序的时候效率最高）"></a>5. 直接插入排序:取出i + 1的元素 与前面排好序的元素从后向前比较，小于等于则将i+1元素插入到该位置（有一定序的时候效率最高）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def insert_sort(list1):</span><br><span class="line">    length &#x3D; len(list1)</span><br><span class="line">    if len(list1) &#x3D;&#x3D; 0:</span><br><span class="line">        return list1</span><br><span class="line">    for i in range(1,length,1):</span><br><span class="line">        temp &#x3D; list1[i]</span><br><span class="line">        preindex &#x3D; i - 1</span><br><span class="line">        while preindex &gt;&#x3D; 0 and temp &lt; list1[preindex]:</span><br><span class="line">            list1[preindex + 1] &#x3D; list1[preindex]</span><br><span class="line">            preindex -&#x3D; 1</span><br><span class="line">        list1[preindex + 1] &#x3D; temp</span><br><span class="line">    return list1</span><br></pre></td></tr></table></figure>

<h4 id="6-二分插入排序-排好序的为一个数组，未排好序的为另一个"><a href="#6-二分插入排序-排好序的为一个数组，未排好序的为另一个" class="headerlink" title="6. 二分插入排序  排好序的为一个数组，未排好序的为另一个"></a>6. 二分插入排序  排好序的为一个数组，未排好序的为另一个</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def Binaryinsertsort(list1):</span><br><span class="line">    if len(list1) &#x3D;&#x3D; 0:</span><br><span class="line">        return list1</span><br><span class="line">    for i in range(1,len(list1)):</span><br><span class="line">        left &#x3D; 0</span><br><span class="line">        right &#x3D; i - 1   #有序边界</span><br><span class="line">        temp &#x3D; list1[i]</span><br><span class="line">        while left &lt;&#x3D; right:</span><br><span class="line">            mid &#x3D; left + (right - left) &#x2F;&#x2F; 2</span><br><span class="line">            if list1[mid] &gt; temp:</span><br><span class="line">                right &#x3D; mid - 1</span><br><span class="line">            else:</span><br><span class="line">                left &#x3D; mid + 1</span><br><span class="line">        for j in range(i - 1,left,-1):</span><br><span class="line">            list1[j+1] &#x3D; list1[j]</span><br><span class="line">        list1[left] &#x3D; temp</span><br><span class="line">    return list1</span><br></pre></td></tr></table></figure>

<h4 id="7-归并排序-空间换时间，多了一个tmp列表占用内存，但时间减少为n-logn"><a href="#7-归并排序-空间换时间，多了一个tmp列表占用内存，但时间减少为n-logn" class="headerlink" title="7.归并排序 空间换时间，多了一个tmp列表占用内存，但时间减少为n*logn"></a>7.归并排序 空间换时间，多了一个tmp列表占用内存，但时间减少为n*logn</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def merge_sort(list1):</span><br><span class="line">    if len(list1) &lt; 2:</span><br><span class="line">        return list1</span><br><span class="line">    else:                               #递归函数分解列表</span><br><span class="line">        mid &#x3D; len(list1) &#x2F;&#x2F; 2</span><br><span class="line">        list1_left &#x3D; merge_sort(list1[:mid])</span><br><span class="line">        list1_right &#x3D; merge_sort(list1[mid:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        tmp &#x3D; list()                   #tmp 为新列表 存放排好序的元素</span><br><span class="line">        i &#x3D; 0</span><br><span class="line">        j &#x3D; 0</span><br><span class="line">        k &#x3D; 0</span><br><span class="line">        while i &lt; len(list1_left) or j &lt; len(list1_right):     #循环条件</span><br><span class="line">            if i &lt; len(list1_left) and j &lt; len(list1_right):   #两个有序列表相比较，开始为一个元素，直接累积为两个有序列表</span><br><span class="line">                if list1_left[i] &lt; list1_right[j]:             #判断两个列表中元素的大小，小的放入tmp列表</span><br><span class="line">                    tmp.append(list1_left[i])</span><br><span class="line">                    i+&#x3D;1</span><br><span class="line">                else:</span><br><span class="line">                    tmp.append(list1_right[j])</span><br><span class="line">                    j +&#x3D; 1</span><br><span class="line">            elif i &gt;&#x3D; len(list1_left):                        #分别判断是否超出左右列表最大下标，则只需要把左右列表合并到tmp里 反之一样</span><br><span class="line">                tmp.append(list1_right[j])</span><br><span class="line">                j +&#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                tmp.append(list1_left[i])</span><br><span class="line">                i +&#x3D; 1</span><br><span class="line">        return tmp</span><br></pre></td></tr></table></figure>

<h3 id="调用所有排序"><a href="#调用所有排序" class="headerlink" title="调用所有排序"></a>调用所有排序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def random_sort(sort_name):</span><br><span class="line">    import random</span><br><span class="line">    list1 &#x3D; list()</span><br><span class="line">    for i in range(10):</span><br><span class="line">        list1.append(random.randint(0,100))</span><br><span class="line"></span><br><span class="line">    print(&quot;使用%s排序结是%s&quot;%(sort_name.__name__,sort_name(list1)))</span><br><span class="line"></span><br><span class="line">list2 &#x3D; [cocktaisort,sort,sort_bubble,simpesort,Binaryinsertsort,merge_sort]</span><br><span class="line"></span><br><span class="line">for xx in list2:</span><br><span class="line">    random_sort(xx)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用装饰器计算程序运行时间"><a href="#使用装饰器计算程序运行时间" class="headerlink" title="使用装饰器计算程序运行时间"></a>使用装饰器计算程序运行时间</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def dec(fun):             #装饰器：计算运行时间</span><br><span class="line">    def res(*args,**kwarges):</span><br><span class="line">        print(&#39;--------%s 算法-------------&#39; % (fun.__name__))</span><br><span class="line">        start &#x3D; time.perf_counter()</span><br><span class="line">        a &#x3D; fun(*args,**kwarges)</span><br><span class="line">        print(&#39;消耗的时间为 %s&#39; %(time.perf_counter() - start))</span><br><span class="line">        print(&#39;******************&#39;)</span><br><span class="line">        return a</span><br><span class="line">    return res</span><br><span class="line">    </span><br><span class="line">在需要计算时间的函数前加上 @dec 即可（详见test19.py）</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础大全04--控制语句</title>
    <url>/jwangcloud/3540061980/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/python01.jpeg"></p>
<h2 id="控制语句："><a href="#控制语句：" class="headerlink" title="控制语句："></a>控制语句：</h2><span id="more"></span>

<h3 id="1-if-判断语句，"><a href="#1-if-判断语句，" class="headerlink" title="1 if 判断语句，"></a>1 if 判断语句，</h3><p>只接受True/False，只运行判断为真的语句快。</p>
<p>语句快中pass会不执行这一块语句</p>
<p>可以在判断语句中先赋值，再在语句外调用该值</p>
<p>if   else:</p>
<p>if elif else: 满足其中一个条件则执行该条件后直接跳出语句块</p>
<h4 id="1-1-基础判断举例"><a href="#1-1-基础判断举例" class="headerlink" title="1.1 基础判断举例"></a>1.1 基础判断举例</h4><ol>
<li>该成员是否是会员</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">is_plus &#x3D; True #是否是会员    # 基础判断</span><br><span class="line">if is_plus:</span><br><span class="line">    print(&quot;恭喜你，会员大大 &quot;)</span><br><span class="line">elif not is_plus:</span><br><span class="line">    print(&quot;垃圾小号&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;请充钱&quot;)</span><br><span class="line">print(&quot;用薪创造快乐&quot;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>折扣计算</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buy_sum &#x3D; float(input(&quot;购买后金额为：&quot;))     #折扣计算</span><br><span class="line">if buy_sum &lt; 0:</span><br><span class="line">    print(&quot;非法操作&quot;)</span><br><span class="line">else:</span><br><span class="line">    if buy_sum &gt; 400:</span><br><span class="line">        buy_sum &#x3D; buy_sum * 0.85</span><br><span class="line">    else:</span><br><span class="line">        buy_sum &#x3D; buy_sum * 0.95</span><br><span class="line">    print(&quot;实际支付金额：%.2f&quot; % buy_sum)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>分数等级判断</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">score &#x3D; float(input(&quot;分数： &quot;))     #输入分数并判断其等级</span><br><span class="line">if score &gt; 100 or score &lt; 0:</span><br><span class="line">    print(&quot;无法判断&quot;)</span><br><span class="line">elif score &gt;&#x3D; 90:</span><br><span class="line">    print(&quot;等级为： A&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;等级为： F&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="循环语句："><a href="#循环语句：" class="headerlink" title="循环语句："></a>循环语句：</h2><h3 id="while："><a href="#while：" class="headerlink" title="while："></a>while：</h3><p>若判断条件为真，循环运行其中的语句块，若为假，运行语句块外语句  注意：每次循环都会执行一次while进行判断</p>
<p>break：停止循环</p>
<p>continu：结束本次循环继续下一次循环</p>
<h3 id="while循环举例"><a href="#while循环举例" class="headerlink" title="while循环举例"></a>while循环举例</h3><p>成绩录入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num &#x3D; 1</span><br><span class="line">score &#x3D; 0</span><br><span class="line">while True:</span><br><span class="line">    n &#x3D; input(&quot;请输入第&#123;&#125;科成绩: &quot;.format(num))</span><br><span class="line">    n &#x3D; int(n)</span><br><span class="line">    if n &gt; 100 or n &lt; 0:</span><br><span class="line">        n &#x3D; input(&quot;输入错误，请重新输入第&#123;0&#125;科成绩&quot;.format(num))     #print（&quot;输入错误，请重新输入&quot;） continue</span><br><span class="line">        n &#x3D; int(n)                                               #使用continu可以结束本次循环</span><br><span class="line">    score &#x3D; score + n</span><br><span class="line">    if num &gt;&#x3D;5:</span><br><span class="line">        print(&quot;总成绩为：&#123;0&#125;,平均成绩为：&#123;1&#125;&quot;.format(score, score&#x2F;num))</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">    num +&#x3D; 1</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>九九乘法表</p>
<p>利用while循环进行，声明变量需要清晰表达所表达的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">倒九九乘法表</span><br><span class="line"></span><br><span class="line">i &#x3D; 1</span><br><span class="line"></span><br><span class="line">while i &lt;&#x3D; 9:</span><br><span class="line">    j &#x3D; 9</span><br><span class="line">    xx &#x3D;&quot;&quot;</span><br><span class="line">    while j &gt;&#x3D; i:</span><br><span class="line">        xx +&#x3D; (&quot;&#123;0:d&#125; * &#123;1:d&#125; &#x3D; &#123;2:2d&#125;  |  &quot;.format(i,j,i * j))</span><br><span class="line">        j -&#x3D; 1</span><br><span class="line">    print(xx)</span><br><span class="line">    i +&#x3D; 1</span><br></pre></td></tr></table></figure>

<p>图形数字输出</p>
<p>在做类似多个循环嵌套时，可以将循环拆分开一步一步分拆成单个变量循环，最后嵌套在一起。对于本题，整个：先输出空格，再输出数字</p>
<pre><code>    1
   2 3 
  4 5 6
 7 8 9 0
  
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">space_num &#x3D; n - 1</span><br><span class="line">i &#x3D; 1</span><br><span class="line">n &#x3D; 4</span><br><span class="line">while space_num &gt;&#x3D; 0:</span><br><span class="line">    string &#x3D; (&quot; &quot;*space_num)</span><br><span class="line">    j &#x3D; 0</span><br><span class="line">    while (n - space_num) &gt; j:</span><br><span class="line">        string +&#x3D; str(i % 10) + &quot; &quot;</span><br><span class="line">        i +&#x3D; 1</span><br><span class="line">        j +&#x3D; 1</span><br><span class="line">    print(string)</span><br><span class="line">    space_num -&#x3D; 1</span><br></pre></td></tr></table></figure>

<pre><code>         *
        **
       ***
      ****
     *****
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">lines &#x3D; 6</span><br><span class="line">start_num &#x3D; 6</span><br><span class="line">j &#x3D; lines</span><br><span class="line">while j &gt; 0:</span><br><span class="line">    space_num &#x3D; lines - start_num</span><br><span class="line"></span><br><span class="line">    print(&quot; &quot; * space_num + &quot;*&quot; * start_num)</span><br><span class="line">    start_num -&#x3D; 1</span><br><span class="line">    j -&#x3D; 1</span><br></pre></td></tr></table></figure>


<pre><code>        *
       ***
      *****
     *******
      *****
       ***
        *
    
    分析： 
    （1）先确认行数：n                          n = 7 
    （2）再判断图形组成元素即对象数量，并确认命名    两个对象： 空格（space_num） *号 (star_num)
    （3）发现每个对象的循环规律，最好与循环或已知变量关联   space_num = abs(中间行数mid - 循环1.2.3...)
                            规律： 等差数列             star_num = (mid - space_num)* 2 - 1             
    （4）确认循环结束条件： n &gt; 0 n递减  i递增               
    （5）编写 测试
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">代码：</span><br><span class="line">n &#x3D; 7</span><br><span class="line">mid &#x3D; n &#x2F;&#x2F; 2 + 1 #中间那一排</span><br><span class="line">i &#x3D; 1</span><br><span class="line">while n &gt; 0:</span><br><span class="line">    space_num &#x3D; abs(mid-i) #3</span><br><span class="line">    base_num &#x3D; mid-space_num #1</span><br><span class="line">    star_num &#x3D; base_num*2-1</span><br><span class="line">    print(&#39; &#39;*space_num + &quot;*&quot;*star_num)</span><br><span class="line">    i +&#x3D; 1</span><br><span class="line">    n -&#x3D; 1</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*****</span><br><span class="line"> ***</span><br><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &#x3D; 5                          # 中间一行的行数</span><br><span class="line">a &#x3D; n                          #3</span><br><span class="line">j &#x3D; 2 * n + 1                  #7 一共7行</span><br><span class="line">while j &gt; 0:                   #循环7次</span><br><span class="line">    space_num &#x3D; n - abs(a)     # 初始化</span><br><span class="line">    j -&#x3D; 1                     #j控制循环</span><br><span class="line">    line_num &#x3D; abs(2 * a) + 1  #  *  数</span><br><span class="line">    a -&#x3D; 1                     #  a递减 3 2 1 0 -1 -2 -3</span><br><span class="line">    print(&quot; &quot;* (space_num) + &quot;*&quot; *line_num )</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输入一个整数n，输出所有0~n之间的质数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">def is_peime(num):           #判断是否为质数</span><br><span class="line">    i &#x3D; 2</span><br><span class="line">    flag &#x3D; True</span><br><span class="line">    while num &gt; i:           #循环条件</span><br><span class="line">        if not num % i:      #质数判断，若为真（不是质数）则执行判断语句</span><br><span class="line">            flag &#x3D; False</span><br><span class="line">            break            #符合该条件则直接跳出循环</span><br><span class="line">        i +&#x3D; 1</span><br><span class="line">    return flag</span><br><span class="line"></span><br><span class="line">num1 &#x3D; int(input(&quot;请输入一个大于1的整数： &quot;))    #输出所有符合条件的质数</span><br><span class="line">while num1 &gt; 0:</span><br><span class="line">    if is_peime(num1):      #调用质数函数</span><br><span class="line">        print(num1)</span><br><span class="line">    num1 -&#x3D; 1</span><br></pre></td></tr></table></figure>

<p>当比较大小时，需要注意比较值的初始化，最好与初始值输入值一样，不定义成0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1、从键盘输入10个数，求出最大数</span><br><span class="line"></span><br><span class="line">num &#x3D; 1</span><br><span class="line">max_num &#x3D; int(input(&quot;请依次输入第&#123;&#125;个数：&quot;.format(num)))    #初始化最大值，防止输入的数为负数，若比较大小都需要初始化比较值。</span><br><span class="line"></span><br><span class="line">while num &lt; 10:</span><br><span class="line">    num +&#x3D; 1</span><br><span class="line">    num1 &#x3D; int(input(&quot;请依次输入第&#123;&#125;个数：&quot;.format(num)))</span><br><span class="line">    if num1 &gt; max_num:                           #若max_num&#x3D;0，出现负数比较则直接会使max_num&#x3D;0</span><br><span class="line">        max_num &#x3D; num1</span><br><span class="line">print(max_num)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>控制语句</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础大全05--list</title>
    <url>/jwangcloud/2660417926/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/python01.jpeg"></p>
<h3 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a>list 列表</h3><span id="more"></span>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据结构：组织并存取数据</span><br><span class="line">list:有序的集合，列表 ，是一种数据结构</span><br><span class="line">创建方式</span><br><span class="line">取值方式</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1.申明方式</p>
<pre><code>list1 = [&#39;a&#39;,2,3,[1,2,3,4,[1,2,3]],&#39;abcde&#39;]
</code></pre>
<p>2.将字符串转化为列表</p>
<pre><code>list2 = list(&quot;a,b&quot;)
print(list2)
</code></pre>
<p>3.下标取值,下标取首不取尾,与数组相似取值方式</p>
<pre><code>print(list1[3][4][1])
print(list1[0:3])
</code></pre>
<p>4.最后一个元素取法</p>
<pre><code>print(list1[-1])
print(list1[len(list1)-1])    #列表不能为空
</code></pre>
<p>5.使用的len语句是计算的该列表中有多少个元素</p>
<pre><code>print(len(list1[3]))
</code></pre>
<p>6.元素更改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(list1[1])</span><br><span class="line">list1[1] &#x3D; &quot;b&quot;         #元素修改</span><br><span class="line">print(list1[1])</span><br><span class="line">list1.append(&#39;f&#39;)      #尾部增加元素   其内置函数中没有return 所以print(list1.append())返回值为none</span><br><span class="line">list1.insert(1,&#39;b&#39;)    #在下标1处添加元素 返回值为none</span><br><span class="line">print(list1.insert(1,&#39;3&#39;))</span><br><span class="line">x &#x3D; list1.pop(1)       #删除下标所在位置的元素，若无下标，则将尾部元素删除，返回值为删除的元素</span><br><span class="line">list1.remove(&#39;a&#39;)        #找到该元素并移除 返回为none</span><br><span class="line">range(start_num,end_num,间隔)：有序的一组数字</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list2 &#x3D; [1,&#39;hello&#39;, &#39;world&#39;,&#39;c&#39;,&#39;d&#39;,[1,2,3,[1,2],5]]   #打印输出列表所有元素</span><br><span class="line">for i in list2:                                  #for循环会将列表中存在的字符串也分开打印，例如&#39;asd&#39;,for后为 &#39;a&#39;,&#39;s&#39;,&#39;d&#39;</span><br><span class="line">    if not type(i) &#x3D;&#x3D; list:                     #判断类别</span><br><span class="line">        print(i)</span><br><span class="line">    else:</span><br><span class="line">        for j in i:</span><br><span class="line">            print(j)</span><br><span class="line">def for_list(list1):                 #使用函数打印所有列表中的元素</span><br><span class="line">    for i in list1:</span><br><span class="line">        if type(i) &#x3D;&#x3D; list:</span><br><span class="line">            for_list(i)</span><br><span class="line">        else:</span><br><span class="line">            print(i)</span><br><span class="line">for_list([1,2,3,[1,2,[1,2,[12,34,[&#39;aasas&#39;,&#39;asadadf&#39;]]]]])  </span><br></pre></td></tr></table></figure>

<p>7.列表切分</p>
<pre><code>list3 = [1,2,3,4,5]
print(list3[1:3])   #切分1-2下标元素 长度为下标差
</code></pre>
<p>8.容器序列（容器）和编排序列（真正的数据）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list1 --&gt; 容器(列表，元祖等） [1,2,3,4,5],[True,False] --&gt; 编排序列</span><br><span class="line"></span><br><span class="line">传统生成方式</span><br><span class="line">list1 &#x3D; []</span><br><span class="line">for i in range(10):</span><br><span class="line">    list1.append(i)</span><br><span class="line"></span><br><span class="line">列表生成式：将一个编排序列放入列表中</span><br><span class="line">list1 &#x3D; [i for i in range(10)]       #性能更高</span><br><span class="line">list2 &#x3D; [i for i in &#39;asdfghjk&#39;]</span><br><span class="line"></span><br><span class="line">print(list1)</span><br><span class="line">print(list2)</span><br><span class="line"></span><br><span class="line">list3 &#x3D; [(i, j) for i in list1 for j in list2]   #注意：(i,j)</span><br><span class="line">print(list3)</span><br><span class="line"></span><br><span class="line">l1 &#x3D; [&#39;spades&#39;, &#39;diamonda&#39;,&#39;clubs&#39;,&#39;hearts&#39;]</span><br><span class="line">l2 &#x3D; [&#39;A&#39;,2,3,4,5,6,7,8,9,&#39;j&#39;,&#39;q&#39;,&#39;k&#39;,10]</span><br><span class="line">list4 &#x3D; [((i,j)) for i in l2 for j in l1]    #注意循环次序</span><br><span class="line"></span><br><span class="line">i  &#x3D; 0</span><br><span class="line">l2 &#x3D; list()</span><br><span class="line">while i &lt; (len(list4)):</span><br><span class="line">    if &quot;k&quot; in list4[i]:</span><br><span class="line">        l2 +&#x3D; list4[i:i+1]</span><br><span class="line">    i +&#x3D; 1</span><br><span class="line"></span><br><span class="line">print(l2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>9.切片  取左不取右 前闭后开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">list1&#x3D; [i for i in range(1,11,1)]</span><br><span class="line">print(list1)</span><br><span class="line">xx &#x3D; list1[2:4]   #2,3  便于计算切片的数量：4-2</span><br><span class="line">yy &#x3D; list1[1:]    #list1[1:len(list1)]</span><br><span class="line">zz &#x3D; list1[:3]    #不包括3之前的</span><br><span class="line">print(xx)</span><br><span class="line"></span><br><span class="line">l1 &#x3D; list1[-1]</span><br><span class="line">l2 &#x3D; list1[-1:]</span><br><span class="line">print(l1)</span><br><span class="line">print(l2)     #两者区分，一个取值一个切片仍是列表</span><br><span class="line"></span><br><span class="line"># print(id(list1))</span><br><span class="line"># print(id(list1[2:5]))</span><br><span class="line"># print(id(list1[3:4]))</span><br><span class="line"># print(id(xx))</span><br><span class="line"># print(id(yy))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>10.引用规则：python中变量是引用而不是赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; [1,2,3]</span><br><span class="line">b &#x3D; a              #直接将a的地址给了b，未重新开空间 对两个变量进行操作时，都是对同一个地址中存储的数据操作</span><br><span class="line">a.append(4)</span><br><span class="line">print(a)</span><br><span class="line">print(id(a))</span><br><span class="line">print(b)</span><br><span class="line">print(id(b))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python集合</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础大全03--函数定义</title>
    <url>/jwangcloud/2679684480/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/python01.jpeg"></p>
<h3 id="函数基本定义"><a href="#函数基本定义" class="headerlink" title="函数基本定义"></a>函数基本定义</h3><span id="more"></span>

<ol>
<li>申明 函数命名规则与变量一样</li>
<li>函数需要调用后才会运行，并函数可重复调用</li>
<li>函数内部申明的变量在外部无法使用，即函数作用域</li>
<li>全局变量：在函数外部定义的变量，可以拿到函数内部使用，只需要在需要使用该变量的函数内部将该变量变为全局变量：global 变量名</li>
<li>变量的传递：将需要传递的变量放入函数头（）中,传递多个参数时，用, 隔开，在调用函数时需要注意一一对应其变量值，即 参数：可随意改变的值</li>
<li>函数返回值：return 返回变量 ，调用函数则会返回return的结果，，其函数中若没有return 会在结尾自动加一个，存在输出语句则也会输出</li>
<li>自定义函数/内置函数</li>
<li>return: 返回的为函数时，会暂停运行并调用相关函数，直到返回值为确定值，则继续运行该函数</li>
<li>递归函数：函数调用函数本身</li>
</ol>
<h3 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h3><p>1.1 * 2 * 3 * 4 * 5 * 。。。n =</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤： 1. 停止条件：n &#x3D; 1</span><br><span class="line">	  2. 分解条件（规律）： 若 n &#x3D; 5  （确认一个后面的数，往前推）</span><br><span class="line">	  </span><br><span class="line">	   5 * num_sum(4)</span><br><span class="line">	   	        4   *  num_sum(3)</span><br><span class="line">	   	        			 3     *  num_sum(2)</span><br><span class="line">										   2 * num_sum(1) --&gt; num_sum(1)&#x3D;&#x3D;1</span><br><span class="line">	   5  *     4   *         3     *      2 *   1		   	        								 </span><br><span class="line">	   	        						    </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def num_sum(n):</span><br><span class="line">    if n &#x3D;&#x3D; 1:            #添加停止条件</span><br><span class="line">        return n</span><br><span class="line">    else:</span><br><span class="line">        return n * num_sum(n - 1)    #递归函数，分解条件</span><br><span class="line"></span><br><span class="line">print(num_sum(5))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.斐波拉契数：1 1 2 3 5 8 …</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">		</span><br><span class="line">		1.停止条件：n &#x3D; 1或者 n &#x3D; 2 即 num_qq(1) &#x3D; 1 num_qq(2) &#x3D; 1 （即最小元子确认）</span><br><span class="line">		2.循环条件：若 n &#x3D; 5 ：  bile(n) + bile(n-1)</span><br><span class="line">				 			bile(5) </span><br><span class="line">			    			&#x2F;     \</span><br><span class="line">					bile(4)  +   bile(3)</span><br><span class="line">       			&#x2F;	  \	         </span><br><span class="line">   				bile(3)+ bile(2)  </span><br><span class="line">    			&#x2F;     \    1        </span><br><span class="line"> 			bile(2)+bile(1)</span><br><span class="line"> 			  1       1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def num_qq(n):</span><br><span class="line">    if n &#x3D;&#x3D; 1 or n &#x3D;&#x3D; 2:     #添加停止条件</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        return num_qq(n - 1) + num_qq(n - 2)   #递归函数分解条件，反推或者正推 数值太大会卡顿</span><br></pre></td></tr></table></figure>

<p>3.汉诺塔</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">递归函数：解题思路，将n&#x3D;&#x3D;1的写出来 即将底层的结果写出来，然后将自己知道的过程或者下一步写出来，将下一步的如2 当成n </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def is_equeue(n,start, mid, end):</span><br><span class="line">    if n &#x3D;&#x3D; 1:</span><br><span class="line">        print(&quot;&#123;&#125; to &#123;&#125;&quot;.format(start,end))     #一个的时候移动步骤</span><br><span class="line">    else:</span><br><span class="line">        is_equeue(n -1,start,end,mid)           #两个时候的移动步骤，当成n     2-1</span><br><span class="line">        is_equeue(1,start,mid,end)</span><br><span class="line">        is_equeue(n-1,mid,start,end)</span><br><span class="line"></span><br><span class="line">is_equeue(3,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.二分法查找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def find(i, l):</span><br><span class="line">    num &#x3D; len(l) &#x2F;&#x2F; 2</span><br><span class="line">    if len(l) &#x3D;&#x3D; 0:</span><br><span class="line">        print(&quot;0&quot;)</span><br><span class="line">    elif i &gt; l[num]:</span><br><span class="line">        find(i,l[(num + 1): ]) #可以不再判断这个中间值 直接+1</span><br><span class="line"></span><br><span class="line">    elif i &lt; l[num]:</span><br><span class="line">        find(i,l[ :num])</span><br><span class="line"></span><br><span class="line">    else:</span><br><span class="line">        print(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">find(13,[1,2,3,4,5,6,7,8,9])</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查找并定位</span><br><span class="line"></span><br><span class="line">def find(l,num,start,end):</span><br><span class="line">    mid_index &#x3D; (end + start) &#x2F;&#x2F; 2</span><br><span class="line">    if start &gt; end:</span><br><span class="line">        print(&quot;列表中不存在%d&quot;%num)</span><br><span class="line">    else:</span><br><span class="line">        if l[mid_index] &gt; num:</span><br><span class="line">            return find(l,num,1,mid_index -1)</span><br><span class="line">        elif l[mid_index] &lt; num:</span><br><span class="line">            return find(l,num,mid_index + 1,end)</span><br><span class="line">        elif l[mid_index] &#x3D;&#x3D; num:</span><br><span class="line">            print(&quot;%d 的位置为：%d&quot;%(num,mid_index))</span><br><span class="line"></span><br><span class="line">l &#x3D; [1,2,3,4,5,6,7,8,9,12,23,45]</span><br><span class="line">find_i &#x3D; len(l)</span><br><span class="line">find(l,3,0,find_i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5.一等函数，和变量一样，可传递和赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def fun1():</span><br><span class="line">    print(2112)</span><br><span class="line">a &#x3D; fun1   #当成变量进行赋值</span><br><span class="line">b &#x3D; a</span><br><span class="line">b()     #此时才是运行函数</span><br></pre></td></tr></table></figure>

<p>6.高阶函数  接受函数作为参数的函数 详见pysort.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sorted  排序，</span><br><span class="line">fruits &#x3D; [&#39;strawberry&#39;,&#39;fig&#39;,&#39;apple&#39;,&#39;cherry&#39;,&#39;raspberry&#39;,&#39;banana&#39;]</span><br><span class="line">list2 &#x3D; sorted(fruits,key&#x3D;len)   #根据len产生的返回值进行排序</span><br><span class="line">print(list2)</span><br><span class="line"></span><br><span class="line">def first_num(list1):</span><br><span class="line">    return list1[0]</span><br><span class="line">list4 &#x3D; sorted(fruits,key&#x3D;first_num)</span><br><span class="line">print(list4)</span><br><span class="line">lamda  无法复用，简单结构可以使用</span><br><span class="line"></span><br><span class="line">list5 &#x3D; sorted(fruits,key&#x3D;lambda list_1: list_1[0])</span><br><span class="line"></span><br><span class="line">print(list5)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础大全01--内置对象、占位符、运算符、表达式</title>
    <url>/jwangcloud/446152610/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/python01.jpeg"></p>
<h3 id="常用内置对象"><a href="#常用内置对象" class="headerlink" title="常用内置对象"></a>常用内置对象</h3><span id="more"></span>

<table>
<thead>
<tr>
<th align="center">对象类型</th>
<th align="center">类型名称</th>
<th align="center">示例</th>
<th align="center">简要说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数字</td>
<td align="center">int、float</td>
<td align="center">1、3.14</td>
<td align="center">数字大小没有限制，内置支持复数及其运算</td>
</tr>
<tr>
<td align="center">字符串</td>
<td align="center">str</td>
<td align="center">‘hello’、”python”、’‘’world’’’、r’abc’、R’bcd’</td>
<td align="center">使用单引号、双引号、三引号作为界定符，以字母r和R引导表示原生字符串</td>
</tr>
<tr>
<td align="center">列表</td>
<td align="center">list</td>
<td align="center">[1,2,3]、[‘a’,’b’]</td>
<td align="center">元素可为任意类型</td>
</tr>
<tr>
<td align="center">字典</td>
<td align="center">dict</td>
<td align="center">{“aa”:”11”}</td>
<td align="center">元素形式为：键：值</td>
</tr>
<tr>
<td align="center">元组</td>
<td align="center">tuple</td>
<td align="center">(2,-2,1)、(3,)</td>
<td align="center">不可变的列表，如果只有一个元素，后面的逗号不能省略</td>
</tr>
<tr>
<td align="center">布尔</td>
<td align="center">bool</td>
<td align="center">True、False</td>
<td align="center">逻辑值</td>
</tr>
<tr>
<td align="center">空类型</td>
<td align="center">NoneType</td>
<td align="center">None</td>
<td align="center">空值</td>
</tr>
<tr>
<td align="center">异常</td>
<td align="center">ValueError、TypeError…</td>
<td align="center"></td>
<td align="center">python内置异常，对应不同类型的异常</td>
</tr>
</tbody></table>
<h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">d i u</td>
<td align="center">十进制整数</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center">八进制整数</td>
</tr>
<tr>
<td align="center">x X</td>
<td align="center">十六进制整数（x的话数字里字母为小写，X为大写）</td>
</tr>
<tr>
<td align="center">e E</td>
<td align="center">科学技数法</td>
</tr>
<tr>
<td align="center">f F</td>
<td align="center">浮点数（默认保留6位小数）</td>
</tr>
<tr>
<td align="center">g G</td>
<td align="center">自动选择最优表示法（整数、浮点数、科学技数）</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">单个字符或整数转化为字符</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center">用str()转化为字符串</td>
</tr>
<tr>
<td align="center">r</td>
<td align="center">用repr()转化为字符串</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">用ascii（）转化为字符串</td>
</tr>
</tbody></table>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol>
<li>变量命名<pre><code> 变量中不能有空格以及标点符号
 大小写敏感
 数字不出现在开头
 内置关键字不会出现在其中（查询关键：导入keyword包，print(keyword.kwlist)）
 符合常识并有意义
</code></pre>
</li>
<li>对象</li>
</ol>
<p>python 中一切皆对象 ：</p>
<table>
<thead>
<tr>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">内存地址（身份id）</td>
</tr>
<tr>
<td align="center">类型（type）</td>
</tr>
<tr>
<td align="center">值（实际值）</td>
</tr>
</tbody></table>
<h3 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a>运算符和表达式</h3><ol>
<li>运算符说明</li>
</ol>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">功能说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">算数加法，列表、元组、字符串合并与连接，正号</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">算数减法，集合差集，相反数</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">算数乘法，序列重复</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">真除法</td>
</tr>
<tr>
<td align="center">//</td>
<td align="center">整除，若其中包含实数，结果也为实数</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">余数，字符串格式化</td>
</tr>
<tr>
<td align="center">**</td>
<td align="center">幂运算</td>
</tr>
<tr>
<td align="center">&lt; &gt; &lt;= &gt;= != ==</td>
<td align="center">值比较符，集合的包含关系比较</td>
</tr>
</tbody></table>
<ol start="2">
<li>python 运算符与功能<pre><code> or: 逻辑或
 and:逻辑与
 not：逻辑非
 in:成员测试
 is:对象测试，即判断是否为同一对象或内存地址是否相同
</code></pre>
</li>
<li>二进制位运算符：如果为十进制会将其先转化为二进制进行下述运算<pre><code> | ：位或
 ^ : 位异或
 &amp; ：位与
 &lt;&lt; : 左位移
 &gt;&gt; : 右位移
 ～ ：位求反

 
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>内置对象</tag>
        <tag>占位符</tag>
        <tag>运算符</tag>
        <tag>表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础大全02--helloword</title>
    <url>/jwangcloud/3728702410/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/index/python01.jpeg"></p>
<h1 id="python常识"><a href="#python常识" class="headerlink" title="python常识"></a>python常识</h1><span id="more"></span>


<ol>
<li>编译器：编译器就是将“一种语言（通常为高级语言）”翻译为“另一种语言（通常为低级语言）”的程序。一个现代编译器的主要工作流程：源代码 (source code) → 预处理器 (preprocessor) → 编译器 (compiler) → 目标代码 (object code) → 链接器 (Linker) → 可执行程序 (executables)</li>
<li>python编译器：pythonc</li>
<li>pyhton领域：数据分析、人工智能、爬虫</li>
<li>python缺点：运行速度慢，属于解释性语言</li>
</ol>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ol>
<li>int: 整型 <pre><code> 注意：print(&quot;12345&quot;) 与 print(12345), 前者是字符串存储，其占40个bit 后者为整型，占14个bit.
      前者是ascill码保存，后者直接转化为二进制
</code></pre>
</li>
<li>float：单精度型 </li>
<li>两者区别：前者直接可以转化为二进制，后者需要遵循IEEE协议进行编码（指数E）</li>
</ol>
<h1 id="入门命令"><a href="#入门命令" class="headerlink" title="入门命令"></a>入门命令</h1><ol>
<li>print(“hello world”)</li>
<li>print(123456)</li>
<li>bin(589): 将十进制转化为二进制</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
        <tag>python入门</tag>
      </tags>
  </entry>
</search>
