---
title: JVM手册
categories: JVM
tags:
  - JVM
top: 200
abbrlink: 2070776324
date: 2021-12-09 10:04:24
password:
---


## 本文架构

![JVM](https://jwangtec.oss-cn-chengdu.aliyuncs.com/jwangcloud/JVM/JVM%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png)

<!--more-->


## 内存溢出

### 系统的线程划分

#### 串行收集器

- 用单线程处理所有垃圾回收工作 ， 效率高
- 数据量比较小（100M左右）；单处理器下并且对响应时间无要求的应用

#### 并行收集器

- “对吞吐量有高要求”，多CPU、对应用响应时间无要求的中、大型应用
	
#### 并发处理器

-  对响应时间有高要求”，多CPU、对应用响应时间有较高要求的中、大型应用

### Java 的四种引用类型

- 强引用 (StrongReference) : 通常为 new 直接创建 , 只要还有对象指向 , 就不会发生回收
- 软引用（SoftReference）: 内存溢出之前会 clear 弱引用 , 如果还是存在 , 则抛出OutofMemory (extends WeakReference)
- 弱引用（WeakReference）: 只会生存到下一次生命周期之前 , SoftReference  (new SoftReference(res))
- 虚引用（PhantomReference）: 主要作用是在垃圾收集时拿到一个通知

```java
// 软引用创建案例一 : 
String str = new String("abc"); 
SoftReference<String> softReference = new SoftReference<String>(str);

// 软引用创建案例二 : 
ReferenceQueue<String> referenceQueue = new ReferenceQueue<>();
String str = new String("abc");
SoftReference<String> softReference = new SoftReference<>(str, referenceQueue);

softReference.get()
referenceQueue.poll()

// 弱引用创建案例: 
WeakReference<String> weakReference = new WeakReference<>(str);

// 虚引用创建案例 : 
ReferenceQueue queue = new ReferenceQueue(); // 创建虚引用，要求必须与一个引用队列关联 
PhantomReference pr = new PhantomReference(str, queue);

```

### TLAB

- TLAB的全称是Thread Local Allocation Buffer，即线程本地分配缓存区，这是一个线程专用的内存分配区域。 
- 如果设置了虚拟机参数 -XX:UseTLAB，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。
- 在代码流程中 , 对象通过引用指向实际的内存空间 , 而指向的即为对应的指针
- 在堆内存中 , 一片内存被一个指针一分为2 , 左边为已经分配内存的空间,右侧为空 , 每一次有新的对象创建，指针就会向右移动一个对象size的距离 , 这就被称为指针碰撞。但是当多线程高并发情况下 , 会出现指针来不及修改的情况
- TLAB空间的内存非常小，缺省情况下仅占有整个Eden空间的1%，也可以通过选项 `- XX:TLABWasteTargetPercent` 设置TLAB空间所占用Eden空间的百分比大小。
- TLAB的本质其实是三个指针管理的区域：start，top 和 end，每个线程都会从Eden分配一块空间，例如说100KB，作为自己的TLAB，其中 start 和 end 是占位用的，标识出 eden 里被这个 TLAB 所管理的区域，卡住eden里的一块空间不让其它线程来这里分配。
- TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。


#### TLAB缺陷

- TLAB空间大小是固定的，但是这时候一个大对象，我TLAB剩余的空间已经容不下它了。(比如100kb的TLAB，来了个110KB的对象)
- TLAB空间还剩一点点没有用到，有点舍不得。
- Eden空间够的时候，你再次申请TLAB没问题，我不够了，Heap的Eden区要开始GC，
- TLAB允许浪费空间，导致Eden区空间不连续，积少成多。以后还要人帮忙打理。



## JVM是什么

- 一个能够运行字节码的虚拟机。
- 屏蔽了具体的操作系统的信息。
- 正是以上两点，使得Java程序具有一次编译，到处执行的特性。

### 运行时数据区

Java程序在运行时，会为JVM单独划出一块内存区域，而这块内存区域又可以再次划分出一块运行时数据区，运行时数据区域大致可以分为五个部分：

红色的是线程共享区域，绿色的是线程私有区域


### 堆(Heap)

#### 特点

- 存储的是我们new来的对象，不存放基本类型和对象引用。
- 由于创建了大量的对象，垃圾回收器主要工作在这块区域。
- 线程共享区域，因此是**线程不安全**的。
- 能够发生内存溢出，主要有OutOfMemoryError和StackOverflowError。

#### 异常

- 虚拟机在扩展栈时无法申请到足够的内存空间，将抛出OutOfMemoryError异常
- 线程请求的栈深度超过虚拟机所允许的最大深度，将抛出StackOverflowError异常

#### 区域划分

- Java堆区还可以划分为新生代和老年代，新生代又可以进一步划分为Eden区、Survivor 1区、Survivor 2区

内存泄漏情况关注[](后期加)

### 虚拟机栈(VM stack)

#### 特点

- 线程私有区域，每一个线程都有独享一个虚拟机栈，因此这是**线程安全**的区域。
- 存放基本数据类型以及对象的引用。
- 每一个方法执行的时候会在虚拟机栈中创建一个相应栈帧，方法执行完毕后该栈帧就会被销毁。**方法栈帧是以先进后出的方式**虚拟机栈的。
- 每一个栈帧又可以划分为局部变量表、操作数栈、动态链接、方法出口以及额外的附加信息。

#### 异常

- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常（通常是递归导致的）
- JVM动态扩展时无法申请到足够内存则抛出OutOfMemoryError异常

### 本地方法栈(Native Method Stack)

- 本地方法栈其实可以和Java虚拟机栈进行对比理解，唯一不同的是本地方法栈是Java程序在调用本地方法的时候创建栈帧的地方。和JVM栈一样，这个区域也会抛出StackOverflowError和OutOfMemoryError。

### 方法区(Method Area)

#### 特点

- 线程共享区域，因此这是线程不安全的区域。
- 方法区也是一个可能会发生OutOfMemoryError的区域。
- 方法区存储的是从Class文件加载进来的静态变量、类信息、常量池以及编译器编译后的代码。

#### 常量池

- 可以分为Class文件常量池以及运行时常量池，Java程序运行后，Class文件中的信息被字节码执行引擎加载到了方法区，从而形成了运行时常量池。

#### 元空间、永久代

- 方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现
- Java 8以后就没有永久代这个说法了，元空间取代了永久代。

### 程序计数器(Program Counter Register)

#### 进程、线程

进程是资源分配的最小单位，线程是CPU调度的最小单位，一个进程可以包含多个线程， Java线程通过抢占的方法获得CPU的执行权

#### 场景

- 线程A获得CPU的执行权，开始执行内部程序。但是线程A的程序还没有执行完，在某一时刻CPU的执行权被另一个线程B抢走了。后来经过线程A的不懈努力，又抢回了CPU的执行权，那么线程A的程序又要从头开始执行？

- 程序计数器的作用就是记录当前线程所执行的位置

- 当线程重新获得CPU的执行权的时候，就直接从记录的位置开始执行，分支、循环、跳转、异常处理也都依赖这个程序计数器来完成

#### 特点

- 线程私有，每一个线程都有一个程序计数器，因此它是线程安全的。
- 唯一一块不存在OutOfMemoryError的区域，可能是设计者觉得没必要。

## 对象的创建与访问

### 对象的创建

#### new关键字的sao操作

当虚拟机遇到字节码new指令时，就会去运行时常量池寻找该实例化对象相对应的类是否被加载、解析和初始化。如果没有被加载，就会先加载该类的信息，否则就为新生对象分配内存

#### 分配内存方法

- 指针碰撞：通过一个类似于指针的东西为对象分配内存，前提是堆空间是相对规整的。
- 空闲列表：堆空间不规整，使用一个列表记录了哪些空间是空闲的，分配内存的时候会更新列表。

#### 对象的内存布局

- 对象头
	- 第一类信息：存储对象自身的运行时数据，例如哈希码、GC分代年龄、锁状态标志等等。
	- 第二类信息：指针类型，Java虚拟机通过这个指针来确定该对象是那个类的实例。
- 实例数据：对象真正存储的有效信息。
- 对齐填充：没有实际的意义，起着占位符的作用。

#### 对象的访问定位

- Java虚拟机栈中存储的是基本数据类型和对象引用
- 对象实例存储在Java堆中，通过这个对象引用我们就可以找到对象在堆中的位置。但是，对于如何定位到这个对象，不同的Java虚拟机又有不同的方法

#### 定位对象的方法

- 使用句柄访问，通常会在Java堆中划分一块句柄池。
- 使用直接指针，这样Java虚拟机栈中存储的就是该对象在堆中的地址。

```
这两种访问对象的方法各有优势。使用直接指针进行访问，就可以直接定位到对象，
减小了一次指针定位的时间开销（使用句柄的话会通过句柄池的指针二次定位对象），
最大的好处就是速度更快。但是使用句柄的话，就是当对象发生移动的时候，
可以不用改变栈中存储的reference，只需要改变句柄池中实例数据的指针。

```


## 垃圾收集算法

### 论对象已死

#### 引用计数算法

为对象添加一个引用计数器，每当对象在一个地方被引用，则该计数器加1；每当对象引用失效时，计数器减1。但计数器为0的时候，就表白该对象没有被引用。

#### 可达性分析算法

- 通过一系列被称之为“GC Roots”的根节点开始，沿着引用链进行搜索，凡是在引用链上的对象都不会被回收


#### 可以作为GC Roots的对象

- Java虚拟机栈中被引用的对象，各个线程调用的参数、局部变量、临时变量等。
- 方法区中类静态属性引用的对象，比如引用类型的静态变量。
- 方法区中常量引用的对象。
- 本地方法栈中所引用的对象。
- Java虚拟机内部的引用，基本数据类型对应的Class对象，一些常驻的异常对象。
- 被同步锁（synchronized）持有的对象。

## 垃圾回收算法

### 标记–清除算法

- 标记–清除算法就是对无效的对象进行标记，然后清除

- 在进行垃圾回收之后，堆空间有大量的碎片，出现了不规整的情况。在给大对象分配内存的时候，由于无法找到足够的连续的内存空间，就不得不再一次触发垃圾收集。另外，如果Java堆中存在大量的垃圾对象，那么垃圾回收的就必然进行大量的标记和清除动作，这个势必造成回收效率的降低

### 标记–复制算法

- 标记–复制算法就是把Java堆分成两块，每次垃圾回收时只使用其中一块，然后把存活的对象全部移动到另一块区域

- 每次只使用堆空间的一半，造成了Java堆空间使用率的的下降。

- 现在大部分Java虚拟机的垃圾回收器使用的就是标记–复制算法，但是，对于Java堆空间的划分，并不是简单地一分为二。

### Java堆的具体划分

#### 两个分代收集理论

- 弱分代假说：大多数对象的生命存活时间很短。
- 强分代假说：经过越多次垃圾收集的对象，存活的时间就越久。

#### GC的分类

- Minor GC/Young GC：针对新生代的垃圾收集。
- Major GC/Old GC：针对老年代的垃圾收集。
- Full GC：针对整个Java堆以及方法区的垃圾收集。

#### GC的流程

- 通常情况下，初次被创建的对象存放在新生代的Eden区，当第一次触发Minor GC，Eden区存活的对象被转移到Survivor区的某一块区域。以后再次触发Minor GC的时候，Eden区的对象连同一块Survivor区的对象一起，被转移到了另一块Survivor区。可以看到，这两块Survivor区我们每一次只使用其中的一块，这样也仅仅是浪费了一块Survivor区
- 每经历过一次垃圾回收的对象，它的分代年龄就加1，当分代年龄达到15以后，就直接被存放到老年代中。

- 还有一种情况，给大对象分配内存的时候，Eden区已经没有足够的内存空间了，这时候该怎么办？对于这种情况，大对象就会直接进入老年代。

### 标记–整理算法

标记–整理算法算是一种折中的垃圾收集算法，在对象标记的过程，和前面两个执行的是一样步骤。但是，进行标记之后，存活的对象会移动到堆的一端，然后直接清理存活对象以外的区域就可以了。这样，既避免了内存碎片，也不存在堆空间浪费的说法了。但是，每次进行垃圾回收的时候，都要暂停所有的用户线程，特别是对老年代的对象回收，则需要更长的回收时间，这对用户体验是非常不好的


## HotSpot的算法细节

### 根节点枚举

- 根节点枚举，其实就是找出可以作为GC Roots的对象，在这个过程中，所有的用户线程都必须停下。到目前为止，几乎还没有虚拟机可以做到GC Roots遍历与用户线程并发执行。当然，可达性分析算法中最耗时的寻找引用链的过程已经可以做到和用户线程并发执行了。那么，为什么需要在根节点枚举的时候停止用户线程？

- 其实也不难考虑，如果进行GC Roots遍历的时候，用户线程没有暂停，根节点集合的对象引用关系还在不断发生变化，这样遍历到的结果是不准确的。那么，Java虚拟机在查找GC Roots的时候，是真的需要进行全局遍历？

- 其实不是这样的，HotSpot虚拟机通过一个叫做OopMap的数据结构，可以知道哪些地方存储了对象引用。这样，大大减小了GC Roots的遍历时间。

### 安全点

安全点，是线程能够中断的点。我们在GC Roots遍历的时候，是一定要让用户线程停下来的。问题来了，线程是可以在任意位置停下来吗？为了使得线程到达最近的安全点停下来，有两种思路：

#### 抢先式中断

暂停所有的用户线程，如果哪条线程没有在安全点，就恢复这条线程执行，直到它跑到安全点上在中断。不过没有Java虚拟机采用这种思路。
主动式中断： 不对线程进行操作，仅仅设置一个简单的标志位，线程执行的时候不断区轮询这个标志位，当这个标志位为真的时候，线程就在离自己最近的安全点挂起。

### 安全区域

- 安全区域是安全点的拉伸和扩展，安全点解决了如何让线程停下，却没有解决如何让虚拟机进入垃圾回收状态。

- 安全区域是指能能够确保在某一代码片段中，引用关系不会发生变化的区域。因此，一旦线程进入了安全区域，就可以不去理会这些处于安全区域的线程。当线程离开安全区域的时候，虚拟机就会检查是否完成了根节点枚举。

### 记忆集与卡表

- 不知道大家是否考虑过这样的一个问题？既然Java堆有新生代老年代的划分，那么对象引用是否会存在跨代？如果存在跨代，又该如何解决老年代的GC Roots遍历问题？

- 首先，跨代引用是存在的。因此，垃圾收集器在新生代建立了一个叫做记忆集的数据结构，用来避免把整个老年代加入GC Roots的扫描范围。

- 记忆集是抽象的数据结构，而卡表是记忆集的具体实现，这种关系就类似与方法区与元空间。


### 写屏障

- 写屏障的作用很简单，就是对卡表进行维护和更新。

### 并发的可达性分析

前面我们说到过为什么要暂停所有的用户线程（这个动作也被称之为Stop The World）？这其实是为了不让用户线程改变GC Roots对象的引用。试想，如果用户线程能够随便把死亡的对象重新标记为存活，或者把存活的对象标记为死亡，这岂不是会使的程序发生意想不到的错误。


## 经典的垃圾收集器

知道了不少的垃圾收集理论，但是具体到某一类的垃圾收集器，其实现方式又不全然相同。


### Serial 收集器

Serial 收集器是最基础、历史最悠久的收集器，它在进行垃圾收集的时候会暂停所有的工作线程，直到完成垃圾收集过程

### ParNew 收集器

ParNew 垃圾收集器实则是Serial 垃圾收集器的多线程版本，这个多线程在于ParNew垃圾收集器可以使用多条线程进行垃圾回收

### Parallel Scavenge 收集器

也是一款新生代垃圾收集器，同样的基于标记–复制算法实现的。它最大的特点是可以控制吞吐量。

### Serial Old 收集器

Serial Old 收集器是Serial 收集器的老年代版本。其垃圾收集器的运行原理和Serial 收集器是一样的。

### Parallel Old 收集器

Parallel Old 收集器同样是Parallel Scavenge 收集器的老年代版本，支持多线程并发收集

### CMS 收集器

前面说到过Parallel Scavenge 收集器，它是一个可以控制吞吐量的垃圾收集器。现在要说的CMS 收集器，它是一个追求最短停顿时间的垃圾收集器，基于标记–清除算法实现的。CMS 垃圾收集器的运作过程相对前面几个垃圾收集器来说比较复杂，整个过程可以分为四个部分：

- 初始标记： 需要Stop The World，这里仅仅标记GC Roots能够直接关联的对象，所以速度很快。
- 并发标记： 从关联对象遍历整个GC Roots的引用链，这个过程耗时最长，但是却可以和用户线程并发运行。
- 重新标记： 修正并发时间，因为用户线程可能会导致标记产生变动，同样需要Stop The World。
- 并发清除： 清除已经死亡的对象。

### Garbage First 收集器

Garbage First（简称G 1）收集器是垃圾收集器发展史上里程碑式的成果，主要面向服务端应用程序。另外G 1收集器虽然还保留新生代和老年代的概念，但是新生代和老年代不在固定，它们都是一系列区域的动态集合。

